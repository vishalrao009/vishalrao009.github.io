

= Try 10 =

First I have to set the quark mass compatible with pion mass/hadron mass which can be done with program at /root/AnalysisToolBox/latqcdtools/ms.py , it will take input as beta and provide strange quark mass and light quark mass. 

root@virat:~/AnalysisToolBox/latqcdtools$ python ms.py 
enter value of beta 6.285
Value of strange quark mass to be compatible with observations is : 0.0783706227423953
values of light quark masses will be  0.0029026156571257517




== Parameter file: ==

#
# rhmc.param
#
# Parameter file for RHMC runs with HISQ.
#
#      Lattice: Nx Ny Nz Nt
#        Nodes: Number of nodes per direction
#      mass_ud: Light quark mass , these are renormalisation scheme dependent, current masses are calculated from minimal substraction scheme. lattice methods are also one way to set the cut off/ and provide the quark masses, the hadron's masses(proton mass, pion mass) are renormalisation scheme independent and so we use those to set the scale. 
#       mass_s: Strange quark mass
#        no_pf: Number of pseudo-fermion fields
#         beta: it is inverse gauge coupling (2N/g.g), it is purely function of scale(a), beta vs lattice spacing(a) is kind of like exponential decay graph.
#
#    step_size: step size of trajectory
#        no_md: number of steps of trajectory (md-molecular dynamics)
#   no_step_sf: number of steps of strange quark integration
#        no_sw: number of steps of gauge integration
#      residue: residue for inversions
#        cgMax: max cg steps for multi mass solver
#   always_acc: always accept configuration in Metropolis
#     rat_file: rational approximation input file
#
#    rand_flag: new random numbers(0)/read in random numbers(1)
#    rand_file: file name for random numbers and infos 
#         seed: myseed to start generating the random numbers.
#    load_conf: flag_load (0=identity, 1=random, 2=getconf)
#   gauge_file: prefix for the gauge configuration's file name to be generated
#      conf_nr: configuration number of first configuration
#   no_updates: number of updates , number of configurations to be accepted/rejected (or it is total number of accept-reject operations)
#  write_every: write out configuration every
#
Lattice = 24 24 24 6
Nodes   = 1 1 1 1
mass_ud = 0.0029026
mass_s  = 0.0783706
beta    = 6.285
no_pf   = 1

#step_size  = 0.07142857
##step_size  = 0.2
##no_md      = 1
#no_md      = 14
#no_step_sf = 5
##no_sw      = 1
#no_sw      = 5             # for every 5 such updates in strange quark configuration, light quark gets updated one time.
#cgMax      = 20000
#always_acc = 0
#rat_file   = ../parameter/sample_eo.rat

step_size  = 0.05
no_md      = 20
no_step_sf = 5
no_sw      = 10
residue   = 1e-12
cgMax      = 6500
always_acc = 1
rat_file   = ../parameter/sample_eo.rat


rand_flag   = 0
#rand_file   = conf_1dec/randl488f21b6285m0009875m0790a_019.
seed        = 1338
load_conf   = 0
gauge_file  = conf_1dec/l488f21b6285m0009875m0790a_019.
#conf_nr    = 995    # this was for l388f21b6285m0009875m0790a_019 file to reach thermal equilibrium and do testing. 

conf_nr=0                  # it will write gauge_files with names l488f21b6285m0009875m0790a_019.297 , l488f21b6285m0009875m0790a_019.308, l488f21b6285m0009875m0790a_019.318
no_updates  = 33             #total 33 accept-reject will be made
write_every = 11             # write every 11th accept-reject process




# actaully random numbers are not that random here, here we have some algorithm to calculate the random number, which will generate the same sequence of random numbers provided we start with same seed. 

# so we have to set rand_flag=2 in order to start from the last seed. 
# we shall also change the value of seed, which will result in different sequence of random numbers. 


# also we can change load_conf=2 once we have reached the thermal equilibrium. 

# ideally we shall use always_acc=1 before we reach the thermal equilibrium and use always_acc=0 after we reach the equilibrium.

# 


== output ==





