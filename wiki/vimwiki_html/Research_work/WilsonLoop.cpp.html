<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ba162506d86ed68821fb45ac962e02ccf596602dadafbb58b27fbcd6648f2a2c623b6a8c74a09b27c15cc15d0a6538d568fec9d36c1c69431d33fd45731a8ef829766f334a485f1de22dc2b7e836e3085c9e30cfe24afc0b2d180d715fc0c2d34295829fe32c0d0cfff4c48f18edd00d906ac4ad8863ba42b4b2380ae19d40f6c43f33c47b39b51c59282659a0692e52c423bd5bc5ca1fc8eb0614ba6e403cfef733471eb1d71ab4d654f84af529eed2fa3bc9472ddc8ec783a18ff930372a2fba52bcc48d4fd2b3ee79f82b1df668ca610d068ed074a0133972994d0c76b12954f3c76c7c8d5cae51c3ff8dcf6e91da855fc16914defd3b867a7ceed0b6bafb41af7b2d60f6dddfe8896261a60a309240269f980f2ce5172fa3133215b3b47c19f44e262c18ab5f2418a2a921854d40c8abe759d14146a2cd436f52e2475d74659d5e374e73887810685594feb19bf7d1836a0416f08a56beb5aa8212a4f26326c26a35e86acc046b4cbf0189603dd95618712bdc32e96d2837f3145a2ccd38a2672fdb82517ca34b64dd9cf15e89973d81605b2a138ec92c21a816ae25e6dfe8ba1a2ccae96882144a33ff94e2b596098558db9dea7f1343fc3cf5b56f5fb096d876f1556b8ab2099cf13346ba615a3991b614f05ec815a37d2d56ad18852965299f5f284d2f20998a37591ab306c26fdfad1b7f14da6354143c67f0a0121d4349187e6242e95f96d81ac8f9e224052d5a83242196f26be2c167fad653cd25fbd43afcfd0b967b8697a35ebffbfb29b465695e8c1b9ea3ca7d713ea15488de14f74ede6871b9ab857e31200c6c9925a6b2a277846a0cca0e5e00aef06bf90e828afa276ec3628c42711e8d0fd034439f21f299372a01d026885178c8047dde08b11ee0e8b7c014af4fde552deb46ee6341ce04521119486bdf385fc7125b8684a2f2a34ca049712f66dd800086629a398e461f2284e73e3e5b3a0786e32f773c32ffdd825de3c1704c8d8c1269a6d68f7b91bacc39c42ff4692f6edcc9911247caf65fb48dad715599ef2cfca3807c9fa6f036e387008291b4b7941db3576934fadecccb464428bf6137d1d6ce8d9ee019e3eed1c1a68d5955743b3e63ad691391588c382b15bcd577cc0b74bd77f9507f49c958ec17e5b4012ed3e842340c1ce786973262fb19591a621123bbf825268e5811d0175507dbe92c36ffecf3fc5c2ba1eeaa9a300574625a8a2c404f052e57d559b12ef56ad853cd7a43ddb585b0b24492ce0c775e4f89022747469b4ef62ac434e89dff59fe2b640bd4500925c36ab51c1beb4ee76c449bf531db96c53e4ce889a8b6783ec5231f2d581989ec754e626b2c54cebc927c7b9452e51ca898fc00ea7372980b69769c4433fe6c9ce8c93d2f151d1dfbe95e61bd72dcb658ee4714c4e5886e85dcfcec0b639541772c0fade46e5dd10232126997c6ca03a8caaa88fa3ab51d1eec6cc200552c626cb5e1048a3f0d062b6608313fc78c1fe23e4f18a1f353da2b2888765fba25bb62480147db4fd2b41218cedc1f100cf63a4cb976dde7935cfb7ab48222d90665c931e4319e446c4d41d90da5c531b24cbfa66403b944f0cc58f1528380cbb3d680267987b09b4f1e1e0ef935b03fc6f89fcb15edafbab794332c90c65c06d4e3a767a136c5dd05132099dc2bfc1ae14a4986ced3c2d3ca6fb373f7e46bd03cff7960f8be9a5cd7b92fa8e5bb566bc9cf83b05c1d95f3afb6092bc96908062672bc01c2836fd615004df19da098a496c7e07141c08cf1926321f320d61a88f170db0e4b9d82e293908745dcc3454b6b999243acad1baa4211b8108d85649779b3a8d053ab46f5eedee2f7804a6806a9c6ff6e3400ea04ba797efbb7da9a6970a84ba8a0a61f179dfd98a58a14eae92f9be105f9bf65ec9b517f99d106c204890c33bc9444e41c7d38ed66a76456c62e15708ae8cd51011b451d16c4862dee70f12be836c32f1e97bc2e33c6ab525a4a80649f06b12af2c32894c2dbed4433aa5cf4218b0ead746ccb3cc4ae8f095dec06c26a24f14ba1abd71af9e817f90f6be87edfbec8a122fa3577279b47ae0ccbd615b18e72d6bed00045d2139cffd180a9d99c497e46925971fb1a0b963ac7f0f123fd6684e0ffa92c6dcbceea1820dcd07ee9311083115132c4b868139ff9719346abe6f656fb6dca086be37cdb5e25186026c543f6040f0cbb3c8c065149f6a5d724f7452441c2afd9a0323d4e07407e8954bf7ffea228514a734341389256fa46c392908af9ca42ab2d1b6db43acd09aabb3016f2cdf5051d14675c701f4440c8ed1a59d40ab6781614e56b652191c1a65a81f7dc8bd8b59386772e2c8d0dd1cc0a88373cb1fd8728413cfc898e0a2bcdf16a58ee5610f8bd9ef558fdb97c0ab0b531799f3f185ef6b1dbdf690ab759e9d57cb4c90e4dc05c8c953e278d32be8ab653b1c5f3f64114e82c778e8f336682309949b6048e0999621db9d0e3d794e1a1f78d5f7d97ba6f1b2faa98442c43209735140eeb689eb81e9c5de777fd4d991d9288fe8ae837c0ac445f2d3f81bbcbe966e256f517c90a5e92750be8e1c3ff1659b5afbd56552e5ed4917fc865701a524245842c8dbba5a8a7a69812ba09cfc06708ace4698dbdaaeb5f1012e281ea702e4b5511fe3bdb54514683d2b652e7635df4440864c293b19b7d01ae1f58bce8e8195270c3701003ea161dda6caf43eb2662d22bcb72b4af00703d18d8a79a4bce1995a8e9a758f39a6cd943ba2d69c7adca748f98c1ebe90a28888ea0a8514ebe7ea84727c7a79fb515a0a2ff3beed7e6fd0c014227821af88d25aec1dce20e18c80cbcd99dcf152e5053765959ef359b4dd1f3f5d3945f73e0ed5199acedcfaa3dadda24fa1cd147a01f3425dc4b49af56683862e3004bcd0f9cb8c2e6c6f8d41a4c881fbba75b928e501142a6247f672afe26dfb803c7d6ea3952867a3a2a1c48e28b176d786c5e1e779e95474315adde49c475f97f758ef968439d2b9d0f7b54d8d7d8df4d4109c74e151410716d6342e6a9713721e444224b5310e3658a86e1bd3cb784e73357a54d698b5c123657318dc3d0560e13439e15f53ee815b456295d9d44b0dfc1eb0646cb575081603d1b8660b3e61d3f94a2e69900960f1ce9cb3c4c9caf8023aa13a8089fa3a2063f10f915ed994afe86298b5fee8f3c87c762ff927e5f401607a0f362bfb9694e3d468fa490274f93c578e94fed185a7a7cc4c6239251bc8e47c2133c6e777881efbf2b646e067de6f1425fc7f65fc6ddb3e96d9be3f46081f57a05d32edf48d9b909cb0fd04b923b6aa811bb463a7d72d011a6ea2f30ed79021b23f345715d235b5b4e447e532ffd0867d65e4d404423acc737c75c3efad78d6868ccc9c2ec7c3da20c8224bdac57c273ff0c9e30fb8cde54357d2fedc35fff3d85b6c4b0f09a393a15a8073dc1d80a49cdcb61e7ac647ab6400aa2a70f80612537e2634a218b4295e53cbb86f0a7c1a54c3a9a0d0cc2b66b8ded94022e7a7e401776a2b8d94e35ae763ea6d2463bf900c3aad1157ff335f2df8b1818b8dae42e2e564a667258af1f56858f9a6669687f00059971adc30d5c36fb8596572fb50e3099d83f0fd5d934d3d8e9d38fb061d3c4250d03c5b39179c10d24ab8e04183ceeea0868f8695df88c787a2a74a592750c9f212cd91c2d0062029d75f4a067bc089dd8febe171700799fca46bf194b37c36aa02f34c5a270d0c4ef1022652198ffb05f792b222d70d0b62069054abb906802f3a5612d81f07ca56a21b15c86af88f6d87f15e56c7b37be6db19e5a0b8d0b45aca257280413538991cb6d8018f7fc1dfdddfef519feb223ebdc38314696ef30a8afc417b70a0cecbb43364917919b779020fc58369ea116c14332607a12bd406449334883a80b49cea674475c82647a9819391ca4d6512a1b3a0605f7de36b01471b09a183a5a3c9954a46347f598d44d1f4353f1139efd79d88cbb9264f127a693e5cceb98189c1a2a0139c5a181d1b23fe9d4f85c2e20baa82a91baebac1b2100ac9f23d05ebc75201d348d48f7971df685709d5559f70c791c0aa8a74548948bee6f353ce53c225e738a771ecfdbf0daf739c7a2a132e8157929b3291803229b42e10e6fc998e26d27df07d20f4c59b65b72edc7a6f98b39bb3ff906d738d99411c2ab178ef3cf49587cacdf1dec656bea6b0d3929b805b790175dc31a8393fcbb27e64beea03d917d612e8fbfff8656ab95baea3e23e0cfd7eea9ca5f84cfd19b35b5fe0109be981a6d60057db089ac523e653c9a82489723da2eccc6a1a9e4b204ff2bd67fdcdae104b8366b89c77d6f8da773777b898b53c22513e81f379c82241be4b988ff4ca5acf3a7806297d7e4782e17c0f542d72dc2d115d2f0e113497a7e1a5dc2f8074b7f8a02176063456040289a779f4074af95b3da467a614e75e7cb36b9c1b3a7b8a5b78d68388853e6fd276e6879237174c7cf1fc95ca4e1afdc43f22463e3d03d0c342528643a628c38e077563881d9cdaf6a62329066059bd8274f16cc227c6897e559b2e84c30390ee0655b77ec192a18158608bd9d9b469e557dd3a738e376ca500f18dd6dc0f41c9e285de7a3ee4c4e47732343240290f400f792869fb88aa2dd9cb8ffdc1f0dbb91896e5fed79d3241e97435017cedbcd4a2150bd5f27043435663d3a19ba2f8969470e2319a99e010e92abd284909c9ec052b8f774f065d03e1b99e3b2f57b7a046d2cab8b30f970d04b351d698ab216d96723acf668d016d98057df7f443054e42d6b3dbe9ff34ed43d8c2361e71187aff281ecdfc5d99c8e53df1c8773b2b9952f444e7d0d384fff0129505d3bb5ddc3cd9f3f881aa4e820b11e4aa61b2bbb36dab51ab001018ef48e2955973b6c642677f75122f4347907a9a7bb2a7fb6c1714e5ce541852cb3bc1f8b75e32055c24c248e713e1ec92ee8de7203598c9513cdca95f54b782b99a0921ca671fad6e336dc5f2bc71ca01ee79cf084dfd8e1a97d9e72634024663a6001bbd1b735039ca5a4686c166bd20463e470180668792ddda813e8d5af3737fc1209804d832a5354a43038561bb664359b3e9038e1ffe47003593adff6aaf67d3dd9e9808b0c79482f93a609aa5ff7aa63f5c2a0da3534f76e736fe72edaa48443bc5db2788b1d735fa9bfb8503cef51e26012c4e1b7f05190f0d2b74c4de730241c568db5e5eeb139351ee7a5a1f122bdc8ca5a3f96d2071e5dd4f5cb2bd3d149997132c610047a392fdc2b89787e8c15dc9641b6206cf50af021aedea42c87ef1cd937bb6d054468e93be059df7b3faaee0b979998e684ef1382d438b7ded827b0d0b08a9f95098f200a915ba0ecf95fc963ddc185ba8988e5c5bab0b2dc6d0c4684bb9a6fb09606b9b6c37ffa12c8a90af06f7cd57f2c7d0cc27a45e6689476d6be26799b67aef201967ef54a19fe83ed4419a6d5e05eac7e8dc2c91486d284ab79074e5a1a5d3bd887593730313acfecaed27a2d26f6b79a21897c7ec86f322786c4c43341c223af41a2cb90196a6a2106b4cda5b8bfdc2b790d87fa570cafc24c3acb6314d034ca36e30e8ca58d3f6909585f62d227c14f165e5b578aacd072f4770cb3fcfe0648741891c0d92050cd355651818b65d4bcb8986231f1a49302f06d95135a88a450367781054d46dbcc773d76d0a51e7ecb5a07e3de5f51c5a6547ac0b5cd1565ac7184596fdcc2fddd3c39a28f201aae469f0d761c9e2e41a316646789730505ee51fa55c0e272d8d6f885b071c9461497aca54d7c77db961f03f5404f3d9d998ce4932031dccedb962e76bf8c31b4fd45f364e4d872eb57b40c0c0e51152f7baf131fc968281781145b93f133623df9476fcef39dbda887aaebffc3d0a755c48ea91265ed637daae043caab9560c8217bc0a9b0cbd3c7b33895e4ebb860d973b6f1f97e5dbecda51839379949e25df0ffa6bc2237db3ec1e829b299ce431709568121129a409e53f3d7de5d1f131bd6d71918202fe9dc327c36eea29ad8d3beabf5cad16c8748f6d7487ed7ee3e83687ddc5e7ff2a29bb0e8b5133dbddae3bd7463db106daf0534a99413a30fa8efd08b92ea231dff7cdf052faad49672f4f1b5773bf9de5777e3332a9122e76c5b5b45ffe616b8b67bf6873cc79e401abe04695171bd5aedf41600dc7110c50e1d64ff0cdd6f5621b4a493680ba91ad19028978a13e4d816af2980620043964e700f9687ad7512e9f638251dd6ec42854dd11eb2f5bd0e499b215c41557c477f413821e5009bbbad2f2d034892417ea69b28aa0a64b6d4de561571bed61d36fdd80fb387c93ce679d097cf9740a342950bf5792d5f9fbc0a831cd5e08703cc64bff7d715c471627248c57749ef9d59727cd271498caadce5c7b1e0325d93b08de8756008e4d78878d4a8f1f823b6463a60bfa441541f5e703f96edfb51e0f477a8afabdb08ae23233383718f94da7457c0b45bef10475d221b7e1015fe18dd31e656c3a3c2fd77fd1057792b202b04a1bdf1124c5d3ac14c3b424bf6196dca521b847f044f4157066cb2a2ff5093c3fd85dffb3509e2e82b28e25d494f331f7165dd3ac24bc45e83485270e467f2376303e837b4bd38c13659c58b2c6cb9ee2169221bcdab93e27477683dbbbd553398bd6e3a77c5ded921a2f365f06da3caaaa674a58916648c87ef44905866aa65d197ba757f04c4e9701718751014de39c5cefe817575fa50a40a38d078282a93bb54780647034ce323da2aab3062ba800df1dcfd802943dcf849d383e1f5961e26c3fa2d4b2052f45b21c7d7a725326820e0b26f0a0ab32a2c8c2c4d6b73b5e23275e3c1554373dbda5685b8e66929a211e5b09b091f028d516aefd7c46022da1b06484c0bc9f72697c8c15e2d04b2c9340ca4ee4026d0779e07ee863b73c1186b35984810f4ce3a969fb53db1970442a118e4631ff0198edcdff0f6a30b115edce2b052eebe89e73f4515c541989baceed76c323dd5091348480b24667c0e16c38f5efaac6c48b23b923a339a6fa3e09941bd9e661f0be5a7a94cafd74ddd40f892e1b493baedbd25471cc8578155a59d43f75bb56563ddf35aff1fefb489dff11801aa5b176a4b349858e2b5f258e6af91423f2754cd21f361f2c880d8b482eb0ac7378231eb8e2426e48723699e5b128bab05def61e59129810cac4f276aa1a30931e5e4192fed7b240283de6fa739f9b5dbddf188de6776f3941b52a69830f0dcc191f36e055bb8524e1de979703322c68fa80a1f9134bca115029e29e506ccc5ff9d48eb5e486847cec7ce08ae352d8f89939966a183a768038cbdeb465d1f35ec628dd4b06bf651f38e2412abbf339b8192120c1029b0dc94ba3251c328b521f64057aacf008201a3d7e5b7dca333b94ed1bd6db4ccd2a2f976c28560800d6f5a6cf37a278d66569eef2cf5965f5965e551b4bafb9b53fbf706a027d87a3318d8ee6c1c956595c14d9c2f8917111865650d8ac35ffca4ad070e1f914bf1793115a0b3823842c2a0ec2e9de87f2371f3ed051a68e4be7c093c7c088f1f11d8a5b94d03b0c245e709eaeb0dd15380c3a720fff6b65d62c6c0d52d18f38f5e607cf7b89f3e8f5e069de144041db537a85be86ef80a20ae0b81f319b0b1769c6209db12eb1f0dd8a8d8cd23bea39183411ac332fdea1124a68812c084f37f402cd75d971ff44faf9618e2c13eaf41af9e87656d38fdf64de096593f20ebf2cc3c4cee942f96b761d7ff0fcd7f9ed270ad81b8abe088c77c83148061a16f08e09137fd800a6c437cd48ca26fd973581c5c70db608b33c52b6f58fd6c42be1ec7f7b53ca2191dbc9e83511c058f7f4a5bf7fc596168946f4d35caa24c35b0960df211fe81fa7832fba8f7f6dea46a98c09227cf60bafc098fa95478fbe9f5adcd4633f19e437ee217fde243f7b9498fe101bd2486ecc1839e597728470186933b15a2d69a7d27c1c6324ae3cfa49665c96dd486e6c2f334b194ac95acce3f3f289be4cfc7e29cb690468e3319958917cb2c92b58bfb148f2e9906c3c5146f4d0fd0a8913f1a9267166686cdabadb7053599f29fc36724d118a4573d1fb8dc6731676110cadce87c15715d4297904dbd5f97b6597c7f9c764226e3230f2e41c6d8356ef11cbc713d543868fb4ea02198c6767ca16b5b0c12a86c93aeb949154ef425d4f4b372dd0051394e2f76665a434ff8492927cc0c0dcfbf4e8baaaf449c3c173f0e9007752a3ea1bb5d449f3191d2ad9e8461f1888e7664296ee31a90ee277977f33ed737f8ac55e4acca357490a9d4f40ef380cfaff8f725e8ebde8302b724bf7564acc6e1358b1a273f77ab807165079ab25785e5bf51119ec917f06b2505b0e2084ec68e97f04fd080d3fc73bb90a43f7ce2ab17e11f77178b4260211bf4574ad0e011dfbb756d82eed5db9446b095c390c6e966b5192cb695eecbd1e5ad619b913f634b323b7f87870e0b292cf3ad264c18d80f8f3cd0882508995147818815c57e2ea955eee3dbb908a866d1dbf642c7f4f85ee552f8e0241382c8335c2749def7011c77b726c9778bc5dc25ff6fe1b13e4952d3514772f91d44941b5fb4ad7591027a7e0c50e17a7e4e11264e0023dd16e55d9be05dfc4d4b42d9e4726c25cd8dbbd6015e4e85f53e06cfab5e0f92b82cebf8b2e81ea94120aae300a13aa3051961692a978c46410e10444e9c1c3d934553c49a4df0fe5e45db9fa26b0f79da46ab6b53d61d3baaf70abfe48d74bf7727c7178af8122b4ef0134cd34c7b12975addfdfba1e742942925bb49274ea9bd2335e962eb5d00a8647942beb7375ab59cc7e01b3da515fa1df5ca158dd163985aa83b39766f628820f5a10e736303d9de21b7df24e723ae82e27518aaab7a1df6a2a36d285f9f66b234ca112da6998b822c330a66b2f9c05551e763154dfa118ba147cbd491ccf3cadcd0c4eff3e18baf5b207ae10bacf420edfdc994ba13d98ce63dfc65edf88a083d13e9404a46934fb437c37bc705de565c7e5de3281913ccbebf1f0d9b882974dbceecb6b83bde7fd0523e1ea3a59aec9c68dee4772efd7c01d2919a3f509902a82f6f4edf8960bab89598aa22d6d43c427343fc691c4f1aa04cf26a4e763dedf99c3a2a193c3ade846ac30f577e9ffda8b0c48a1daa1a6cd827d1de5aa97ec712570662698a24c20bf7178917449606064801c543d85e60d4769e8977b23b3cc070007e22d918687c186aadda13ea527e0538cb8ef5b69668d1c7d70950b40f7e31506789741ba8dd02e4544c1317162edfe413fd20846fdffcb665a3cab8313e1d95480d8faaaa21830c810ab0c035fc6ed05e8006a20809e8295ce1d5178aadbe763724cd4795c307d9d4fb6dd76af5614c081fc9acb7caba245d9f5a588bcdce3532c0342aabe7ac36012a23261ec97ecd4632611082cf2ea831916b019e8ea4b819935312db6f1204f1b24de841dd6b4c0c1892cb7fd50be14286b4b890bd5499f3739815f8bbf570afe366487e8415e74d6a6ca1eaf9a2725e32d87295d33c06e665ba7b498ebbe78d7d1bf357a00efadbff283c08a4af6ce6d68478d8e47c9988e785615a1d934be809c7445964788bcb1ff78dc6e6dc0a2ba0daea054132c8978fbcfd1ad3bce2b40fd3f93289bf72c1b3c33fe84fb9a56a7f93aff505a77897f2f620c7ee0de0a94d5d12472700a44ea7f8b902ede8a6b098baf229fb8b1619c99816808b002c74bd3351742ae2acb4500ec73deb0d4c195935949832c3572d8b8d91d64cc8892ba3d12cab7a4e9fd4f2ebaa8c946b7cc6ec29f6841c1d532b4b4cebe5ee93845a260dc0bcce2a55ad1b4577354ee2b1c28d2893c46a3427fea6c3f4c7bccf8207bf103a4bf77c9173652966c1f2db2fe8417126689f4ca16c6143211745d1502dfbcf45503d7e8325afceef7f310cb0c1b19ce61adf47abdc7e0765ecd11f2f57b15c47b6aafc5feee2b755cb8d8ba99a7ea830b81e068ea5134cb9642da7568e9ce97aae763e0d86098c1e8df672ab976eb5c0c7ea0592a58aa547a79ae582ba02f76796410956f998e3613a7505c192146e8439feaf57fd297d31240e591e7a16f1394faad061e9584622a7543537e348193562cf04cbf45ae678b0173a53e589ffa9e882af8731284df45e05dddd8c19af824774b8236f258d68206793de40caaefe3d2726e815f40b6b6ace0153a180a28a1901f44eb73598746b5850f9bcff7b3628f62ace9036ba364417b4d7ab242d2e267a98c6c045fa79cd8fa99c34af96cc1a764d880164de62fead60bdbecc7142fb788c7899fa5ca7d104e15b5652307e0d27b5cf21f9dbee69f06741c23be04bd7784bf1d4f8a124a69b954112c7b445c5bd9b7af069b9596478d515d09cdc6986354c61475723761499057ffad700db7b0c1e8a1ce63e683a54419fd61f19feb34dfe2ead67f8e549302c138b1463d04a98039fb018ef80dd1afd0bfb5f188f5d3b38d303e2563478b9efc60480e8b34207951455d955ad7fed8e86a148f4cc475ad4fc54b0be843d1e125c2b0bdd7b0e935698f2d6383bcbc106b5db3b7999b5d5dd4570dffc1a8210154681c5219f354ae5e9d7997f096d22aa9a8fa98a40f20c1e156135f5752acd23871f221ee2f0499505c231f593d9c5ecdf7ce49297cde1a99c99da65418029b0a6064fcf0e1c0733f60bc91d6a13417cfc4044773433f19a54f58e2567254044e4450665dcd56008c3bad1547dc877024920690d3d6eb481cae67530215398b111c8b071bdccb3ca9c654eb14ac0e862f0dbcb97561da9bb6cca34359809352f6e9e441dae0abceb220e3b36496f8e653927b166de6afade978a2ef658b29b588076a995dfbc2a8b808a8eed6b117d702c4070da29d8de7337f7348fe4318ef364d9a65c3b4639bd8e1d788044720342dde57a4aff5a12e51acb1b37f7ac0fb66aeda389357fe83c4c75ae51c70fa15bd54532838618ffe769032f605ad162e5a15a7f16656877a523a28a070f7884b2b7d7a9bdfa4c7c152d994ad6abdc95df3d52ee148ddf1f799b7b34abe3baaef39f2dbeb65454f73a85303543e8a953cb48e3aa4c08b46db9064e91acdd9971296048e89e555d55456","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e78898a6ab07019c2b7d9ef05e99b905"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
