<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd831b1a0f56ab35838630a4439b1fceb8eeff00d5e8092b3ee35943c853d8bc145e56cb1a27477ce670f21ad336d53dbfe33eb625fda35441b3ad60fc7656f70b37edc0103ca68d281737c1018118a48d52c376fbdf68ea2ef89f325a8eedac7b50a804e26acef6021175c9ee7f5c4e6878acfdad4bb9fbe624db0cdafae79ff9d3259917d3109be9ec762cc125843814f642c53e0000004e306ac73e42db243b33d4df89e48f1f2d00aeca36c8960c9bf347922abb6cb8f3bfa7c32f9f5c071a6d077075cb0f6b2ec33a1795c28b267ebd9be91715000ceef3e71bacffd92cc5489f63adce33fbfec6195cd6d5a3ef83588b8a573308c1e5ebe7ec54082ae192366b47aeca7a196a5a94efa311be7baf41b94572c189bdf8c04a68f8202ba59da05c575262381f6e6934eae3e2b2899d2f1923fc59e9e7d251ecfd60f0ae50d7e49bb97214b9ab8c9f0c22121f04d1df62b6aebc7ec7b8adb354d82d44568251e3697faed37e3c4f98f8f5fd04ac584c14b0f6c7540bf1acf26983c767353eeaf0505f1b4ee062e7c134a052b2f7ec039aea75ac4b0ee0714479e5f29330b0d1449a17dd2f30494d08d8a26fe894f601214205cc0a3783098fc064b6de2959112c5fe1777efcd62d8fd8a6c2bdb43ce622b9e57fb00ceff8ea10e64a51d31ab5d197799cacc56e2009b9b26961177bfbeca7a71be159d8ee6f18f24634d0cac8ef88fe3590441d55ab8b62340e376c67ec7d40873ff0d66c0139af4086b33152bbc395dffcdf469ff96684208a0696758e6d1f3269158de7dfa6faa680b524f6b279035e1196b6fb8b446aa89bb5f5bce94632f92a19ef589deb164e41e02f58fd1d7674ca04b33d1e85e12cf9e9fcc18c0d2b2a3ee300e91134251c8e60a0926a9bd1839f90a2a3a857c218cb41eaa55bbde57eabf33e5e185e457099a6d17d5cfda48683d23ebe74018c703560cd4571d2dcbaf139da350fedde468295a469d93a8e2237b72af5fcbbff2d26982a4e37e43a3368adc20fb16f8f4fce795384c2ba0d4c4cdace310734e240496577bfef6f6e51ee28b99adb5692ebc8f9f5690adef1de17986aa8ed6fb9a805d370a91738f38a015dfbd40601fc549696b5d9d1f267a9df4c824c04ed7edd847cf3ce99080e47d25d5a47216f65674757915a16ec5cf3b5d628cdc9d26094dab005de58e9602ab118376795caf762340d31acc5eab0e07f355ad999a11d5988d4c6bfc00d5e655014b3856529a6e0a2df76407f65de76102e3aaf8d32f1a612f8edb92e280975d7d4ec003bea74b57b1eb8229685f3e6bfae14dc6188a309c62694ce29b01ce71d1c20542d49e276cf8400567fd1de73a230fe558d69f19e63800c42f01e84d58c06ec6c8adf36c0d3ffaecb68afaf1cef6eb2b5a92beaeece01257ecd0943155a9e9645474c4876609ed34e3e8daf5d6bd53b89e98f8d8ba8e1b8e5cd7ca9f5efb6d4c9659f230ba0819fc48f7bb1cf9e801368e532494d6862871b2ccd8ed671c425d8a298e584ccd0a383cad8d450cfac78e2f13b217e3b2fb942a6b83d22c2b60a2634b84c9f31db1af75d0967521211e91f7f2d84329089d07d2f82c5e3a10cd5cef45ca38b2d4307c7a9cb958bd2df1a2d3999ce8360a2b8f4155cddd64a5a8823c7ac5f47bc38abd2fc34233ebbdb14142c339c62f0d12760a2d2769a98bdbc80e9c74ddceb3b0421dd4de9ff386e1a989a0fd02c9ccab836f99df2fa174e08d6e7b23ad2a28410da45275be8f354a9a3c33d56ad60a69b82b723be57820074f57064f419b2490dfabe88617550c817c960330f84ae6a2f1cb68b2336d0d748b63fedac1242278039a80990133d7004af32a79ce5dec1350817014d4e206496758d48b20f8fea1ed95a9169395401dee02f8ec56fa86be471bb7e948371eb63bbefa9340630de49c8806e55d7dc5a03f02e7992b58190cf80acd421029608b7578a598383970e6fe806ae8be0373943bd012b05ebca9022f46f4ca4f7e3a9b8d49890de1980742823a421526b8c6533276e29b9d2ecadf384639b5e35ef3ded3da81028f9b1639d27dbe14ed80fe147ffbfc37f910ec4eb9a4d7dea826eca2e7912635784bbdeb214b358a3f544467e0a4fa61090f50d2a7eb3800622a6f25ea0afeed671ff7216b65ffa5f5297cfec368a619d02d1a330338333de33be7d401168f081922691081527271abab55ef10d0e532b64f7cfd542668bfbcae29922555712963693bbbcf6e15f63e1c4559d23c6d8bcfc47d11790df9185cb97d6aa5fbe31d553b88d74288a506ea119167c172035ae00674ba5f77c6fa9a74a55c13f3e36876b285000ede4fdee27f7d0502925eb0057f971609018aa150d1aa99d698d1fa648055edf58a6dff9a18d2734627367590e4ce72ab695630e4c12926373dc8031586b3efa782be7297c5e9088d117868ab0f3dee90b4975903758e2a300a665b48c231a886dc7569776a29261d7d9ca445b4458f975c7d998ad5480a5fc893cadf86657d8d421fde65daf9ae831757e3c958f51b89e8ae7b910fb6aa63b5de8bad4e0f3314ca3ba6e181f1b1bf8caffd2d9ef32a4f2cd4e8cba962010cc5a527d9dfed16f9c106230b3945eaa488f426755a90e765213f411a5685daff3f2346552299535b4549221c479c9912f461537d866e8980456d2fbbcab843d112c25a0882502e420b4ec355fda7c54e54b44110565c4f83c92e52e45d7550da7eb7af97c6ee4ba062a490f2a3c6b6fbcbe0c0c0512fa4609a3a4a3c9c37e597b0ce1ac5d552b30eac0dffef57e0215f5793c02e91edec3cfde91cfd00b2ae1411158fc15a19ef08ca2db2998bf632574e3ed598d33660847e82bec74fae2a0fd288db8bb36e1bc4a46efa3ae505c7b86f5e53bbc2fa7990ce3cae8e448709b1991d87109a176c24fec7baa148a45962477f31fc51b738501db8e2bb2f56dd359ab63d47854b5b68f54185894ac2997d36e52e3583b1fd0e56137bdedf2441a069c1b8f8bca4fc7f181e7fe42f7006f59858b85bc679e56a808caf73ce4ee56c87db4d28b49ab21153e4b5ce4ef19d74785c5b07fb6f8479fe27e62232588ce59d91a5db5d662ddf59986ab5211f6f34ba314d9c4284449e19a29ca1eddc37aaa789a9ec56a321c3ed088895b2f843b5646af007f5f96c3ff51347d6fa447d60782d21e958f03d48d694b56eba294427497e480b19801016a7af968b28078ee619e70984e13ecc1784104790833201eda5a9674bcfe9fd1533df2a6552d0273091e9740b4035cba1c7cea400bf9ab7469bb34c9ed84da6749504e5067be0c5010ac368213044848c05084a2ced38503fb8ea0b3a0920b02d7c0f4ed14ef4b2fa593bbdec10f6f0aaf69fd2827a16fa9d74743b79556c1ad161ada00f59d256be69b88fdc23ba51e96f9aa8a5fac54a1ff579ade2fba81cfc3ebbb5c9863c22a57252df6598705da635736765ed77f5b35fcbdef32bb2dba8ddaf0578d1ed125ada47062c9495cff6a8b797d8c4de58b1c617bb41c600b4bf9771384e7f6a48f3a1f918946bc4f1cb4cc4316ae18415d78f997d7ca22b5eb925dc24cfea65cf21cd2f4748edde6673bc1ea17e3117dc55d3cdb3a8a51a991693a7c66569754d3aeeabaae6d68d495019493753fd3048b610c6628d6de8d47be5f93fe82ac8cfe7c953ff858a7dd57b2b10e522d3576a380d33b0aaa6966101e6d8b046cf5d8df72ca7e93fe243695235e7dc7d243c49e60f947feec0beb96182b4fd7c2325cf80b3acea4bcbe2219ddc9abf21e91beeadb06fbcadb0286fac1a34495d1e9961d8c34b112844cdae2c4560f7bd389f615878d612a84e9d6bd11c54b21a06c3042d0af0559722862f977bbb4bc3929e82d07cf5f7920f679613f07c2e1991da58bcbadd2c05f8c5fb7402eb66aa202ac35aa3369809e7c8a6bde5b56f8d08f2d38ea1fc7582ee868445205f74901b42089b8d7d376acdae67836254baf6948fd1d9f9b1f7c5b19ca897f3313cb7a4ed35d141828f96a40036be0f0f2115431ab16fae4c35e40974466c2c111f0e2408d7badbd93f022c9fb88ae46caf0f97cd93cb54d69667a7ceedbeaa452b95060c64c968b1250a212b3263a0c699b200b5ac67c64a85a5877a1e1040fe58b4b8ee1697925b22650be23806ada7df9bcf8f5a533791c706b83a3954446046203a8b81312e53f6fa02508d4016c8d625617653e541fb56afe370fda44740332213bd6fe35cfa832af1de910fb9382f4c60e4a8e2c350df300f91b61e35c4243ab5e14a07cb5028896f89c2e55dd941a95fbeb27257190507661b662e316ec7e4fdddd375b73f6e78ed3d3d6a66ed1c9516b92b8258e2dbae408af10729682340523656af08c982022c442527016daa4f73ee974a4f6f84c12583a66ecc0108c234568afc5d13191ff0e1f5d72a882421583c980301bffb3b343e8ef5b90dae0055765062a76a1055554806c8425f052047b676012e9312df93075456c6284e85c6db1d8b0add485b6537af4ae5819a0dc0202fde2cd7e71fb6c29f8cc95b9a70a3bd049b002539da7aaa049b2bee0e2ef124b58d0e1734a79286b9642c6eb4c47b20046bb326b318024d06931bfaa9972bc758fe53024091bc6adc77deb3dea1f90f95c373f7c3e5398bd010832fe0524958e39d92b8f690f4b874bbfcc0abf6d327428d16ad925210dff92c421eb7c3dedaaf02b9cb3542b615079192c7fbb19bc219a83e1ba0cd6cb1e73fe84b762ce1de84f085fb0c45b91ca62099f095dc2f26f909ab1c4b87d09c968fd6afccb59da7c0809ff1c6e4ff0100e039b2dbde66783059c0508f005d934976dab4bbd5b1bd75e050cd5a775216f97ab2890cf5a3355c002019c6e7d222107b5f95c6e90c21fcc83ad138d3d9256b3d7a2ef0eeb601af55318b4ba6d7b7389925deab3bcd3ac7da1dca93b715c50d119cb30ec6f8e09673cf21e5e2db6ae120619677a5f12701fb0a6576c3eb55197044c1b773dfff05b8020b79914a920df05c5799ecbac085f19fbce26d3b2758d697b203899e4b8cb0e24dc47c455527520da5c22922efa60c3029561cf3c34309edc23c522ffc0dcd5ddcd24bcc1067265256fccda462d89173eb1a9b844ef2ad88ca49b9e781696ccc7eddfec22c20e935a935b513c80bc446975c4ef8682a8364f4e99c86bb736229d15cd98ec04a54cac9cc489aba37d7d5b88e4bcd8eca7884d4dfda1cf490d98e6df99109e518765949c77354efe9ae64512bed4aea239d4734b584a0598f0a697b563a6a155dac96ee1af155536d8d241f62ccc1a21189723410f06ab725afb25ac8244475fb5d1e9a78f5aee5dd0814d62ecf5e5edb06954beb27add8704c739ec24f2775a82f468c0c295e5d31a313057e220a28b569690af82c00f4f5a3760b1c1ae043e7c8377ac860f7c3a72a273fc98fd1a31cf3eb74f1708bfaee002d91e33ea212563787c44e57252117c587a2ac2e08a757429830f6adf61f868df6fd5527e751a412a8f1328ce8b2b704a76ee3c9276cf8347b0ce47c599c6497eb34d07bbee44f4650664f2582d2567f1ee0b2cdc04a0757e57ed7592b3639759ae56d55906dfa42cfd3826289825e210c144d878d74c52ace28cec51e97469497e5c75758004b67fc91d75d352fe11f92508c44182771dc01a7bb5d81651e4f2f49d3d7f95f16cf6d76c14af0406c17476fb9013dc11831ca049312ef101b566054ae392bd403839f87f4e5649b415e8746473af10ffd89b928887cf73c07deb263544650ad63f6072c4c04f9501d6f6d6f318c826129eafce010f33812f13567708bf845a1eb66bdcc8d46281cbb8972b676fb0ac3da0b66d9f781a5e23bad5c549cc21add732f868a8132160cfcfcf89509ebfc107f9c0e32834e21f2fb0933be2006290f594315aaa862a1db28d423c536618412335e2e2a9b9063778e358e588033d0fdf96f2ad5751d1a555d8e770294c2c5bbe49e2059bbfc07fc0e463b08373c4d6f0d601b1da6ed15af673584c90d531ecd35f1d4695fa4f78e95385231017c6c083bba6f047988036f854ce1dcdcc4c77f10ed22a94629759feb40f8d82bb2de1ef58e37b68e0743d3398527638ed081cd7b3987e5b4548f0d0846824d8ff93de1a47fb01552b0df4af10be8cd576d9498ffb8b5f62aa919ae117c6e847a6798d406e94d55381b30da58b8d86fbbf582de954a802c3bcf53c1699b7acba3967e7657912bb883b83d4f02c0ad55b1426562ffe597c54408643aa598e3fa23710cfe7add3f6691597fa06817c86ce2da8447457411a21b72ca5aec71ab290d524a91ee92f0d8357fcf693402ac69c153fa80b7844caa541b75c21a1446c151090d444fef7812f2b90effa155b72a23fb95e473bc4131381e36771fb9e3bd9f3a5167eccc9be07a22dc4b58f68ad6107a6c04d2487fe0de72f7a137a08d351858f7cb0534ff9396e24310888905a7fe30401e0af62c0eec04e34751cbd3c8e67d35545553adaa379cf6ea7f8adbe63a250351dd273e1664f16bafc5bc001ec453c359793289a24281ed1e9e7be9e25bf920b06e5e908b856eaf1d4255f671adde59ce40f7a61fcda16e196ffebf835ffdc67bcec29b11f9ace8c30724e8b43267fe5b3775c7dd261574b96e0869724194c595b98676454d2d0c7653858d55a6ea1facb2e56b938c90bf628d7b08825e01ed3492daecd7df438a95f27f5a7c644b3d4fe099e2f44ed3d42497a8d0d4847446b4766bf11db8770d60866038f6208f5e581fc12cd413495dd60f9e6cf369dc9201cd88792ee6432b5788b426a6547363fba0b15c91433635eb666a69020c8e2cf2c97113e67f5a38c77f544a9d3f40e21ef3143c39da470ab0900f9bd8762d68f9b16260d197be726c7c23489b439552a4c4637367e5c9d280b771d5fa5c878b48e467587823731d49bd323267e584a6b6167382e8761cce0e560dd25bded21b3defdc2ca044f080541d50299f1d2bae8240a728dad7366eed0b83b8abdcf25c00a6e6fb363cab86cfd352a5c2d8994bfe73cc403fbed06cdbce636f1b26eaef0bd01aa7e7f883736df178871ff0ee3da215bf0250f025e21940edb1858e7de76800e46b7c9007371bdbae16151a954d26f23cb5b88fff667fb9a7a5058ea08370746194d75c6fc650f53568adfd1bdf3b58cd2b69c967a22ff2f9836a12fc254686dee0beb88163f55d99b646c90b265a14f91d0e1068ce268dfbe7ad3ab1a87eaef7d08b8bb364587cbe0f3608b4952ac5870af0fb110ff866be9498e7faacbdab660135102b39525e30dc5581ab28c78d16096dafac74e834015ca2eedfb7401a02f41531f03b28ac153a4ad63df23a683f5adb4bbc303f72b62cd9c2113b2c938483cf8562ae1c5ab471bf23d446a8add1baa43dec8276cb226d1ee1f79378d34e92bf2984ddabc937cb9653b45a0e598f3c3dc58da25311458b7a29fc1b5c363985739fcb769d15db2b97e46f75c6d350aaf3ea408f1d7ec1f71fa97af20f3c8828e10cfd1a48d7cfaad3c048c0e902778b26ccf8fb91f1704cd6fb8e962f6ff0302b99c5acd4bb073724460df0f9a2a4464a575b4423c09fb8f53b319a894dd2d4ed5c9f8cdbcf70c1ecb14a179447a50c1f082a80e3f4cb1ea319f54c10c4ae5bc108d7034303c803d428d29df391fc009fcb9c2ce40ae4d9d20a046f8ab3ff966e5bf4a503798acf01fedf1e60d6e82f210b37064bc0b64e7c4822320667d0927b8f463a7bbc6e2414325dffc23317722674ecdb7873dac17c181d2ab8d6a006344e9c066482220a2899f110822f5a5f6298dc4e8d4cb15213af05e721efc29b2f5a1374e2b4e78f13881815a08dea58900f76c7ee0d29b22b89f25475f84b5d793fc03f698a25cd10cfa8f9f1d5264923397ddac2d44c8f41b40d6fd18d0e61d74543f92692f33854e0c7807106b22ff18f75c2e44f0b0dd68460343b02fe67cfef87d7c933ffd1c7d98f332043775d7b0854b300fcb51e335e79b7a5acc8862ea37166014ba033312402335fde744a64597589ce190f73fc432f40fdce6510d094aba83ba3ee0081a5c3efe22fa39d46b8f7537d9c9272e18b124442674395f131ec17d04c1f0adb0702a21f55e34822dd022015c4e07ea1297f92f5d112ab573462113a9766897684295ace9df8220f10ab683a8414e5fb26469570874192e994442b193e0d32d732cef8baf11a61d3ea68e2c7d158ef46c57c32f13624608abae03637a21bda3daf36d9fb85203c237fedf46504ce4caa1a22a2707049d08974ddf029cccb001d450f27060a73574d6e09f3b2a2d2df8914eedbe14afd06ffa31a99f7ce9d3fe9c56693ea63ecf724b4d89cf0f01c46fd19cc8172e998781329464fe243d875ba63f0e52b27e50e97088a2d12141a7028d7695019cef3e48df403408323e13d70e04b4d1007067931ef54a7bedebc4f3a24fa772f21363f37658590320e8ef175610c07829d5b6323c50f72b2104ac224f7abef3e9dbf5acc1394a076fd4e3e0e2e3a4e29d234a7cefc60e56fb6a514f1e7dfce4b4fcc2f3c5ebb45e5551da84c3d0c7c6495ea2ea809960f21810c5c0491caf2a12d908b8eb230695c2685d0eadb586d8d7440cdce9cbf5f3044ec99985d717b6e62fa52f7b8799c4f3dca834cb689ce1076f3b1dc667876d7e827f11daf1224435706abe17176d9d904b77d39465633b3744504674734329ebaf8b3605313ae12c80bac4c84c713592003f9e35cc0bf7654d61271506ea31f10532c4ad8bd6b4d2ecc360e8e4507842037a03a4be29e148da3b89af5964445eb72c7642a4bfb687b5bd8920525d17e92f09da41b5a89a9d831629ade92848e15134546d9348c2fe32cae069d96cdfbd0521019b984cf71ab3fab69dce311a218223517a4a76fff4c16b7564e7f383ae33a6ff8d94b23327cf1e3868527a3dd36984fc8c6ca0651907a16891d2e9e6af787ed28bbe08224373c2bb6241a3b1b6bea822297cbf32d6bd9fd0601f32d707dc9cd267855f12075b640025daf45a41193596141311228e2d80bebe94faa77251c95532480e8c6ffca6f616a6ae390752e96016d37708a20e4ee2853c593d010a242fcc0a9cf122f87bdfb221e815ad14dda771880ec99f1926dc6061eead2d0664c945782f0747711c8aa96e27975dc295d6a8f6899bf2bc08881f23583b2833ebb3976b78dbed4c463259f0af720903b629b5187d0c1ae50e2159a91e33dd3eae033fe05fd5353f8870f2b19925da7b77379755f089faacad7515a5ee6d50c49dbf8ca5c2d378bf5a217bfdd4a8067c8d05486c449d73f86c6e689cd62d16b46e05fbaea43476c275df59810bd7336ab9978cb349fed7614b2c1a762d139a040c06e37f55e2c56d646d45a5355bd4472b46f2c0fcde264d01ceecec5488145f8b250accec8514122f829d408a96ca570f258559d4e6055f2ad3e3386673d1ab7d9bd05ecfcc4b5f34fe2c371cf153e9ad0190faf808e70cada2dfa6832a97c4d59a2d893e31e0ca5ba45648f1abcea6d742c9afcf3bcac4fde54063af490e3e95d9490d608d3bbba8fb8bb8d425948fac86f4b40c43b6c32bd325a61afc00bfaae9f21c8ef304c5754152a94cd20e379bf04e982eb68146908f4b5a61567a6814b0e643cad5c648579cf2f3bad89a70acfc6290ddb05d6a4ff7d8f2e2444591506d24b89c206b5468b84d9152b4416cfe3fefa9dfc6d0d3d08852ed6e40f55597bad1510e980e305d401ae1b6776adf52dcbb3a1abfdf81e6d23bb6b76c6ccd386a90686439c7279f4862ca15efec751862094ce520ce70285634fbddfb47ccfecfc7ffdcff0797b395cc4467af656b313b477ffa5b5e156e3e699681afde74ea1d17fab339b6b3ee020fb165e158450fea4abe18277570dc66c0bbe510e86847c45d72f9ef8af62f6051bc8e81e5cfd9b51ae262c8921ee2e7fdeb238595dea04d5ed90b305af785f58c63d9ea257379da208be00d79ed677549385cbfc275f4f59f1351f1960e4dae66e8de833ad5acfd3dacd355b5a87d980f670fd2fdf6331d97197fc6d19e43a7b92f53ebe9c2c079f67fa133c81aa1511b724985a116d6868651d3158babca860751b00c526c0f618e850138a0b731486b2b6969f8a568a7d10147e242db0b0059db809c91a95242893647949d4711ec9214415b6107cfae545c9a2b5842c36623976a7427186de8501178246aff9884df39c3f3f07c76bf728611ac553d6648b072a22cac9b598450b56e6c91e6d2cd2dc0ff41ce847e140ff8fc619222228e942254a2f29a60e509c15da4bbbe226ba5aa8fe33cb91ecb1c846b7386ce4046cf8d7f6104d7c0e215b1789640650974faf1e4246f1d647b05136803d0c8def22ba120039b6ec27010a9a8ee6683de6a8783f14d30e2377eac2b99443f7d68a2b2423809c2190c2ef55e06c3e1c6339e3d66457149f090f6a331bf4ddc92029cfbe7ca2c2b31cccfa1b63510beb9bbf5f851d0099247d776fddcc086fa0757f0fc1b84d35281ce88a7ab799d7e2eddbb50174730e5a3bb6c69cad8b0a1c3cc615a92c19e1516c3fe5317ccf81896a04015597c9ef7107c3239cfc97137ff3030d901251f3439638cea0dfcb95b42de751d0952f737e54a9bc8ccdbb823a135be6e5f6226c3fc4fe2ab6edeb6e3c3f1ab7cdb21cc23136cb7bef55f4b2f16937deb94c02bd57b0b42436b9ed32d8a7f22f93df3e759d0ef13f3625acc1dbc2a772545c6e315e785fcce1596a9c0889b97d148ff82c5d981b5cae743bc8533a638989e598f3f515dec0c7be046565d0b17809760ca5c09571886236c3ea1aa07a607272c709d48892643a244f23d7b24fb2768e39e1ca99dc0bd83f6fcd8e9cdf7ce5c54e619b1b6eadb56cf2322e6b28b42460397e77742592399a29e86b4949ef53cd8646521e8712c5f6dce6b3d2a90ff5651a3bc53d3ddd00c769897317f8447df7bc3ce019ed225c19b7978c517210971d11951006d22ba39acad9d576a0d986b1ee3844edb9b55649bf7e17599af5319705563abcc1643abb9d0328afc556cd3a803946c46d50993cd253442c2e4885c6cfc5f46276184597843eb902417a74c2aa9080a548593c6c99701cab490998a3cb197af5d672ba82550d58c10dd3bcf7a89dfecd854430b2cac09822efc32443fe58ced2c687bf5b8f6076931c7474bd28be6d0617a6642ea54294e8558fd2904a3c67e217c9330b9a93c97","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"e78898a6ab07019c2b7d9ef05e99b905"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
