<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e126da82356c57ab983dd316a010f0eee3c7091cab245d420d12eab6ac6a51f9b1bf2151a2169ef9e347d27ef320588213ac26bac086080a42e812dc3c08519b1e4db019762a1cd59f7aed2472cc5b91d2b6476cd4553b48e7f35397b14bace5ef0c6941441b1894cb62bb42e38ddf1236908a95e24dada81780653f6e03e9604eb31f5fee232097143e58dfe7df72adfec9a0e82682193aa448260e7c73bdd2cd41f27c8c978e91241e951e62369c89f12a4b97a485fb4dc6d11560faf4358dd3eb5dfb6cc2ce29f154a001ab7578738b12c4f150a3a1157aaed6285661d7144db13e788c388b47facaedc80b025b3e60ca6aaf2aaca2f0564d07450cfc659db0da33388d2b6a693d7fd71b67d699de0267adcd09595d9b41863fabd9d7c2526be4f3334a08c4aff5f1455cd80817648c9ca594c2774d612f5b610cc85e975b4d88457fbc36aaf1dcfa860495611d23e1bb0584785ad38de25583d3ddd9be8488d3dad8389c48da5ca8b295ba62531df21e80e85a3f957eef76d9580f174fd2040ddaf0945d4e0afe27c83c1a311ab789d0ced7ee6fcb0fb4ff047c319a51291f2b3200c3926052c91bacf269f02791632050d80958dade507dc7870332b452f6c2704b532ef4c8de5f6ae3f99965071591eaf201dffe2c967a3bc76633622a4c5edc51a6c45ab4c5ebe3492e914951be29e74f5c6752053983421c00469c1c8f6b3ca5ff4bd9b2120b0c874d3413693faaa17f05d5f7b4847be25712faff199002d719c84b39674a78c41718556d399e6515c58ba2c58b42faa021fe6c4d3b3f5b0f7ad6bca4c96f19750d9fa57210168a20c8f6e51b289cc15ee4cd37d2de774d3654d80415b222dde5a117976399f4ca4d259cc85e37feac15f4fd65aa2381c93aec4b13eefbf59095f6034d1c9ff1fd8f1aa57c3b5de7ab9c331e86b90012b5bce95c4aa218291a1eb12018ef2c9e33add1c526f0cb85abd1b80dccb4f1793db06c44c4e455052d438f547718521e59d375c68601ea9dbbf5d14c12b80bf0880a8d4b0265952772ce21ccc2610e8fc0cfcf66b426f4769e951e2dc3a23f0f3d6b8662f55686c7c7a67bf1878c8c0e37ac543e438ce40ffd7ceb97f4b4338eeeb6a44f3ae872081a4f2ccbddf5569368da63b3e28f0b52f9708c97574cc1a3be7ae37988716f8029237a2255386df48bb38b5d9bb40c9dd6389295564d88423d414d1e8e9870ee8f93a4bfaca76048f02dfdda34da7f543e87f10bbe9ccdfcb1cb72741766da31cd897cae953dbdd075a2db19986d3484498ebff428a84c4d015405d88aa6cc47361c5668f7f9bff5cd5ae5e33702c348e1742e67264511a9359832b79079a95cff18d0fef85a9e6796b89e914510fd86c2cfb65da160fb51b89505d964a7847aa62d2f517077fcf854a540147dcd7ded11e35bf111ccbe8b2234bf0b42f3616d41300f2c346ddf6a1cc34bdedc80c7d0f2b30ae5c5309ee635e69d2de219b0de9451d20323a013f66f55711b86a2ea25aff228c5b0bc13201fba806c3abc5788164c5633420c6b2a9436ec247995e47419b997367deacd54d60b555286e5e5a1bf7972d565ca346a5d3ba290bca1b4f3893fdb13002edf46e8cfb7bcfc056e23a26b57a4d48913ff066d857837bc05e509d2f4e75889f0d0458d297ad50d3fa53f9bd39208702e50d3d3edc3160c2ee0a892f40d94ebde6bb7b35e92c3d550e6eac9c027bfaee53dd19228a085af9f47137815b91d70f3a31a7962cdf01b7e6b436b241b1854c73faefa46dd2873874081216e4e6937716003695486f2c1a313dc55c379879f5dee95be6a2e6517708309d11440ca545949f021aca005862a8c141cd32743435cc98e3e43d59e1da2896448f52afd96295332690d40c1205d489278aafd89d7f89353a55b3da81d65c16c3624c5212c06f70b867fbb971d777bf16cbfc69c542cb823f874fcffc729c583e6baca43f0e55084d85d7a271594248f3f5b810eeb1045d4e726e7ad76c22ead58a741e1407f2f39b0768d9fb106255a86bad786dc929855979891563d72944cb834f10efe9640cabe4542da9fce974c8a7e2009fe39106e0880d7358cb0f13960083374cb5f242931068b6d94cb604bb905feffece3c156453eb0cd66a5e97f2ff36d0c5a7b3e1695aa8490529d44c2129818ab7345ecdb7f3960d1003033a7075914e67b669b4ed2de59d52030023425dddf9b3f18d2cfc7b08eb33979f54581de0f3796dbb12512b2c4b86f4a9c05e8a8cb67d7e7d766fff3409811741eacd72da19e20a25c958372f11353cf9618326a563c5ba1dce441af0987539a5715484db1f0c2b0f845eb2e514299b5174597ddedb965d5827ab2e038a741c12a69b94818d43ac0ad359bb1b73db470a9b9787ab3fd4f6ae1f9e3154826400c64f13f64a53d5767d3a4b465aa7a90949dc746d1798ea21c0405595c308f4851706bbd64206f8429fc085151a1f1f255dd4ff72d95658fd93b7676dc5516df8fe56cfaa143e7f10226741cf9fe402f807c91b5588da00974939fce2fd40c4635c40b8b3562693c30d9c30a225fdee31c2cc16e350d338bca86ae2539f30efa3e3f5b09b45921ae2341fe7b51b36e7f85c13acd075aa268c142a0594a89d650e28ac213ce03cae579b5778bd88d3f72da0cc3e3490dda357132b7eb7dd2f40353dbecc7d0a5af891e5d58f32d3ff4e50b51cc25e18a80a7aa31b0900a1dcf9de51a5a09e6082106c0437b3c8f86c84a4220ee0725ffa593dd36bd6082a9ad8179b98a66b25c2af71988c1569a69ea1354e2ab1d28be786da19c5b6a48fa0a2e50c4b46739eeaefbae3b1d175c856edf9feecc24784ebdb248616ead61641245e047f77b2c7ea1a94dc0644f1f22d2d6cb0e54b6294a5d3d720286e14f5cb4902b1c277afedd757bcd3ddc2814a111cad3f077b5df98d0a0ce6e3e9c6f058c5ee843af1a6b211a31ce9d353f6d7a4c99a3894df7fb852330181cb4b1b06443f4f57b9b9578a78c157fe2eabcb1644e9ce2999691358483998a851136ef890f58e7fc9deb18833417246af6e19d179e762f8f56ae0fdfbb1f97f659075b75bfcf69ad7919df066ca45abad616e755f5ab1a4439e393d56e22e67eca433df93a2cde0f4f3148ac8160010601fcbbb4b231a2250fd45b734bc5268b88c2d5e4e36b6577dd9e03578ebb183888fd5223ff11a61c6850831d81eda90307b657774e0178f1d35d3961b8b4243d71f309070e221b0e5a044f2f70411db1c1ec21c1b26e8ba5238e5469727e12ea37302173831785422161bc6eeaaa6c14b11d84ae3e1c13dd62a21ef354b5d3ac2000ad5e04f473840a380e65dfd889fb17258ec15739d44f631ddce4872f7638f1857ab41e0ad15b9b0c4e892d80ffed7f819b8042476dd5eeaad63d9ee5afdfcce1cea674413139e0eb84c36f62d71435a261ba19d20b31c0b9e8b285aaa5577327ad11504c86192362d9cb2055b1b76077c267ab26cc897dff69184d83007d8c2a83f604689f75f70d8cacd59f8f6778e52a07de819693597961771ac0e0c3656dc96df83de733372de06a5a8e4255e4280c9f5b2c0c65983c9ef50fcbbdfec824d70764c983ac50279fadb460883f8e1b766f0cb57d51077cf6ec8865dd10626c332dd824ec48d6cdc0ecae41c55330330de38e29814237aeeccabadecdbe2fa9281b68f8fd45e3ee5b6240e5e6e7d8788d0227fcc99cd6c2521177e43f16ccb46a10fdb5d8063c51d141c45b74d46bd8af0a77bd8e0c0f28a9a258c65ea2bfda0f265f36f873d584349d0ed6467ce38a299f6b29523183e7519c3e580fa276d9d95bfee59c0ca0a05818eb04374a48400ed7c3674aba35ca7092b5ab7624661108376f36aed6d3d55abf85c7d08110f61b0ce94459f7c9a9507a35e526b8e7d9e4f9ef6c38d3535838f759e3346ff0f0461d427a2d04c6f7ab5741917e5c407b179bf303d01ea731c5a531671a3e9683b0ec8550be650773f675334f6229735fa4f0b086b754d3880217d65c89610dc16dc0b4444b1c4408eb9d441b027609b6dde015a15d4ead155eece822d3f114a353b4538fcb5180084891e442e8c9949fd923537d2b7a7a6da1e810941e85126b3418a70fd83ea4133c7628e7ec670f046c2975714848234825a517b5a2fe0471540088aa1df262dbefdee6e553341708d1422f687f834489338af6de92cc0778964eafbf48ffe70bf3518301aeaf69a952b961cdaec3a1cfb6355e6636cfaecfbafcd448d587a6eaa1086becbbcd7c116e4391e08dc8b2c443ef2ae2e7dbdce9c5c9ea8f4bc534b9a88b908f535dc518563c293e3d909553bf69ce2f2fce07d39d008a82f8910988b11b00991614a93fbf2c956211d12859c3016d017060c532767d954d95a7755c8e079774956d84451512c44878fbb24493a74eafe1830d949d66662afbec6896d47db0099ce750bbdef03af61e0c0ef65722b2d92baf89227eabef9a87902963808b5588e5dab92c167dcc28b2b3f13f7273b8aeab04f2fddc41baadcadd6780fc4ef5a17ad10be7f660d93592f4fdfd4e93b339042996a58e9d493500f77568485aa7cfd55728ef0b741c16540388aeac20e4e370282ec2c66cdb598dfa3558f7ea0448a29c198a63e4e7d47bd118c4c1b7cb6ef42823d71989b887760a06af00303ddbd218489b052221c19e5e14a5ab6cb67e6caef9888397af763cf2f25ae936df4e1578c70b7c8c8e17da8590c73a98c5a794987708d3eb5aabc1555d1308489012498050b6f39d3905d0f759b8df917c903a3fc4fe17d49da777792837cd0a43a048ea9f6ef22b7c9fffadf034678c73ad7623485e9473ef102c757059c3e8acc1ee064d28e6e335676d8024053fac9739f75febb9802ecdf6911af5eeba8239baf514e9c459a7927ee14ae8936daf2efe1e9adf353a19c57836d983aae8bb9816a11f97fa639e6416f0ea767baf798d64a1c68684355567b1e5ab7be590a689f8e914633848210e49b2e9a7b5cae4e17fdb28189a3b315a8abcac3028cde5bd43ef18920e9ca96fff07be513ddb2b5c2be45d81d08deb78b63508cc6e252a315728b893a8deb94885d1d4e248214e2c80e8d5114997983f1a98649341744b6b5bd3a1ab9a68eaac7687a81479e5ae650196c822e6f6fc2645add25c214a2d8eeb77459e2042dfc50fac6609d42b7b5d94a4b772efa0444af962d99b1fee7f942b83ebdae0a842cc73d53d4ab4560e62e5d1911ff5a7dc4eab686131eeacaa433570ba8b76ee5eaabe9e3584830205e3eadea7645f1a7142e9aaad7ae710354e0cf9629ea08df97bcfa12eb2e5603d01a89bfa0571cf5ff2f2c512a6afe69928383307841b87149ebc9f74f282d2157d1abfc97be0a62c185e4e301ad41e82e63586b1992edad4eda3ab552890bad194445ff0668faf7ace19539d2e3edd005a61aa6b7338353ae1935ba691d3adc53a3948cca096286daa31d2a2a65f9df7f6ee0ec6bd9e435e84289bfad911fba4492cd862984f1062aaf494808500470f524e958b478a662122e9b6e73173d876c145f95889ff54f267e7fdfb5d20f3d5f455ce70880b6c36feae8b1bd4e8628a85556eebdbdf99e7050a7ea271ca5aa52501c6fd2389f50406e668874a7cf3ce8aa93493f6efb1cdfc8796a5e902ab302249a1e090c3a1a0c332325ffe44664427c834ebc3bbe0de94a1bdc2ddb958075a8430b084522d4e96b754f2179c455244cc3a003421167dfc0cd2c7cffae5887c0f0436dc67b9a858960a5d7aee56a39b26fb995d15c0a12c9c7b3ed54c489c2cd43c6879a7a23563a12d014c46cc4f20f50081fc613555fd317aabeb87021618b0382d6c9bb253dc351e3d3a4df202cb3917f8fec7955703fc7f1c73dbf777d53f65a25afb68510055b63c08e05a11299d8ba8c09d33c8d5104a29428b73ef5832c353d1f252c6ae82ed346d0561f10600d38dc1210ad44d14fbdc00eec010bfdcfefe56bd7128ee77253a41c6f93d52086eb2758ab8ee1f8ebdad0c9ab85038b138fa37c30bd3c12f4d7b9ae70edf95b1b0080bd615ababb11c2ee71e49640725bf91aa22ee3b8ed25297a1b1b4ac57184970e3d6e25b0bc735bf97695fb4d02defdbbd5b9af602b1aeabfe1eadb18bfb5cde1b5438081fae62136fb7afba9cc575515943145a80f4bd8fa13a73af5e8ba12665d6ddead4b2a62ca8f2c345287f0b3ef7d2d4754ab85d1652fded2ee6c18f97edec7f59de230bfc8654d5083cb17ce2b86dc1a68dead93fd86efad725b34398a76f6e0c6ec038714f316b01731a431fdcee82cc77d447d5ec31513f73366f955fcc8e121ed5059586952f287bfca1bc8c38947a024628592bc270516d72ce8cd97eacbd2c1c99b520e8ceb1c820923fd108d15c3d13bd7ab46d1c10702ae446b4d550fd2e6bb754b6f5541b4d80dac631149e129644f8ef8d24acbb254ea73ff7dcf393320ec1fb06992a7833a8d0af8531ad71a18cceb9a85a43648459c05a5beab992ea70fda8b6ddbe5b7fe634a9b27b7556cb6452cefbd8c5820a5bd11525d42a230016a741454095f7b1bf3316fed8f9a720d7884807e032e87ca12328f939c093968cfa4a578634b7140270b746c3c080328afc36cbe639985797fc5aebf7b2b1498d7d07111ef0207ab7bd91f0d83748fb12bd4a7291f713924fb49c734392d744d48cf9fd1c4c9a03ee0378488263923585ff3868f80038e4416e2eb87b5a5e97188e632942ede9364c508f9f85c59d5602bbe08c00ce44d3283d17241712336574c31604083cdf287462fabe1c3b2824831fdd0956249a824a7f8b05c554d617ea51a10fca9c254877208c07c2259232dd4dc387d3bbd12a718d3762a203e46fbf47da4f679924fd6096d84ceba2ec5ec5d33995e7548d44a5f01d865ceb4f882241d6164d8960f42364d0092509ad123cbf89e172ddbd084e64ae3dbd31cc868df5d44724ce4ef856dbc83ba5d72410c5d8aaeefc00872cf5a95e93a2fbd3d6813e15aa6f025b857f91f2da5e9d1bf1991e5b291612a38c85727edb829935bee386dd903d6eb54e31e600238b38e82112642e1762b17458834d854b1a87fed4e79b1a47415a59d34691b4b3054fb32e2f2b718c182985c8614c11053ab61d95758a1157a000b278b9961342f205acce34746d5c1cf5a862963f977940f285686e0935cfeab9c41e18b0a9d8e409a03cb947b9aedc303b739908ef961f83180bdc0a501e290b44d2e10b4cbc6ab21f1bd40579031edc72878bc66bc41f2d9301514d380026b60cc25ecb9c0ca6d532dc2bfcd1b4551b6730fa93efe35aef4a1098037ab87df60212cfabde9e389aae9ea97e37ba1140920aea1ea6fd81c9270176fa79bfd0d4203be48f27bede8869f9d600edf9e2f6ae26066a365496dd56410469f6f05665810fe9d204c64517a606345ff180d62a9288c5ec6e15b4b3cf15630a3cbfcba9c37b89675da6dca1970c491392c0ee7c180d81ed427d7fb7ba42d4d387b1764ceeeedd69cc54a514fb616311fb89dc1fe30eb1a32ba14381753dad81117cad9f0b20159aca3a7c2681b4f09a73081014eada957a963ae4514eee5ffd08999096cfaa99cc5fba87cea389092de5e826e78fbe550ece3ad78fdbdee92683aa76178a4008a72aaf3aaae19f83c8c508f0e51471acb0a6269b63130607e369e7b358419730f48d430a05fa54a7b702ac4f497f3c769be32adb787bed6b6192f63f414039a46e2adbd4ff1f201c3cf1ffac2c8bf591266570383e33b869046f7b00074806415b107015a880fa2cdb5af5a92230eb67ee7b09731a966845333442fbc0efc54ef5f9717a1c5b3ee6dec90a5609335815b3bd9bbf8513f0fcbd15ddb89af378697c950ebfaab4beef5c1fa7aa67d1d6efc72f6dc4cf4b12a071a9ed6d0afe21e8633440176358c56b09b6be5618c3cc9f89d17cfdaafdf56ae14cd0d95c93c3d6c3fb7bb4b5337332c12d7d0bc4443eb9054d40fcec0645e0fbb0677df0ae6b025eb161e96838f4889ff7912eb26a73e2354ae1e4d50b05fa693fa57d431e4d90a4e4261f9a1ff4e9ffddacc325b037621aaa990ba9bde9f62154de1981575d2132a1adcaabba8010463ffe6b8b3173b87039c203cb24dae4d81326b207d805f91d098b3ee3e5142a195f8da5567a524c488e3ad81d677156088c2010fba772a4d469acf1b8d40919be35886911ecd88dde383041290289c5680a2ba7cf5908a00ad09489ff9036321b9d776c05bbf5e98ffb8ac02eaa667a3a13224af2f8325354650dcf41d2492e1855203dc2c8d81b559955b187e640999a9e66b876e2d2fda9860a5895d5bd4c8492dc85c364c0c2f4e9a80b12c8a5c93159f631678a4553658cdc8deb712c3ffa4de6d5bbedd92458029156875ee532bd5d62bc0765d65c4ede3eb73df070320521c690b74ff9565f23d1d7dd6e0447014ef51dbe75628b156a740df6b82f4c72279699fe034e998c2182c5409b1f9402a8180383f5846c4465c617e67c7681cd7b6db9ad1eb1e7eac08abf4fbc5ada45767333473ebc52d79587ac9cd5b1eee34f1fe884a515c0591640570dbad244822a7c4a204e19c2f9006c729e7b5df83e749273254c8b49eaa2570fe8ce0e14ecceddf0b221eb808c12e8eedc676d8058984f8de5fe6525b6dd91faac76aa22aea4b8c17dbb136277eda36740eb7cda2fae8b2fa2c18f72daf1af0c9899001dc4bfa1423d0aa70c2d3b6eaac17b4e7d2a5858fc6cd8a32cecd59bb3923c90cd3e9711f1d7f52fe060ae5e0f1ae4ceb9531c601b9932507004ad2da521cc391cf46a41c81c3411b923f467df5d11ff57945e0f203673c63d1691c3664ef09eb55bb9c9dab13508595cdc0fe68bba4aee522fc740827b9daf470e61777dd9d6d6066545cd269f07380b85c01cbd7530e8597df13aefe055bab3f238441f04f4e4fd2f53557277c19fd867edee78793c8e68f280b711208be265fc589d43c2e0753a4bb7ec3d492e16e31c4e7eed7864933f9ab15389ef982fdea1554968c1be584e0a3f351723623f66a3fae26a3d8ddcce238644290127e57ea9a814564b0b59df1fbcce225f9b62484ca55b97e66b23c6aff9bab9d7e169863c6bf95993886cc92226d2cc8e2210e52425cab5145070fa2a150aca55feecf9974da06addb19ad291715329de8758b7f3343e2c17ad72c37ff896e1e5787faa64bf1aeca308af22fa41b145dda5c00d68a25b65481e40c91115d8d864a3e461759edd1a72123c6caa653d73e1eadfb50d36a9bfd44ba81a4674f48a94e56015fae3702490ecca2f0abff32a69a366d3a8117f54e41d763eef082db9d2911e9e5c12b157e5c024f73654f4e434e8bc8a1966152ec1c3fca815df4048cf2d15e7ef337d2b92bdb2dd495491e935c67f29cd9c5a69fe06bc6496e91389243b7c83840701f56a83863489af7fec756955b541c80479d9f796591e2ff6d616bb7dadf62bfd9503faa6ab78046fae4d2284cdef8f3d028a159d9082df738be6167b6a77458fb3d9edbd8bb01b0a947a146a7aab1022ad918073a98308152fc3f0baaa540785bc7558a171dca761625eaaa0b41aaea36ed31e81f0b7217de0ada3fdf14d9b3ad20addda1fd378e85aab4207c45ae691992b5aa510758867a8637b39949495129797cd411e05ca19cfec95601c4f12c7361c0e6178aaec81d0a5914ed2429d23c0585291cc087c12ba228806ba7e48394e9d0d95fd007a0a5091c667bcb394d72f3dd513403fe9febd706f3fbb4299dd8d66687d2fef872c188fe1fb57f0b8523d982a7f1bb4b9b250a96aad740c00f51e8b1bb9167cb09e40d236f849dd763dcca2f1ebc567f026162458b3bb24c59c960385d304fc94017013fe39791ad5427b17c91b277bc9ce3e57275903d1ea93a2c03317963dffe0edcffb21adde4bcc0e00e36f833613af725ca88a4eb3c7d6b8f99d0a849cafc2b4d16b1e111a0048325ce89719b3ee77c2d7bd0e43649154ea65c64edf29ba42134d960a53996c0e3b04b3abc589549a109af555b5062ef05dc3ad3cc241835da0f09e2c426042a7c19c3725aec66b4d8bbc5241607d6e7eda2790ae97cbffba11dbb24d74d7ee58eabde7b94a4780e20addcdfaef357bc9d936ce9a08378403a014a931a5e598838207a3ce4ff1e0acbf68fedc45b8b4044880df2516cb81f0e56ef9602823571e438b6513cb6148aecb7c050cab4719e47d4a0ea36519c82a8c7dadbd946e9f95d3f256ee15d9b42518d0708b6e64697622bcc1facb75ecf180b80be59495c4fece552876ff87c47cad53a54fed8a283addab9d506dcfc7cf862665fd86b33d1c9bd881222d343dd828093372765d8599d51f79f688fd137114ca6ac53963eb0197d928f7cdd6814f6e76fcd4478ca17faa582548d48ccbdc40a8db4ca0ba4845e2d803b5141aee5e9e514f234b44fc23aab89f53add57904bbf8d450468eac9f648fc87fd167d0fed114809d2b8bbde477990c7b2a95884c44be9d78386c27e5baa8a6b37eea5cc87ea68ce1269e82ef7abaeaae56127ceb92b6dcf8e9b28587f4bd7c75dcf2ebe0fa1564be8927e2be553a526faf8753538d2cfbdfb0719061ec51246a4db1f8d8d995ad538cc650cf1ad9c653aafcff29c0fe19ffc746ae2d02dd090dd6e4ae3aeec75ac294dddfaf46b0192d35403f238bca54b51afb2ae3b6849eecbe814515c672fab7411dc725d7630e859a34e864faaa01f90678c4246bec5dcc50b453db4e587fc768348a811c6406273a9b8696bc704157909b5203c82fe0f5364ca510a7e571de6b16b20ef78854b678211b04fa42b7832860ab48281831616fd0718c9cbc580d46","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2be9fc7eb6ccb3aa2640bb18fe622bfa"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
