<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b565efe67cd688d1d544e8d0bbe366b63f3be26ea47c865d4688b245f5140039d68044a6e77822a4288c62de95de19fa16839095e1df72aa5095c195f3e66b8fce3ab2e6d7ff64e55b8b3b4bb1948daaa06746856bfdd10a4721fd2f9d874107692fe4da1ae0cd17fc9eba86334cce7939773989c1a04ee5c27355a025a08fbcd0b478d498f7d2d589cdc3a92293c301d9c3310db33688e892c93bc5f10bef5b69cfb52934aa14c784ff379f8f48a3d78c8baf023f8d7a859769b2fff61bf886cbc0f85a59e61180820fa9daa1ff43836c1de529654f79ffccb95be0c23b89a60c5d76d03dc8b196ff0f6e40796c8b777cb7478712e457f3ed54598608a1e5d3151ad446422907967a896ef7a21934dae3b1e4e3365d424756f7aa6375be887db44b981c363f6111b713ba059921d3789098ccea33043fe3b0f4d5c304087793cb9d6f0f0fcbf61f009f31685eb5fe111dad511a6ceb8499e452009e5da8a4b0798879c0a14e5d7f5fd4239d182c18328123b20e3ad9626af346cc6cf619ca6d270e872240f67e535030d9ac30c60f272c0c54e93409aab378a8533130785aab5ce199aca7f157119be960512a45d5770a17444f6b57516938c136d54709b173b627639c3af58298151003aff7cf417f7b9a393c5f05ea12a7e8848e7eb65cb75823f832ccdf287f9e1267a69284b1547905aa9f2c423f05ca3bfd98ae457c7315365c3c21f88ec85ba8883abebad236efbc2e01d2b8463fb37cf0cf954c3aa18899e33c6589cc59ebdad4bc129d52a200ad28b02ec383fdcc7c0d992aacff5a34f8d60b0fbf674fc6e873d3d972425f7f9ce995260674e0c06a23dd4c278712652d53a9d05f43798af0c825eedfa6d486d8f4f4dde4c9011a22269a46daab7844467fa11919ce5e919e6fdd36456cf2a5c94ce0df8f4cb358fac8e32a8d2d2f73f20c6c02f56f00230f4ddeda0684d700dccba7ee03c5e00e8ed9d4c8d8ee5e26582cdc45e39bb8aeaa02f113bd9a617ae8e5a17d495991953f9fbd4f7bbd38d006c1b3c26bdff66bcebb2558d5fd133bc0e272733149aa5ba45b44731935ca7d08ba4d0b01d1913f53484b6748cb66a792a65f9beb5eb51008e61bb5f18b2d01336d75c2903c7dfa8c16b455a4551bf52660a13df1784cd35f8c78ba8d20d9678613e38985b5616094081be2de3523c96880791ffbbaff3d9915c49dc31e0364933f4e83c2096404eade6b0aa23385e92a17ef0d4db830eceec4eae21f6659451f5158c9781f20f09a92c1973588acaa5f34f2d9a2ce93e7b828cc7f2a84794bf74b593cbfcc892261b9298dcf504c43fc095db7d6d49f0e414ddfea6f7903c9e6a7b9945a9875f846179f1bd6a85cb207eb589514a867a475b08d02b008c1ae2fc9d71c4b512866befdd82e1075049a06ea41fd1177b942ab3757e69f482cf63d9c54f51ff295233ff7c63580b1035953b3c6584d2f6a942ac00ee659236de0f21efcf8ae79d362a313a425ff14b8bb9f9caa0ca9c90a22ad9609ac65ca51cc7170c8fc3d2b8a66a71fb79f2982dab9b8de60f71f567a038b252ffae5b203c2858abd8831bfa241a1cd39071079b744a221fc0d0da21445458cc3970454f6835132208788f4458419e57bced5b034f8c272f4fb9b0f090226762594afbec6526f4173ff0709813981bbcded29c030179bb4002cdab282b31f61868d6f912698063a3770075a574f92c6fbcaf5e773d1e5637dbe1bdd5b701af6043246a50319cd3e01b19a62b0901fa0d972c4cde9d5a5c7e4578546b141dfbdc910c6e287b154c94ffe7eb29cb2be9b42cea5a0723e4e413d8fbefe7af889314fa6d0210c279a0fd08a8196e6838c8d14cad393908f1a75229ab3215e196ab4c016280f89523b29b66c53837985de16ecbfb811abe5e6204d4e5ceb5deccdcea76f8790dde160bc77b1457be305d9e102c79b479b14e5d0ae364746ab0b76c10ad44f9d89308af9fbfbe15659eafd24cf7f4e96a18f73bb09610aa9d0d5abc9498088185a41ad50cc4763a560a9106f13db014e70f6f24c2f928cb588340b18c2e7ffd1008d2207a74c9ac2c676feb3c4d3a5db75f9047ced7c551501e6c178ee2dcf6b4670d2591a453c5a5ae4e2436e982a04ddeb189a1505b05912126f7485c2ed58ebf8f8aebc2798e964eea0dd7d86fcd98f005d6724c92a88d18d10592532212ec19b0f9b35719f3ccf1d5773597ab7985883844f6a8ddedbafc64639fcd699e3ad1f07b8a669d9d63f6c11e6be5ae3377397ebf958e7e81145b443d41d6df11229e969d1ca02a7b41f193cbd94719f9ac72ef627c953c85fb76cbcee330933e8995b2acf1b8bcd7306c209a3cba2cfe842823b868f4feeed12a42d2267789ed7ea13c9557af094f969a968678bc2b73f7b76f43eee2b1edcf02454ae137bfb4a2daed1cca5db45a6429db3e60d1c6a46bd89af8875fc64436b7fe67e9b2b2c10ad7c572054dad873b6d699315ce449c82f1efa2d2f81242db207d6f3eed24ed55130842fb71acd8d43bac785bc47b69cc8e43c8694f36ed826ea17a207aa8557579b834bc3d8efc727b57cb046ff0794a898371712f8b3cf79bcf663b8fb7d782901ac6929f2a6f7590ae1f9257f661296c5ff3c4e2d0726d667cb804dd55b8b438fcfe6725a5e21d8f61114cfb8eff88a718fa302d8279a35ae5099020c7e0e049cdd8f1d8645d4cd950a430255914418c9e3c75634a39febe93a43bc507e764d1dc6b9ed9a728b24cf59a9951a0be87a1a15056467ee0d2667cd59aba1ff97833a6fa56e167931062b1a76926c78863785e4b7d0b621df6332d7d14a40baf893290358703de2c563cd19ce2c570fe8454141e127966eb0093e26043b86001521dcad0ae4c4f72b9912be26ca5fd6a0a4c81820b5f5f19df0ae5d52663b57c6fed026acfe3a2dc1522826c25b6ef321322bf050455a6601ca7392bb1ebce9f2e2bbc0cf8167e6d212d3c2ce9c1885c27bf4c64f7cff72afe8e7809ea9de93011184a85814e6eda6e9f77d7af6d15f3f2d822c1cc719e693cda1244d06155320450e726092144756df94d6132a77532cf35d2cec19b13390efcb83dc43cd10a3ecd4f4a9fed0dc1e85977b4192a3c172adea1526bcbc82cde02a6c9adbb04fdc5eee693d8935a625213035ef2d750664e47350d2c8938d1f8c203542c662986b76c4e2f04f861ee215187f69305f519ad83157e12c13755698191ecc76fc50e8eaa810eb47e3ec81fb9818fc12171ee060808bf718af0ce8495a8f915641d22e43ffd7c1bf65b7a471d5b1d7f9ffecc015cdd654ed14f10bf884ebe3bf2cad76ec944d00c1b9e1eb5258b1629c1fc0ef080159a33a38af67a807b2df6ce5ba8f909588903a3af34a698ed10fbfc5232d3b3ac124c8a2a64557a5b2102458549d4cdc40af75185e9e783bf13bc88e3b612c1da058717b091e789f1fc1e7fd5936802bc5ad2da4d7eac40144a6772fa898b50838b7f8913ced542116260f4c38addf65fe0af7a5435d1456d2879e0e62e418469dbe7b629906e3ceebceb9a89e4816e13f5eb090e6b4dfb29ab9116676f000b4abe30381c8ac1d95179cee4bd12e3dc2d95534e8352b28845d20db56201d9af2d15cedef8b3beef9982af16a6db33b23af144004a61dcd1f609db9f57cf94a929a8cbf6d0357839895a82ae78471de4e14be5ab24fa15cc8f94e0b9ae4fcb050d108c981ec58c5e4b858f5248595777acdfafb01041e1fb6031797214b138cf24fe64a266ec010b8947283043a605e51402591cd5738b88ac1d3342edaa2c276142e2e3478aae603886eb7940de7cc7a30405fc78a2035bf88baeaf31c74907a8a5da71bc844c2c21965a3ed061a6e84c53fd0380962d22f8a0ccc1ed7db70acbc7ffb1077811f6c252f969f1a2afd5d461433a02bac9d492251bdf81e0732a69a6fd4a6a8a60a1774d6edf7b101587160cd209577ff4472182077bae047aa58d1b8cfd954dbc0ce6e9553443ba00680946d8d17526e8509d9643782a36565f77443c6debdbf5fb1c51f08bea683253413b6dfa5fe1d591963298a50799dbea2eb410b8c9ee99aaa584516586ec25c4d82588540dcad73b0b6497231b0adc3e7549e5ac41992d84b5573277cf506b4c11f153f47526b70f62855a009f3cfbf53434603cdebd02c34dda270e5f6d776d1833697bad9b0e4adcb16791caaecdec9a1a0b4df4608afa7866453a813fbaf69974ca35ae6f257e52750f5b16c3d25359ef2826fc778c867e75927d64567c4cd2f90be20b3ac1e54a158431b9ee97331b50567699d2da58c73d5d719608657f2bcbc7fbb95ca0d40ecf4a0558742db8277be7c937a37fd2b6f04b61568414f58b38ead6fbb4a2d8d6ad3fce3faaea2ca80084d1ed3f97689d7c090b85242ea884f6638350457069c24535185034c7e9b8bb42fd88dc7b56dc5199c8e3db8f563e2431688029244cad771a02da4161761bf951011e8c950c9ab650601a636d28290d36ba0435ec50afefe52a4dca366f6a6bd3066cac23542de19383dea999351eddb1e19f2317a17f07df81db387b82a812773b6d256fdfc430c140ff4bfae16e64cb84c43b97821688d61f7f0ffd9c8c103b67dc8bd14d6570055a7115cc4a5720af612343ed83f29a2b2c6dce2835cb7245b411979438ccb2cfd6ad54d86d75e09ddb057a73773aebbd2581d944f1e7f66631f0b81f0e9a9844cc7e25e68ac06311986fa3043f1aecdf07f6fad6561cd3b1ec1dff72f1216d7b817218da8f129e6b0576a82986fe90063ee47ed502f1586733e27c71a34152548ac78d8a391e1f78206a92fc9ce003d2a5d839b0cf630f4ab2ea0104d13f76ba5176acd3d68e15f21b3ad46e48c2b43a28f7347481c8aecc7c72c0494b71618598f679e65be5f60397f2a690ded6901bb93b884ab4b9ab7e31822fce32b4ab7e20eef2e36bb24428608ee4ad49c51527e060c3c6a80e6d2f8624f519c4ac85eaa0c9f5103fcbe442a73b30e5aff38259f75d4c2278f6ba910b7c10f92dd63b5bfc0b4f673d06abf1ce37f06839dbfc3affcfb8657f0b6a5a522c2a179e8b76be955a8ef411ca549381b2730622614a1cbb46506444cd38b8f426d99fb9898b1005ec7674186d06f6b1b919179655f46f9893f9c366288ae37c376d3f64580eb8b3be3572afbde5535fbfae30a3b0d87ef399ec26c618f725f07cd407b8853b2753c4538c9b9299dbd082dd42b31335b2110e703b87c9b7382afd2325283158274c43b2ad021ddb5690ecc4ee437a9aabe35539894dee9183d77c9f747c4f16f42d94c00c054f14c682eac573be132871d760131f1a90e1538e2c87160fb322b6b2927acc1e5385b057b63c2c00e7c4ac9cb14954dc7bf4e60a2d6dee45e14c659770318d900b8476857db56577e2a5cb1d47d3dbbff9e2cb6ef9a54de7370df2cd8bab9cc536cb7ac6c84e09327ffe1f28ad1ec3eb4e2fdcef0cc1dd580171d1677ab6c3c51d1ef3ee9f3fe03985f9eeedc4eae04582a842f372ab31773277da7c0f3318e409d5b5d92dccb51581b8579dc69cecb019e896f9e31768d38c64cf81edb6b811ed861c9bf5f4b0eab6132937a785cb3d6849de72663f73188aec7f8157be681d0ad1cbd76e4f37a29d374a1ad7771705a536ea5eb83d631439282a4c92cae34f4712a4ebd8f28fb14ed14efab0115842d9eb3d0f888c6ae537e306fc9aee8bbc9c3bfc296b0cc8f6d9b1a8ab0913ea6282852c945baa299e3d8787c8f549b1de551f6fc6186380fb747a8b624038694612e4436e8a3bf2ef151147422d375ccee73aa185370f76aa5b83e87750d1996d6c9d0a1fd1d9b18ad2f7f92df08553fb088258e9aba3a1b54de0e04d94037f32aa0fa7d5dc573b9576e88d921ec7b3973f5cfb788af3bfdbc4603dde7aec3f8c798cbc1f05be116eafd440a145ae03f8e617020c2ff079f51af0a3329196ecb997c9f092d82103aec1f5b4433be517f9801fa24a4dcc5c6310382c4a81f716bbce0ae4aae782c5976ec3716802b65bf6db0ada1223893274517ef512aaa4bb8c35e03567f4293df45df78e413452710acaf8562f675ad5136925c7b186efa46580de8a30eda90e0b47f7eb78273ef3f33879764413b6ab575c47e1e01155f4194ee87083d77fd18cc923a62ea78d9bd442e832608f66bde0f99d01089ae43136e48a8435c93d461075a8ec51eebe928d16d6f53cf465c20ee4d8cc723f7b18f1ff87ea49c4e3938e936d9731379d719ec1130b8ed89087060587e957ea586768f8bd92dca0f6b07c3c77b4634f1f69f34c13a38b6b59806570280172afb75e935caa348e2caca1a96f03f50f217c3001d8b26a08cab8938fa33e42a64b68aa4831469555aa9d7dabff97cdb8941c9d53bae03f0d3aebb1b1a1cf47b551c9e36a80a5349349834321cd46212d99b651eb4cef974ab73a5c12b5bf7c955e39a655d5a70e416ec360179f826db272c35aee45db4e33b97733d7066cafa1369ac89037b8f630bb2373f44975ee227286617820e92a3de892339e6dc9bc0a2f459ca3a41fbb4ed0c856c11dae2ecb95747917cfb8a5a6132874f0e079755b86017f4facaf9ccf1c5c7c18e035f12530728599ddaecf83ca58c8b975f890e30a94d8adf1ce18dc47492fb8c8a65c60fd0d488ea46dd41934e5b478985dbad8bc7e03b6045fb49020dc992f7428ca9f942f5212d09c14e2bbb8606309d852b4fa27db79cc3a5f3cee52cec8d288db3a849f71bf2321ce2d4183eddc7925f556d0952b37aabf0baa3999a59fcef2858b176ea0a8bd7dd61ad800ccb4e2ef18ea1bdb72f31fceaf11aa371e81385c2b94644008f892e50948597e4bab0d566e098f1cd86b383850dc2ee89c3efda5b4768c2b824868718688c392b9ee211bf3790a55dcd3112c58b1a2c1f9203b90dc7aff834172164534cc8aa39174038f8d894bc8119aec00a1fbb557edcc27148f61fd49bc91248a60026bf6bc7e6cf88ebc6821d99a6cbc06bd5ff35164621f3fff867b46a85f98a473f7c85877cf3c7cedb03849527adeb2711f4c3b75b90edcc749ddf3d45e7d11cadb26e196ea939c448d45f0c1c5f541377f3133e4564c23a91990422051febb2453d13c4be5670ded7d1995e31167ee6a1127fcbda8f5cadc0e59c4f72c55a78542539052fc0baa13619b666eb5e70c07bb8c1e68daa149e9d4396b86f8f7c5ccdeb5dcb211863736070654c39f139ca8ccd09d9f9d92bbe6c293428927cbf11174bf032f12d56bb99ff6c474ffec766460c123d7aea9d75bb8d1291541e1050d054c154e97e2d5170ea6460dfc7f7e4b184a2442a2480ed1866f5dcd23ddceb51207ef2aed1c55a1394b8b095b911fbf930aef067982a556b4acb28d012cf20b6a895342b59adb7a1a66ce86b2e5646431a747efb403666ff57b30ab9e8153c4df5dd020045c73b91908f0710661d9b3cd88403746a4ec2049a5059ad9893d4a04efa065d806dfdc19e0c67a662385a5fa30417b1d853569471148dc8df3669b13e8f43a89a97e4c130850097c4813f9a5e7f9e0677a86fedf2a2b1555bba51c60c41f6941cc5d62c42744979eecc2d39a34965450888bfae7416766046bfde02e2c67f3b253185bda85628fabe195f517c4aa6ef294b6001a2f387426c0d480851668ececd7de0a9ddf8873cdb189c330994c9ce73dfc6e7261569607693f8ee05f32881e6cecd22181044fda97b07f4cd2c583d67ddecfb5a91627f7fce0c141fc2897d3ad965d0a720e312403f681b0cc39594084693eaba58a446857d004833c21e514da96464ea23916a5447bcc380215ed623ee3fc844907ad432cd9a815493d1bc6b641bd361bdc3a11159fb1791b00e03da1df2e365975ad414245058ceb712a7e4deb4972d06e145693bf67e2dd96e3455722b6640cf7d4e58b8c927fa6c662cbb68ab2300a986bbc8515ef225c941be3594134dcb75dd95265d3f03ccec4ec5a723b768d2047ee1bdcebbc28d87081cda4044d0cf1f2d7eddc4129126411ba4c1dacb73b6a03455fbaf8945e931423601b7971ba2e0333161243241a38c93b0550d5c8f3922c306a47f7d8674eec8fe72e553dc19dc05549bc961c5619b1afff19d69a14f8e212a66af991606b57c144a40b3470668b375fa22e2e90fc09c53395ba008358856bd917d4eae6f8b98f3a6060ea61eda795be818cd0381f1bc61e5dbbe2c0db8081ea5bb97ddde371826743ba5e0f252dc948504f94d1709e7f73c351dc4d157d2296b996f3e185270795ed6b0427632c9021c7400a8d3b762c4219e56c59fc395d62ab48d21067a6bcbe3779302d8b2bdee29e909267c8f7d4b0f7cc92c25fbb733adb790b3e8516705983f2c18dd4d6d0337bfb029a3f6a28067e43285eedf80e1c4ff991d75ce5136df16364bd07d7aea1d4bd90d3909bf0e2ecafca5cc0b9c40718953a4aef43e8fc6d648189db3a29d21e3dfa6f6766368fdce9ae964b21077f2071e382c797cda48cf211357490cb84a213e72dda457dc46183f8f80bb7cf41c2cee26f043e2d0e63b6a686c2d1201a390c623e17e7a5105edd29910e69d1cd9f23d47c7edb2575abb0f6c3b34bb5f575afc3c8e83b97b6bee8f40c63e912d0c34e5ede0ba4bc46856a33dbc704f5387134f61fabbf57f191eddf1b684539da6aace36fc2d8239fd5749e59f1c4e6b05bbb77316c4370fe99badf551ea0616271400c233190b0640bed11d32c839eb38ca4c5263f81d7e750f7597a44de6ffce902e0f3dac667988f9a4961fb207a3dcaddcfd92a309ed0e6d0810705f08a2b1f52b872edc55d011d2f776bb858f580044613d1e390b01d7815c29fcbc4ae3cdba0be7f2d06bdbb7b09d9a144f92f2a05716f84ce806e4c2af2de746c7009f48af0104b18f812433828d03c57f98833cf426cfbf5a0ab78fbdfffdee6cfd469c7c2b0990108cf213efde4898764d5cb8ed3589e9b6f5a858568d842aeaefe0d796004882cb224fc452cdf7d72ce82da44e1fadb7f105c583c12d8afd4fdf502895887964ed69a512594cee77f5a0491e0803ec9bc4132224ce8c8c2bf4e873379c3a972c0c02d1b41dae3c0cfb977b3d80370254630d5959926f1e1585e8da5a25f85ce083ff52bef3c4ad0bf6084c82f73e7868aac075e1e023b7aa4dec61750774a95c25919547b854fab6e5e469b64c2a1d53ff210b4bafaba3560c3313beb77c9efe34c279355086adaced69145b42ce1bda3a5c3a1e2e18db778054e13f89482c0fd3386ac2c7ea6477ae47c154dea7d02987a0330e775bb9f5e51b132fdb94bb17f837f792438db98d75fa742083f95be20cbb7664d60397309e17b1477de2271de2666ce75738295fd0b2df50fd39279c8baab8bf6d55e55ebeacf1d2986b62c6fda6ca05cf1338daf5056473913d8c7412b36c7f569ff405ede053dd5d6dd9ca547370e1b59c3a9898caf16bf1ebd11197e7efca19b22b2af7b763eb9ca8f74028f159d8d4d25cffd0e24ad5c4490efdbb2282f5fb69210463d5c628759367ecda2f3c1ecc6baa62c372092846b12eb4b841404d6c215d0fae5e60266006f06980dea49a528ba1e4360bd4334c15cd6502eafbbc71ea6287ad61121b533b5c4c6f46acf782d29cfc9ab553d641dbad1e8f28a98f5e1e8d0e1c3fc324ded5e130cc50222f4b20d0795bfeb56e82f77f78d5b899675e5b28b4aa3fc0dec17090fb1625f8b1de3b6d88c0ccd7780ec943892178f22c6ea0c5cfd05f4d13f941fd2615be9ea1ff3eacb68b9a87fbacd05acc4ff24c00a87e726fe3ff3a3cdc8b41c066c6eedc6f8626e4d72db87718bc9ae0a5a5f88323bf45b29aff56176fe4b4319430683b6f2c96fb24b6fb2b609cfd381ad0c08817bd365495d084450fc7d6f224277a3fab0fbffe5fea107675f872ba7cc6cfa1ca2d4d9ac65dd1fa3ad4ba57d44552b2c3a7c52466f6eb6565b507d824891dfa085407d7aa502117e48ffcbc96af3726ecb28a5344717a023b5c0e4653baf1413554cc0829d41ace1ab33c676697da23e88aa5dc0cddbd62175657c5f281f91b327af9b0f6853e94a8d4b5f56b54e871e9b3eaa466a08601994dfa3dd035b12b823385d543c8d387f931269eb1eb1ca4c3100e010e66f516cbcf1224e8517d084b50326358a41a68681876d22e420da4488779a538acd540065764cbfb5b3b818f12264d761ff987b05eeb5537952a21eb47abf16f5e693e1fadcb50be29b39b1833c32c7b0e10a7ba44b5ece230ace2781930265288f7ca2f76907bea679211f47e8c0e8b60b7bdb31897fef6bf6ce8a061d1bdad1f03b044c2f2cba68faaa5f220de70fd8d4995ca84fa52c36898a9a5e4b58ccfbd1584027cde8c79c702b6f5c2d2fe73668f27d1e73a3c13e32667b0eb80b0d9b183edbe28194ffbd3e57a8b9ce3c0f2cd8026c395613a6fb9cecae6cde7608021b906596bd61812adea201e883cd30c61fa87aa04113625ec69b0122e0380b7599bd9776f408bafa1db0844951a89c87c9a71a8b9e1f0dc8eef1eeddf444e6304d2e3bb7028ae984c9a258cb47b103b441ad75907b634d4415d318d3ef12af3a6257c41c58a15324ee40bb28262c1640cde5ad5f6b8222ddc1e516bad803cf923834d4f18831eda3220aaa453ed0a904bcf54f4d86dc08185e29634e6bb607bff7d637a35da1f7e4cf4626042bebcf41292f2c2a72b77e8f727af3e2d8c7b6cea3fd0393a81b77ea59008e0690f4fad355fa3939d994eea8c8cf4e715f387a8ce1c92554623e2b5359851b9766da9b9c1d642f28f498c40894a990b6f52fa7330ade14ac2784b2c56ffb59a19361b6c843d2f417497bfc349efe719f6ddfd55c7cdba32c662d2a6414c824c6eaf5725b0a8ab3fdc66f2d4b6990278ca6a69f9119c50c3b9b54b964e0c106905f931a6e9be4b1203b75608eee62ba07297d13de9ce5a32893061c0c5fe4dfe5d9e79bcce5b10c26e5917e4b632334132fdcd41fdc007c0018f29e92221d24b1016a81ba2bf3e640e08904370f6a0c84319d8a01ffe6c432b3cc2f81384014c5723fe9991622f2223544be14111cd8ce9b6e281cc87a35f52bb9c8ec8fa7e9ac59f317c223368405fbda72638d3e78bae2a8ff96f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2be9fc7eb6ccb3aa2640bb18fe622bfa"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
