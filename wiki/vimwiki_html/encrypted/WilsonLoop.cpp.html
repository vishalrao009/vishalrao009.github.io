<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"db9ca2e42894eccd412ef3540c43703ea87db7dd4c9b6d97b163f1bddeec32899478904702f4a1d67397ba6fe491df1adaed8487c871509a5d44a111135160680733b71a509063bc04fc9da7b6e7a9702ea4ab36ec3223ef2eaa980f09b66e226282a4e5f67df19b474d61dcd3ce20ba8c3caf327a64dc0d6cf0fa6cda03dfa794600407cdd77c155dca17fe6ef61168392d3dcb038600f3a70b037e939b3d8d88b200a336c1a51583e1d0d0d21b4c29084c26476c44fd46a9111f3e384aee84ac64291cee8a8cfffc6c224e9beb812d35b6eb5ca6badd3e2c55ab1fa58d5f05807b35af0665a03d3f09e3dc93b078c60fdcafe7558af859dc95c635e1e9c23a4c4d8310e74d18b4e97382cd563771577c2ba03a68c7fe19309848eb45081214c3511360a0ebb80b20782c167c0580dd68518aa2db67339922d3c630a08e85da9bf204edfeabd9304f9e3b1b18034c852c0259743029e6da4a8295866a9345170d260fef4f527f69b0781413e8eb595a63d80a8a5d155d024d13c32198f4470a901f563311d14f0c1ce9fdefb395dbd08e59ec21a24ed809df7dc8198665b5892c5be08c56768e2a9df9219c5835909b3323d776dfd4a76d0f7e8792719da0170474d50959e2e055689e988df33c4ad3e6c03d9950abb4d918c709619d2f6b8a7cc37b6e89dedc223774520597efe5320f8413ea5f340bdc7e8ea5ebbe8fc9fb132001da9d7780f2462a8541c9550eecf4d56bf0a95395a4291b1d5193156542652306d7203e8a4fd1ef2364a63e21fbc9eb8d6ca0c25698d07892d46555233818bab47df2bce1121886cdf25b5bbcc0beb9c365dbb82aeabd9461bfe22c19b35e5e7fb6f7c26adbfb9d0cd4859a907c4e82d950cc06ec18bba35d4fbd993d42752bcb5a87ae6c4886959e426c97cdfd2372424b0426f1d9311ad563e2985533395db83da8da6db3512619473f7462b7ec3b3bcf74b0416c3117a34a5080313be0300db21dc67174112e8f9ae23ef42a69a488fe6c9e86ba6c5f1716101873280cc512f4151b34b43a3c1714c6dcd288f2c4eecce23608ab4dffea422488bd92ee419493790c037cd9b5f8493fef672dfebdff8ce5a37add25595cc7f1c290acc31fdbb5ae1ca88f6863efbd97a0f782b8549bfe9616c91733c0f36060fa1fb40ec796b876dee2da7f84fd275f48a16b9b92a3b9d6e842fe76dd9fd49d6147e58ddbc00a0cd8b11cf36cb1a18bd5715e2cb9979d8856dc41f972d7ae2bc77f0f4db88c0fa1b5cd7084f0ee4aadc6c320e76fe59f2e5c05d04e5643e844b467de277f3a11f53a38da9e6dcf46d6cbcf6e2a791085875cf54519fee8fee54048aec69253d47696a9f1252ba3a5adf9eb1220ea10e37cae7c09e70a9ce23302218c7256bf1839bd0d8b4f86df315d5a67cc0b79d9d664509c24de2cfb32f4605815ab33a685fe7b324622839c8ecda0c72b42dbb346d36229433da0092566a948eee1c1895de1647ba478050cdf2d25332a7303fbb395efdb0faea0b61f227d1bf0f5c4307e7dc3193e34f0e94f2d8c83a0e0e9ec4bc3f665ede2fced217bd65d3b3774567d28fd6a8b33cb88248e365847799b0ad73d425fa81937269090dd1ad919d3534e9aa481f7df7d6533de153dce0c07781f919b850fc52b96e4a5dd0011d94d21c2b8b4eee26e2229402cdb2705897180d07bb0e6fb5a4eee9dfde85d47c6bf91e27133f158cbe9927e4f9045dce5732836815836b3344d40980f7069ef5621f1cfb8bed342be65f5fb998b374cbbcb6ecf0d404d9c619fbebcce7dec27cc68a74028170e849888bfdfb4f43216df42dbe7ac8ca361a2aa1211fa927d979eb5c0ceac2146d56094dafa501663bcb53cf2c81d7a77eb0f5ef9962bbd2c45a6b0e6f85bdbe338595cd2f5ff46b19c4b27c26bcff513a884757c128973ea74dd9beac3aaeb2b72c86dba5ed85f305ecf96c320f422636cc866a3e31d8cfa3791790991abbfe46207a7c004fd6ea0d54e19ce5bfc13e16f0273351e510ef1bdfab11b9bbfb6347afd9f2876e7c7fcd4878f45763be426aecc50ae98103d88c003dbbec2c185f9077768d6f838275d5744d2f915fed6fb6c198e17ba71e467974f39b7b90fe4c99e35289bb662d2ad4d725a9dee2fd81bc92dfbcd06673e7956e6cda3dc957bf5840d1485337d647101f34f9fae61dbe15c6c5a8406c76ab74e84d00c2ccc4aa182c8e94f9de82a119e552a9613bd21421f7b69054be2a3e6573310e304e2c28d84e42cd47839c542470816f8baf62c4fab32addc941d37fd900e7f9645bc67c17010fb4e175a9dd90229ece422921c88a51cc12addfb31635cc60249e4912aea395516a4c5024583d13635c83a66022b37935a778ce3219b782b6bdf7d4e991f4247ba7b76c347e8af3d91d55d9dd9879bce65600eec35b90fa5c00555660325469e92f5abdf7580afab706e8ece8080d8a731f2bcbaa7527ac4000a080e4d1bd8028447d7014eb5c7719e8c9204e2cc84c69ede5ed1e7826d7dafeedd63b7bebbf448ef4e66959de025f59a733b4efb47c41827cb9fe835b7e7dc221cadef369d92894a0f99e353fc428676b7f26a25027ac88e060bc942269cea8ca4db6a93879ff938dee63d67185436c6de951a1af46b3ac1fb1510a73d77294b7cd1247dec59e0585f31d756d74da8679b6139f7074d59acca76247e83a5ced92c63c9ab72012843b027bc8a198f0be42f36c9096bfe1b31a53ac4db7d84f275117f8a5b43796406afd280f342de1ad6359c5121b6a8ec3c3860452fb9b6b8ebefa4c73a089a0a98d0a662f7a05c28c6be9f3a3014785a973728d6038632b0d10ec08f7da0dc47f56e321e007572b082d6b60d3d9fd8253d61fc52c403c9b7863fdc0346be95cc7d4084a169aef01b2b4563b74d7cae4d62d096849cb13d7694340ca202ad5ebeb960953721b39f4eb45db49bade0767cc9852a9a6fddbe37c214c1a618ed55e9f519adf1bf36d94b1939d93263b45883649fda1988b2d9a92750a829534d8a79b553afbb6b1e05c0fce16d41fdaf36609525181190c003d71607b93f5ab1be46dd17b3d8e82b19327ef2e3fe204693125db899545d523685d7a59e3f0d33936a62fc06b436536b542e1072f0b7a470c934b08d04d10bd671c91d0abce1d6570e1c9d7d446d82da32c51e372df342cef6afccde029720311148d277dc9b61565766152f85494d7027a3430a007ae8d9fe0e56d4f528d2fcb2e576a0b76b9f8d86b026bb57805e9c8daeed21ad09f4a571ece50d29c0a8414e25f6e2f84e19c9cbaa4e3ceeff2cc8a42328c3d23087d3418c4c06a2e9dda8c7ee191d48f89a6827380dfe651f454f7f5afd91567f7e55998a224ea0dea8b3681fee9eda8ab64e16ead6e7ee24940aab33e16012e9bac56152f01e1ca931ddbd2f4aa5904fa3010ef5f546ebc3820f7cc85ae709fae7205165b1dcaa742e913eb03970fa78a61daa5a38287b35a3940f798df8b37815a63bc83c1ea04111c414d0ea460660f2f216b720f506477b336f193aca50c49a6f7eb2cbbc0ac1fce30c1397a809c6e5fd6764b66ac982ab009e52bf0997cb3c61b6970c8b84e8d1aac2b03f3353109532aff43bd1ea9c2f988f86b1ac85b6757c66866dab19930541d0f6cdc024eab993bff06af6298d6155a1a7db4bf57ccf70d2897252ad0e9a740065d587db16d3991627a86941132ed5062187589a96c841a3a71f3db4c6168106f6a2f5a2a01773e6b7927f7580efe1774a1bf8fd92b430427b0f4fe6e206979a200df29fe21049d7a3a813d3bc60d6c18f7ff55d52de3bd1196246c3d579380b9e78ff4691885804b02a122604766003b039f2b30e951abcf5254dcaaaea11d26be9bd0cd4063561666a03012c479375ac133a44afee3626432c77497df72d27d24d9301093f76cebc96633c09bc4164b5bbd35b99eb3d47433387f931283500e02a3c27cf8d63a61d1f972add44b856d01a53f644118edef828b83a3ef04bb24a48982f2c6287a9501264b83eb1b03d650a6901319441bd1979457a8905658a19c19d757257f7a148e1db60c563904fdd7cf545f31c805922922176ab3fbcd9c0d744b6f64fb1a81bc8e073a73c3114682299d95c496f7ab3cea83ceaa6e3f51f0b791bd5df0629a9df879c0b617423064782e993cbdc714db2ca17ebf7c86e46a1ffec96beac9ee6c4c8af3927175fa9ca835f26bd158676fa8570a43feb6b9bb5188bc3682599a30ec68eb9a9a0067d8c23ed91372e7896c4ee09a522ba0e79a546791774cbc3c398f8b170e43ada2907c0c4bb8a0b5c8491904c8514696678e2fea3faeed4659c82d7749a871cb3245139ff63aaf6cce60cd37a72f94a0cdecd2871bb154cb2890aa5b017cddec48d771cc576813299c2a6bff26c81759ff5a59beb770c1701e5f6eb05c5cda505c55c302ea3dbfc7822c0535cd8826110a656b6aaaedd4468bea04faa7c1fbb13f11402a190eab459b6bcabb909dc08edf55b43f8e569fc2904b2f343bd1875bdd5db3df7358621e8ec3b662c19c6223688ac50689efcce8ec395b6423062bfb50743d4aba1a1486fa8720d0eab89c5527b6283632549f510f1871258a5f71da0a400bb805a8ce6f9f427ccc0b435f1a64120a2e19ba4ade220989d21114857747e4b9862f7984473d5d2955d5a51f0461c2a4e9da85a2f3c420f5884d1c3dbae43caa5aeae14af270505a864ea4799f8c7a9c073e207bced0826a91d5f60d6ba6122d42947b4ce3462366d2e3779f2954202252291952fc3a625c1c731ee103e3a9ca84409bc51b3f4196c39e929bfa90d903a654b1b7035fc86b254386f7b396e6eee807bea4074759bce5a5079bfaa8f862191159c9f6912bdf719c6de0e6fd8eaeecca382fe5f44e71849c232fbb1bfe84d306479cf2be5bb171a3a55aeed16f277312b292ed0f5e2730e9b7a554fb84ddd6b42c945c24299026e3ec37568a0df79cd18bd2b5525aac31f0bbb0b37105ae69fa9d2eb9b61b546cf800601e1c691fa9b1e60f5cf27f15bdbca4925153d1b0beca1a0eb66a304de35dd6bcd41e2e1421b6c995ec8c09172ceece2cba0366bdd788e75f99246953c577ae7336450390de265be3397aa6a2fb7976698a8f7793855a0632b8728cb2a5d8af9b8681e0213eb59f98e74a2adcd6ff73d558c10c6f2188bd760056791c2a6944c67ea8ea815f8e742456703f632d68e942b363f74b32c58e1c69069c6a361f64e618f5574eb746ca62ae77e44276bbcb65d0df1826faf150fa92053e8b39ec3823eeef2655ec87ac91933b101fb8ae05f1a8a4a1bbf0a1a8769398bfb0563be56e9da5e618d2ae1a709df982f97eb657a828c9c3df1d7e6ed50644c5437703234acf5ae543baabab8dbff15d7d461c95e44e92814fe4fd4f2fd3592187ee58c8ef7da8afd0e759b1748a6159f45770ff21d2d48ead46aa377d41538d9132f5d5839bb2c0a4c6ee0886b104f668faed3d2ac232e7de75cdcbe3d2735aff94263c6d5c761d322b1139ae7908c8e1000d9e1bedd4c1eddf5bd004f64c88be7c6b112166da5fb1c028b5fdc49aa65f42634a4720e59fbb1c69555e96f61a90e2937a4127652651ef092265722942451b036b55b32500b29ac0f28929d28a4214563add0d6e5267a9bd5af98cf7038f5da4ef68d37d96b8e6b3cb54daa67139900a6883c37ff720368e45ec191b283b3884ec26e7a82c8bd4d11e7fa1522d1d3fe976f6ca911cd09e854d038f17d19c5d57633838d815cbf9352012041a08aed1b0199fd057274e2a2a93d13d9075691cc8b7e94103671602d804a11178d7c6611dadf1278e9b71c62ccd03741840188bbeaedbd05d7f832130369e4406ee7cf375143388e019575c6c6135eee43945269d7ee9f01b4307349b2891eeaf5284cc918de780bae28ef78d2603a1292db661c331d5cf5f0b4781835526527191119142cd4bb2b0ba767c19ab0a136e0f508c05579da004b7b820fa367ec41ffa569add428eecf0e4ee37872ce4e7358cc9e993d0a201f27167e9101746f3002c98a1c9fd76cb5cbb5b6054b35653400b788e8193721e22f399bba67bf9a9c05082e327a3a58bf16481d3fc4ed85dfd8305ac6290b6a2dc92719a1ab3cf6224cb1249bc259d14767c6388da7c2b48ec507fbe2c4441cba070dd4b7c0db0acb47000d836a6e99be17b2bd7a1d72c172655f7935b04701b76c715aa7510dae5155be2f08a27a6ecb5bb78f978463ea61036dec196f1ede0b2af164c212981abb6d167f758792656bf30bdaab99c3004c2cb67bc69c979970f99ff52f9b22695c34fa57f034523580702268318139973303820189e4659fcea32685662423ef13bde2c36d21528ed1b5158361824a84f2281fce535c610150619ade6288c67e190c350f8874c15679879b48e01a46a379ae0b1731e4d514adb9e6a5940fd07a9411509bd64cb9dc8e66314effd9ce9c5da0ee3f940a38e6d91dd55f5e7854cb74c4633343cd5a5de9207b3a088c2bf611393fda2492e049872ffde85f9490c0f7289cbffe915cc33acacdb4b2205e9fc3050a63a6cbd29964136402dc67c2bf2a0120f4baabb157f41dc632fe4d227885e533ee93dfa69ac0fd8b315384ede42170f0d4d3cab81a49b17183f24b95ae2e26744658be895fbf76fa30bee6e5bd44888e772f77578a2b92b9a6df4593da05474ca7a5d70183673cc998f6858a264146101662e741a8522cdd31c560ed785c04645ae2ba3933c8957719984859eba7453105c4238292abe0bab9dcd6a205506545c695e782c808967d977c0998d7ff6946728e5e02dd3acfaedcb80b19708e241c6de3624b50a5a8eeb926dedd870540c39300a437dc50d318b584308175e770c00af1c47656f4758250bf3ba83abf7501c93d979a714d324d16108a92fda45476907aa5eecadec96011c79b0b59c1f13b0a770df8dd41e4f88bdd135189c5f09636bcd85c5aeeef9121ac4b075b3eb188a4159e03104f843cfa636e1d24e9b846ceed649d308ed8a1551668936c2ace67d4e509cb7f4b961b3c5a3512035425aaf782378b208a3625a1a47fca8a9cec0f0de86a4c041271333a52c6899fb791892aac3d64ad804823d3233cc8d34714dba82e00dc6f365cf87feb17951d33d63bef3f05b34dbe713997b34faf1139ed57a99288b95c7ff99427f4700481b612166a201278d1de3bcf9ac58b10581896150939f1ddc59b37800ea30eca5c68578af2f0cecc944bbe40df105faae31437af8fa38ad52d21fff69f638a63c1eae3bd812fb9b091df80a6dc5ceb2db3d0f3c4dae64ae5dec4af206d0fa98cdca0ae2768975d1232acecac795761dcf8ba45dfb6513b24063aa5e36c6d34d6c56ce883e3f623cead70fc7a68876f58080eb6d45b767d3db72b667c9b71cc2dd1e181a41da06e1917b9dbe984fe833b350804f62ad2821139a7fd86b558cd89c81a9462027bd262e0b0a5f1aea754c0adbc5a0a2ef1b778f84ce5b1f67f93b8aac91d77190d18f4ff0cf575d7ee0e4deadbc1ce9cc6b541cc08d2874e68c8526b769afae461fd5160f4800780923db52fcdc0051830576352f3753c041b7a94fac529c1116572f79a9afa4a6f7d5ebecf7a23759d951779d78d35bbd34a66564d44d500f774df4edd4dc012d0d9929fe3cacb27d125e8ce22d19cfb2ebfb95603b8ea63d3103471ec21c5f68ab644cc96fadd313c99b78ccc91f6bbfef7b441cc9ab0193c0c3735497261846aa0604a74316d39ec632dd37b2fb3d46c80065dcf729bab95d4b488b502a7d3f5ca69a5ba0c4c0174ab2a840fd3e0763299a0ead355afc27a6add7621f33e47b2d2a7eb197d1dfdd39074d48591a1bdebad78194ec9a9bcab11ee63896c14277fce371febf0c917f3b1214cc909577867c46e2b6d7fb0a2266909cd8cdf93f98ccd5fa36c09221d4a4090f6c32594d529c7d3185fdb067d4ee971c25c13f399ba70a39664a8606704ca70e491684a3cc9c09661ff3189f2ab96d96272ecf8fd5c9cfe0e62e49da12a3c6dc0896dd869c9a48384bb2c523475802880b8e0c7a4eab88e0b63f2e0428a87ef0ced3666f2baa4871718cdba64ffea826c27a6fdab559eca2b3e0424a7a1caa91e4bfe158ece7124e6398e9eeb81ce14aa0820740412574547eac475d93a6d8df5247c16acb0369b6e43eed29d88126f830dfccd5acd94dd15e80015969d0ca9b5e137de999349bdaa92b716d6c9b7a96369399963adc678a0ede178f444e909b578ccec7a6a1830b25df838f42f414c2286e36bff296604f79b34e009070d804ca00d8dbba1045d79c8d145cd5280721557d665dcb6ac0f082b3648951a624172d38b8159db78f7dae608467d90fb111636b33296a7bb7812ba410f8d7663628daecea6d522780ce27d2e0a0ffd3fdb9b7f5ff6eb9a27c2ca493f45690b4ff3829874950cc441b7d3f24f7a54ea208cd8d08db4db890e3c009234cb1329e3ebc51a8f75d048d0f4d7b522b11f599e17bc10a5460eca4cec991d706d59fb2166a12f7d6c2eeabd0709f54dc968dfe5b0dc8f16375bb4f80d155f005630a5d9a0fc108cb19a1474ea790e3452a1ae7c8b3be081646a93c59ec32bdb650e4d64ee581982a5bf91af2df48ca31cb3a88cfba082422441d1694ea36bfff59ec158254db4c1dad71c48e0e640e5cd7c532dd9a445a8b9447979b77a4623a5dbc0b2f9680435b9e0a5ac2880386662583fcab2432a55e5942edc721de4b05d9df196e408a7cb6c86603d622953b7ac54a3d7d2db366d4749bf6b1439c2f4089a1c4c2963a54d33f3a8b364582fd83d37a31a606c32daec41376aaf139fe369f7a84faa257031ca9666ff9cfd2016f186deb89c38c8dc5a5de7533fd87c6a2ca09578d59fd7c275c880ac30d7c8df34dcd2e7427498853de8679c36fdd91f24d48519cd1af08d4ad4d95696d1ff6d322dc1ae21520782721d7095ec837303d90e0ad62b0af92734e8fccb52c37baf6c8ff739a43c7c2f089d55451804eebcf21ebef70608a5857c1dd457f149ce9a5e215ad433d8c0080fb2ba209a632c545eb700b900b13a8dd6bc9ac61f9901f22d5109679b003ac14db2096627c6bc9bad29eeefd13f16edd024296cdccc8931456ddd63ff1e45b9879603468208e765017ed803810443ae5f8d73606d9ec1431bacb102a547529e05d2b0feef367b2d2cd92122aa08d40dea51aec0e460409fe91b1308839324d44803a09c11d5bb40411ff91c61fb23e9e0b4dfdbc57d152fecf9baf391655a59c3ff1cf0afdc67dc298fef171b29cec02f38f8bf3e30e785c820f76b45a5f2883a288b1c2cbfad9032f1877ee3addedecca5de79664e44b1b8cd89f9ca7eb853469cab22ff515bb472e8f5bfc71f672d846a27f51780065803a8c9f5e7f4f4cfb45245ecac217c351fa0f50d37fb44d67cecefbe5d80956149705646a6034f7af1a2c5f027a6da8f2cd9ffeae17a2d3531e7e2c2c47bc554db0ee17d431c3f26f7b1a44df64791e342837617034bb0460c4f0a3b97a7d40012aa96d17eb61cc089c6cc3eabf092dcad29c0bb8136d3d9196b796c468ac2d183b9b664502c3c5db259de3ccd075239fb0eeaf95683dd54e6621511bc66bedb68c2fc88d9ba2746e834547a3314610fc446bc3991c06d9bfae42a6367251e2e5377b7115f61d6ed869922d9c55a4de73d6480aeb7bbe17996a62074366e5fa048269b6394cbcabe119897d2e66c3f132976deb853974d77ba46ea40f1aea8e48949258dad4dbe85719f1559fef6681a23f580fd4877df19f6341ba2506a307b1e066b584d20f2242e82c2a4e290b838626ed82fd68bf5e7ed545c1c16c8a088836177fd22ee67f5129976a9ac8a799a6657f4f08fce80fc901c61d933033905b39a6c2bd7f98c09c2db44c90ac20b9b1162afe399bd4604564e593e9c657fff0312493bd6cac83e80872dea2bb1fdbb1205fcb3818fdfe905f90449549db87801c19bcb8ca0c48a16d897c379ec3116b9f92750a39af79db8f9b4d2ca83c40cd4ba1eae5f8a16ffc2877207faaf3da017a746b7e316448957fdfd83d8c2ab971e46a32aec446e0646725516e9ddb0e7cc1ee231a70d47836e7fb9ff50dda82f03734f63bb305e64bb6c5edbf76419c0c131c294d2b3617af4a981bcfb235a2ca178f50326208290adf27e2867ec05f40f654b3a44a64805254693e5e39ae8419be160ab63d812b161835dbcd3f2f5496989640e77f9b1ae132307db5f38514cb7d60d4d19862de4303fe0c8c139f30847225b01c9a36f0e1b204fd5bd5f074ac701dd924fdf8c24a20d1343ee3215a4a0714f8c944935b4a7a1ae9030c6553339ef6df41c91e923ee00831c06410c8b533e4a559e13302a3cea691039df7cb17258a4bae29f29788b7fe9632543013d182568db045428a48daf29d653ad60544d7b6574c40ad4379c66240a176fe43eaa94b90d0a3a746ad2831a6c36e40555a59c92bd98a2eeea2a83650f4b67ca757f1b8eb75d5f565b6fadb26822ad131812445bb27ac6ba7f8881940cb3d9022cb6be7c047abd60908aa7ea8f2e0e9b093365218d1ac87214d7416599efebc7b0d9b8d6d99da5bcea34482c6b8493561a367985cfe865554921d27a4c785d5195828a8c985bcc287d5c3611e98a380ccf272edc355d2ef21bf2675b74c7729140fa10660f9f97c271e5800849898f88bf11b4decab2acbb5c844d5e899bea62c2743cfd33d401474a6c1f74b1a6ae805de97456e8b6c7599d532dfcc9c4346961bc9bae5786a2a369dc10f4144ab7b263355b76851aff31a8a5b3ec54700b518c2f6e04f85d04a18ce96b67c123d5533449ef9d710908","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"2be9fc7eb6ccb3aa2640bb18fe622bfa"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
