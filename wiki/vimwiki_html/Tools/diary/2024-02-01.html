<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../rss.xml">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css" />
    <title>2024-02-01</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> 
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        body {
            background-image: url('../Images/parchment.jpg');
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            margin: 0;
            font-family: Arial, sans-serif;
            padding: 3cm; /* Add 3cm padding on all sides */
        }

        #content {
            color: #333;
            font-size: 20px; /* Increase base font size */
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.5);
        }

        h1 {
            font-size: 28; /* Smaller size for h1 */
                color: black;
        }

        h2 {
            font-size: 26px; /* Smaller size for h2 */
                color: blue;
        }

        h3 {
            font-size: 24px; /* Smaller size for h3 */
                color: orange;
        }

        h4 {
            font-size: 20; /* Smaller size for h3 */
                color: purple;
        }
        
        h5,h6 {
            font-size: 18;
                color: red;
        }

        img {
            display: block;
            max-width: 100%;
            max-height: 500px;
            margin: 30px auto; /* Add space above and below images */
        }

        /* Mobile Styles */
        @media only screen and (max-width: 600px) {
            body {
                padding: 1cm; /* Adjust padding for smaller screens */
            }

            #content {
                padding: 10px; /* Adjust padding for smaller screens */
                max-width: 100%; /* Set maximum width for smaller devices */
            }
        }
    </style>
</head>
<body>
    <div id="content">
        
<div id="The demonstration"><h1 id="The demonstration" class="header"><a href="#The demonstration">The demonstration</a></h1></div>

<p>
It was decided that we meet at 3:30PM in the adjacent sitting space to discuss the ideas for the demonstrations. After a while during the discussions it occurred to me that maybe the parallel programming can be of some fun to general audience. The idea got some encouragement and my quest to write the magical code begun.  <br />
</p>

<p>
On the day itself, I knew what to do, I came back from the office and started writing down the code which can show how parallel programming and serial programming wins over one another.<br />
</p>

<p>
The idea was simple, but not that easy to write it an hour or a day. But I was willing to finish the code within few hours, because  <br />
</p>

<p>
The problem was simple, add two objects of type :  <br />
</p>
\[
\begin{bmatrix}
a_1 \\
a_2 \\
\vdots \\
a_n \\
\end{bmatrix}
+
\begin{bmatrix}
b_1 \\
b_2 \\
\vdots \\
b_n \\
\end{bmatrix}
=
\begin{bmatrix}
c_1 \\
c_2 \\
\vdots \\
c_n \\
\end{bmatrix}

\]


<p>
Simple, right. Let's do it then. We will start with the largest array (such column vectors/matrices are called as arrays) possible and write a <a href="../C++.html">C++</a> code to find the resulting addition.  <br />
</p>

<p>
The idea is to first do this task on CPU with a C++ program, and then via use of parallel programming on GPU with some programming Languages (like <a href="../Cuda Learning Center.html">CUDA</a>), which support use of <a href="../GPU and CPU basics.html">GPU</a>.  <br />
</p>

<div id="The demonstration-Beginning of the puzzles"><h2 id="Beginning of the puzzles" class="header"><a href="#The demonstration-Beginning of the puzzles">Beginning of the puzzles</a></h2></div>

<p>
So all I had to do is to write 2 programs to do the same task and produce the advantages of parallel computing (programming on GPU) over serial programming (CPU) and vice versa.  <br />
</p>

<p>
So what's a program, it's just a set of instructions written Sequentially in a language which either be read directly by computer (if written in machine language (100000 010101 010101 001010)) or read by some software (compiler; which can translate it for the computer into assembly language  and from assembly language to machine language (1's and 0's by help of assembler)). <br />
Any content we write, see and hear via the computer is written in form of 0's and 1's. If we write a program, then every word of set of instructions has to be converted into these 1's and 0's. Such form is often termed as binary language (or machine language) or the number system with base 2. It turns out that it is the way to store the information or instructions using <code>on(or 1)</code> and <code>off(or 0)</code> state of very tiny switches (also known as transistors) which our computer is mostly made up of.  <br />
</p>

<p>
Since we can't write each instruction in form of 1's and 0's, we have developed a way to convert the instructions written in familiar language (English or C or C++ or Python)  and the compiler for that language plus assembler convert it to required machine language.  <br />
</p>

<p>
It turns out that C or C++ is the fastest language available. I chose C++ and started writing the desired code.  <br />
</p>

<p>
I might go bit technical here, will provide links to unknown keywords.  <br />
</p>

<div id="The demonstration-Serial Programming"><h2 id="Serial Programming" class="header"><a href="#The demonstration-Serial Programming">Serial Programming</a></h2></div>

<div id="The demonstration-Serial Programming-Algorithm (Plan)"><h3 id="Algorithm (Plan)" class="header"><a href="#The demonstration-Serial Programming-Algorithm (Plan)">Algorithm (Plan)</a></h3></div>

<p>
The Algorithm or the way to write the code was simple, include some <a href="../Header_files.html">header files</a>(to support some functionality to read and write, and write the main program (called as int main() or void main() which are main heart of the program)).  <br />
</p>

<p>
The program or the set of instructions can be reproduced from these steps:  <br />
</p>

<ol>
<li>
 Define a size(number of elements) of each array(both array has to be of equal size to add each respective \(n^{th}\) element).

<li>
 Store the size of array on some part of memory(size of array is just a number).

<li>
 Allocate space or memory of N( or size) numbers. Do it for another N such numbers too.

<li>
 Now fill up the memory space with some numbers.

<li>
 Write a piece of instruction to add these numbers \(a_{i}+b_{i}=c_{i}\) for all \(i\le N\).

<li>
 Store the respective addition of these N numbers into N memory spaces of first or second vector there itself. Therefore the first or second vector memory locations will have the answer of addition.

<li>
 Print the addition result for first or last few elements to confirm.

</ol>
<div id="The demonstration-Let the fun begin"><h2 id="Let the fun begin" class="header"><a href="#The demonstration-Let the fun begin">Let the fun begin</a></h2></div>
<p>
I started to finish the first step of plan(Algorithm).  <br />
</p>

<p>
So the program started with inclusion of header files, and defining main function. I knew that in order to show power of GPUs over CPUs, I have to start with arrays of largest possible size.  <br />
The largest possible size? Now the computer have two such memory locations:  <br />
</p>

<ol>
<li>
 RAM (Random Access Memory)

<li>
 Hard disk storage or Solid state drives

</ol>
<p>
I found that the size available was 256GB(1GB=1024x1024x1024x8 bits) of RAM, and 10TB(1TB=1024x1024x1024x1024x8) of Hard Disk space. I thought to use the maximum of these, to amaze the general audience.  <br />
</p>

<p>
Since the number of elements belongs to integers, I started with integer data type(All numbers and characters belongs to family of <a href="../fundamental data types.html">data types</a>.<br />
</p>

<pre cpp>
#include&lt;iostream&gt;
int main()
{
int N=10000000000;  //not allowed the maximum it can store is 2^{31}-1
}
</pre>

<p>
I kept pressing on key '0' to make the size (N) as large as possible, it wasn't long to realise that I just can't store any such large number in variable 'N'. Since 'N' is declared of data type (int) or integer, which compiler can only assign 4 bytes of memory with each byte having 8 bits of space, where place of a bit can be filled by either 0 or 1. With 4 such bytes I am left with 32 bits. So with these bits, the maximum number I can store was just \(2^{31} -1\) rather than \(2^{32}-1\), where did the 1 bit go, it turns out that the compiler also takes care of negative integers by taking one bit reserved for negative numbers.  <br />
</p>

<p>
With \(2^{31}-1\) as maximum size I can allocate with integer data type, I was bit off. Sooner I found that there is another data type which can store only positive integers(unsigned integers(no need for 1 bit reservation for negative numbers now)) making the total number of elements double. I was happy and so I tried and again this large number can't be stored in this variable..  <br />
</p>
<pre cpp>
unsigned int N= 10000000000; //again this large number can't be stored in this variable..
</pre>

<p>
The maximum number (\(2^{32}-1\)) can be stored using 'unsigned int' and binary shift operator (&lt;&lt; or &gt;&gt;).  <br />
but again error was on the way.....  <br />
</p>
<pre cpp>
unsigned int N = 1&lt;&lt;32 - 1 ; //here 1&lt;&lt;32 is just (100000000000000000000000000000000=2^32(in decimal number system(with base 10, our number system with 10 digits))) but we can't add to objects of where one piece is bigger than can be stored in unsigned int data type.
</pre>

<p>
We can't store 1&lt;&lt;32 or \(2^{32}\) in unsigned integer data type before we reduce 1 from it.  <br />
</p>

<p>
I then tried to look for other <a href="../fundamental data types.html">data types</a>, turns out that I can use 'long int(8 bytes)' or 'long long int(16 bytes)' or just 'long long(16 bytes)' to declare the sizes of the array, here the keywords like 'long' or 'long long' are termed as <a href="../Data modifiers.html">data modifiers</a>. These modifiers allocate the more number of space to store larger numbers into memory.  <br />
</p>

<p>
But if I choose a single number so large which can occupy the whole of available storage, then where will I store the N elements of both the arrays? It is better to look for the largest possible data type to store largest possible integer on the computer. It was 'unsigned long long int', which allocates 16 bytes for each variable of its type. For 16 bytes(16x8=128 bits), the maximum number I can store is \(2^{128} - 1\).  <br />
</p>

<p>
This number is so <a href="https://www.wolframalpha.com/input?i=2%5E128-1">huge</a> that even my text editor (<a href="https://neovim.io/ ">neovim</a> which is used for writing this blog) takes minute to save the file.  <br />
</p>

<p>
For a moment even if we allocate memory for \(2^{127}\) elements(<code>int *array1=new int[N];</code>) and entered integers values (4 bytes) at all these \(2^{127}\) places for both column matrices. Even for entering the N+N values the CPU with (3400MHz clock frequency), will take 6 instructions per loop. In total it will take \(6\times2^{127}\) Instructions. And CPU can take care of \(3400.10^{6}\) instructions per second.  <br />
So the time CPU will take to assign the N+N values will be : \(\frac{6.2^{127}}{34. 10^{8}} = 3.022\times10^{29}\) sec. or \(3.022\times10^{22}\) years. We don't have that much time obviously.  <br />
Also storing 4 bytes at \(2^{127}\) places of memory is not possible as it requires huge amount of memory \(2^{102}\) GB of storage.  <br />
</p>

<pre cpp>
unsigned long long int N=1&lt;&lt;127;
//define both the column matrices and name these array1 and array2
for (unsigned long long int i=0;i&lt;N;i++) //2 instructions to enter into loop each time(i++ and i&lt;N)
{
    array1[i]=7;  //2 instruction or,  *(array+i)=7;
    array2[i]=3;  //2 instruction or, *(array+i)=3;
}
</pre>

<p>
Later, I found that the number of instructions I was guessing were not entirely correct (correct number of instructions are little more then anticipated), it is better to generate assembly code using <code>g++ -S programName.cpp</code> to generate the assembly file and look for number of instructions for the above 'for' loop.  <br />
</p>

<div id="The demonstration-Starting from basic (modifying single array)"><h2 id="Starting from basic (modifying single array)" class="header"><a href="#The demonstration-Starting from basic (modifying single array)">Starting from basic (modifying single array)</a></h2></div>

<p>
So it can't be the largest possible number a data type(<code>unsigned long long int</code>) can store, and with two such array the amount of required memory becomes double. I then thought to just store a single array with some numbers, and write a code to modify these numbers and store the result at same memory locations.  <br />
</p>

<p>
I thought to find the largest possible array which can be stored on 250GB of RAM. With 4 bytes at each locations(aiming to store integers or float/real numbers), I can store \(\frac{250.(1024.1024.1024)}{4}=67108864000\) numbers on the RAM. This number (67108864000) first needed to be registered in memory and we can't use integer data type(since <code>int N=67108864000;</code> can't be stored with 4 bytes or 32 bits of 1 and 0) , so we have to use <code>unsigned long int</code> data type which can store this number at some memory location (since <code>unsigned long int</code> reserves 8 bytes for data, we can store maximum of \(2^{64} - 1\) = <a href="https://www.wolframalpha.com/input/?i=2%5E63-1">huge number</a>.  <br />
</p>

<p>
Good news, we now have a number which can be stored using data type <code>unsigned long int</code> and we can reserve size of 4 bytes (for integers upto some large number), for each of the N=\(2^{64}-1\) numbers. For the moment we can start with just \(2^{63}\) numbers.  <br />
</p>

<p>
I tried with following:  <br />
</p>
<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1&lt;&lt;63; //wrong as we need to explicitly tell that 1 is Long literal
}
</pre>

<p>
<code>output: Error: shift count &gt; = Width of type</code>, which can be get rid with use of  <br />
</p>

<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63; //telling 1 belongs to Long int rather than 'int' data type
}
</pre>

<p>
I am now planning to store integers on these N memory locations with the following code:  <br />
</p>
<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63;
int arr[N];
for (int i=0;i&lt;N;i++)
{
    arr[i]=i; //storing i at each place of the array.
}
return 0;
}
</pre>

<p>
For most of the people the code will make sense, unless we really observe. The first error is in declaring an array of size N using <code>int arr[N];</code>, because this method allocate memory in <a href="Memory allocation.html">stack</a>, and since the stack memory is limited from 1MB to 8MB, we can't store 250GB sized array on these locations.  <br />
One has to look at <a href="dynamic memory allocation.html">dynamic memory allocation</a> of the array, which is done by <code>int *dynamic_array= new int[N];</code> or by using <code>std::vector&lt;int&gt; arr(N);</code>. This allocates memory in RAM region of space, so I thought that this is the best the compiler can do (Later while writing about this task, I found that it is possible to write on Hard disk and read from there and modify the vectors, but this story is saved for the end part.)  <br />
</p>

<p>
The second error is just a warning as the loop will not continue N times, since we have declared that variable 'i' is an integer, which will only run from 0 to \(2^{31}-1\) rather then 0 to \(2^{63}-1\). We have to use correct data types for variable 'i'.  <br />
</p>

<p>
I tried with 'std::vector&lt;int&gt; arr(N);'  <br />
</p>
<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63;
std::vector&lt;int&gt; arr(N); //takes a lot of instructions to assign memory ( so many seconds just to execute this line of code )
for (unsigned long int i=0;i&lt;N;i++)
{
    arr[i]=i; //storing i at each place of the array.
}
return 0;
}
</pre>

<p>
Turns out that there is some faster way of allocating the memory, it was the <code>int *arr=new int[N];</code>, but one has to delete the assigned memory locations explicitly in the end of the program.  <br />
</p>

<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63;
int *arr= new int[N]; //allocates memory in no time.
for (unsigned long int i=0;i&lt;N;i++)
{
    arr[i]=i; //storing i at each place of the array. Still wrong, as it won't store 'i' at a[i] locations for i&gt;2^{31}-1
}

delete [] arr; //we need to delete the assigned memory locations explicitly.
return 0;
}
</pre>

<p>
This method returns the first address of the allocated memory for 'N' integer variables. To store an address in variable 'arr' we have to declare it with some symbol which makes the variable 'arr' an <a href="../Pointers in c++.html">pointer variable</a>. <br />
</p>

<p>
Now it seems that we are fine, with the above code, but there is still something wrong, we have declared that the array locations can only store integer (integers store from \(-2^{31}\) to  \(2^{31}-1\) and not upto \(2^{63}-1\), which is full range of 'i'), but in the loop I am instructing compiler to store value of 'i' which could be greater than what an integer data type can store. If I increase data type of array to be 'unsigned long int', then each of N elements require double the memory (8 bytes instead of 4 bytes per memory location); i.e. if I use <code>long int * arr=new long int[N];</code>, this will try to allocate 500GB of space, which I don't have.<br />
</p>
<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63;
unsigned long int *arr= new unsigned long int[N]; //I don't have 500GB of RAM
for (unsigned long int i=0;i&lt;N;i++)
{
    arr[i]=i; //storing i at each place of the array.
}
return 0;
}
</pre>

<p>
If I am stubborn to insert the integers at each memory location with value of indices (i), then I am constrained to use the largest possible array to be of type unsigned integer.<br />
</p>

<p>
Later it turns out that there are similar data types ('uint64_t, uint32_t, uint16_t, uint8_t') to allocate memory of 64bits, 32bits, 16bits and 8bit respectively for the declared variable.<br />
</p>


<div id="The demonstration-Moving back to int"><h2 id="Moving back to int" class="header"><a href="#The demonstration-Moving back to int">Moving back to int</a></h2></div>
<p>
With all the high hopes in mind, I was constrained to chose the unsigned integers data types (which only store positive numbers).<br />
</p>

<p>
I gave my first try with the following code:<br />
</p>
<pre cpp>

//This program is intended to demonstrate simple serial programming where a vectors element gets modified serially. 
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using std::cout;
using std::endl;
using std::vector;

void increase_magnitude(float *starting_address,unsigned int size_vec, float mag_multiplyer)
{
  //the variable *starting_address is a pointer which will point to (or contain address of), the first element of the array.
  for (int i=0;i&lt;size_vec;i++)
  {
    //let us multiply the whole vector by 2
    //since we have address of first element of vector, we can take its value by use of *
    *starting_address=*starting_address * 2;
    //now we shall increase its address by 1.
    starting_address+=1;
  }
  //in this way at the same memory location we will have modified the vector.
}
float magnitude_finder(float *starting_address_vec,unsigned int size)
{
  //This function will return the magnitude of the vector. 
  float sum=0.0;
  for (int i=0;i&lt;size;i++)
  {
    sum+=pow((*starting_address_vec),2);
  }
 return pow(sum,0.5); 
}
int main()
{
  unsigned int N=1&lt;&lt;31; //the number implies 31 zeroes in front of 1. So it is 2^31.
  vector&lt;float&gt; vec(N); //whenever we declare an vector, it has undefined size(if we don't provide the size). Unless we declare it with some size. 
  //declaring vector of finite size; vector&lt;int&gt; v(100);
  //declaring vector without size; vector&lt;int&gt; vec;

  //let us fill the vector with N natural numbers(1,2,.......N).
  for (int i=0;i&lt;N;i++)
  {
      vec[i]=i;
  }
  //let us define a pointer to integer vector
  float *ptr_to_vec=&amp;vec[0]; //giving address of first element. Or we can just write: 

  //we shall modify the vector by multiply it with some real number. 
  //Real numbers are stored in float data types(require 4byte per real number) and double data types(8bytes).
  float multiplier=4.0;
  //Let us find the magnitude before changing the vector, 
  float mag_before=magnitude_finder(ptr_to_vec,N);
  increase_magnitude(ptr_to_vec,N,multiplier);
  float mag_after=magnitude_finder(ptr_to_vec,N);
  float ratio_of_magnitudes=mag_after/mag_before;
  cout&lt;&lt;"the final vector has magnitude "&lt;&lt;ratio_of_magnitudes&lt;&lt;" times the earlier one"&lt;&lt;endl&lt;&lt;"which should be equal to "&lt;&lt;pow(multiplier,0.5)&lt;&lt;endl;
  return 0;
}

</pre>
 
<p>
 <u>There are still some mistakes, I hope you can find these out</u>. <br />
</p>

<p>
Think what are these <a href="mistakes_demonstration.html">mistakes</a>, think really hard.<br />
</p>

<p>
Let me show my tryouts: <br />
</p>

<div id="The demonstration-Try outs"><h2 id="Try outs" class="header"><a href="#The demonstration-Try outs">Try outs</a></h2></div>

<ol>
<li>
<a href="code1_demo.html">code1_demo</a>

<li>
<a href="code2_demo.html">code2_demo</a>

<li>
<a href="code3_demo.html">code3_demo</a>

<li>
<a href="code4 demo.html">code4 demo</a>

<li>
<a href="code5 demo.html">code5 demo</a>

<li>
<a href="code6_demo.html">code6_demo</a>

<li>
<a href="code7_demo.html">code7_demo</a>

</ol>
<div id="The demonstration-Returning back to sum of two"><h2 id="Returning back to sum of two" class="header"><a href="#The demonstration-Returning back to sum of two">Returning back to sum of two</a></h2></div>

<div id="The demonstration-Returning back to sum of two-Serial programming"><h3 id="Serial programming" class="header"><a href="#The demonstration-Returning back to sum of two-Serial programming">Serial programming</a></h3></div>

<p>
After going through all the mistakes which I later wrote above while writing this blog, I am sharing the first try:<br />
</p>

<p>
The first try out:<br />
</p>
<pre cpp>
/******************************************************************************
* File:             code7.cpp
*
* Author:           Vishal  
* Created:          01/30/24 
* Description:      This code is supposed to do vector addition for cpu for very large size array of size 2^32
*****************************************************************************/
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;chrono&gt;

using std::cout;
using std::endl;
void AddVectorsOnCPU(double *array1, double *array2, size_t size)
{
  for (size_t i=0;i&lt;size;i++)
  {
    //array1[i]+=array2[i];  //or *(array+i)+=*(array2+i);
    *array1+=*array2;
    array1+=1;
    array2+=1;
  }
}
int main(int argc, char *argv[])
{
  auto time_0 = std::chrono::high_resolution_clock::now();
  size_t size1=1L&lt;&lt;32; //1L denotes long data type of 1.
  size_t size2=size1; 
  auto time_1 = std::chrono::high_resolution_clock::now();
  double *vec1=new double[size1]; //dynamics_array allocation does not take any time comparable to stack memory 
  double *vec2=new double[size2]; //dynamics_array allocation does not take any time comparable to stack memory 
  //let us fill the vector with N natural numbers(1,2,.......N).
  auto time_2 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_2 - time_1).count() / 1e6;
  auto elapsed_time_storing_N = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_1 - time_1).count() / 1e6;
  for (size_t i=0;i&lt;size1;i++)
  {
    vec1[i]=i+1;
    vec2[i]=i+2;
    //*(vec1+i)=i+1;
    //*(vec2+i)=i+2;
  }
  double sum_f=vec1[size1-1]+vec2[size2-1]; //
  printf("The last element of the array after sum shall be: %f \n",sum_f);
  auto time_3 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_assigning_values = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_3 - time_2).count() / 1e6;
  auto time_4 = std::chrono::high_resolution_clock::now();
  AddVectorsOnCPU(vec1,vec2,size1);
  auto time_5 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_modify_mag = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_5 - time_4).count() / 1e6;
  //let us print last 2 elements of new vector
  printf("The last 3 elements of the result are: \n")
  for(int i=0;i&lt;3;i++)
  {
    printf("%f   ,",vec1[size1-(2-i)-1]);
  }
  cout&lt;&lt;"\nthe time to assign N: "&lt;&lt;elapsed_time_storing_N&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to declare vector of N with doubles data type : "&lt;&lt;elapsed_time_1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to assign vectors: "&lt;&lt;elapsed_time_assigning_values&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to modify the vector_in: "&lt;&lt;elapsed_time_modify_mag&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;" The total time shall be :"&lt;&lt;elapsed_time_1+elapsed_time_assigning_values+elapsed_time_modify_mag&lt;&lt;" seconds"&lt;&lt;endl;
  delete[] vec1;
  delete[] vec2;
  return 0;
}
</pre>

<p>
<span id="The demonstration-Returning back to sum of two-Serial programming-Output"></span><strong id="Output">Output</strong><br />
</p>

<p>
The last element of the array after sum shall be: 8589934593.000000 <br />
The last 3 elements of the result are: <br />
8589934589.000000   ,8589934591.000000   ,8589934593.000000   ,<br />
the time to assign N: 0 seconds<br />
the time to declare vector of N with doubles data type : 1.3e-05 seconds<br />
the time to assign vectors: 26.8489 seconds<br />
the time to modify the vector_in: 10.8359 seconds<br />
 The total time shall be :37.6848 seconds<br />
</p>

<p>
real	0m37.837s<br />
user	0m23.566s<br />
sys 	0m14.189s<br />
</p>


<p>
<span id="The demonstration-Returning back to sum of two-Serial programming-Finally, found the code for serial programming, let us do that for parallel programming"></span><strong id="Finally, found the code for serial programming, let us do that for parallel programming">Finally, found the code for serial programming, let us do that for parallel programming</strong><br />
</p>

<div id="The demonstration-Parallel Programming"><h2 id="Parallel Programming" class="header"><a href="#The demonstration-Parallel Programming">Parallel Programming</a></h2></div>

<p>
The parallel programming is much more efficient in doing this task, since parallel programming requires use of multiple cores at the same time. This task is performed on NVIDIA <a href="../GPU and CPU basics.html">GPUs</a>, since these GPU has many cores/ALU. I am using GPU cluster with 56 SM (Streaming Multiprocessors) where each of these Streaming Multiprocessors has 64 cores, and each cores can run 32 threads concurrently. Which provides us \(56\times64\times32=1,14,688\) threads. This means that instead of adding each \(a_{i}+b_{i}\), one after one (in serial programming done above), we can utilize the parallel addition by maximum of 114688 threads at single clock cycle of GPU. <br />
The GPU has 750MHz of clock speed. Which means that this GPU has 5 times slower clock than our CPU with 3500MHz clock speed, and with this speed GPU can handle 750,000,000 instructions per second.<br />
</p>

<p>
Since I am using NVIDIA GPUs, we are constrained to use <a href="../Cuda Learning Center.html">CUDA</a>.<br />
</p>


<p>
<span id="The demonstration-Parallel Programming-NOTE"></span><strong id="NOTE">NOTE</strong>: We use the term <code>host</code> for CPU and the term <code>device</code> for GPU.<br />
</p>



<p>
We have to start with little different Algorithm:<br />
</p>

<div id="The demonstration-Parallel Programming-Algorithm"><h3 id="Algorithm" class="header"><a href="#The demonstration-Parallel Programming-Algorithm">Algorithm</a></h3></div>

<ol>
<li>
We will declare the size of array.

<li>
We have to allocate memory for two array on CPU

<li>
We then also have to allocate the memory of two array on GPU 

<li>
We assign some value to both the array on CPU

<li>
We copy both the array on memory locations of GPU

<li>
We declare grid dimensions(number of blocks in x,y,z) and block dimensions (number of threads in x, y,z).

</ol>
<p>
We can't just define any grid size and block size. Run this <a href="size_thread.cpp.html">program</a><br />
</p>

<ol>
<li>
Maximum blocks in x direction is \(2^{31}-1\).

<li>
Maximum blocks in y direction is \(2^{16}-1\).

<li>
Maximum blocks in z direction is \(2^{16}-1\).

<li>
Maximum threads per block is 1024 or \(2^{10}\) or 1&lt;&lt;10;

<li>
We then launch the kernel(we just name the function to be executed on device to be kernel).

<li>
CPU shall be told to wait untill kernel finishes the task.

<li>
The result will be saved on device memory locations, so we copy the data back.

<li>
Print the results and time it took to perform the task.

</ol>
<div id="The demonstration-Parallel Programming-Husttle"><h3 id="Husttle" class="header"><a href="#The demonstration-Parallel Programming-Husttle">Husttle</a></h3></div>
<p>
I started writing code for just taking an array of 100 elements and multiplying each element by 2. The resulting vector will be stored at respective memory locations.<br />
</p>

<pre cuda>
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
__global__ void modify(int *p, int N)
{
    int index=threadIdx.x+blockDim.x*blockIdx.x;
    if(index&lt;N)
    {
        p[index]*=2;
    }
}
int main(int argc, char *argv[])
{
    int N=100;
    int *d_p;
    int *h_p=new int[N]; 
    for (int i=0;i&lt;N;i++)
    {
        h_p[i]=i;
    }
    //need to allocate memory on device (GPU)
    cudaMalloc((void**)&amp;d_p,N*sizeof(int));
    //copy the vector h_p to respective locations of d_p
    cudaMemcpy(d_p, h_p,N*sizeof(int) ,cudaMemcpyHostToDevice);
    //declaring grid_size (number of blocks)
    dim3 grid_size(1); //using 1 block in x direction only
    dim3 block_size(100); //using 100 threads in this block
    //calling kernel to add each element by 2
    modify&lt;&lt;&lt;grid_size,block_size&gt;&gt;&gt;(d_p,N);
    cudaDeviceSynchronize(); // to tell the cpu to wait for the GPU to finish the task
    //copying the data back
    cudaMemcpy(h_p,d_p,N*sizeof(int),cudaMemcpyDeviceToHost);
    //printing the first 10 resulting numbers
    for (int i=0;i&lt;10;i++)
    {
        std::cout&lt;&lt;h_p[i]&lt;&lt;std::endl;
    }
    //deleting the memory locations and free the locations
    cudaFree(d_p);
    delete [] h_p; // this is how we free the array declared on host (CPU)
    return 0;
}
</pre>

<p>
<span id="The demonstration-Parallel Programming-Husttle-Output:"></span><strong id="Output:">Output:</strong><br />
</p>

<p>
0<br />
2<br />
4<br />
6<br />
8<br />
10<br />
12<br />
14<br />
16<br />
18<br />
</p>

<p>
real	0m0.454s<br />
user	0m0.037s<br />
sys	0m0.400s<br />
</p>


<div id="The demonstration-Parallel Programming-Adding Two vectors (Parallel Programming)"><h3 id="Adding Two vectors (Parallel Programming)" class="header"><a href="#The demonstration-Parallel Programming-Adding Two vectors (Parallel Programming)">Adding Two vectors (Parallel Programming)</a></h3></div>

<p>
The major problem is that the GPU Nodes can maximum store 16384 MiB. So I can't store anything which require 16GB, I am then restricted to use 8 GB of total space, 4 GB for each vector. To demonstrate the efficiency I am restricted to use maximum size of the array, so all I had to do is to reduce the size of data type it can store. <br />
</p>

<p>
Returning back to basic data type which store 8 bits. <code>uint8_t</code>, this can store numbers from 0 to \(2^8 -1=255\). <br />
Now I can't store the  \(a[i]=i\), so I had to store some numbers like 1, 2, 3...such that the sum of these don't exceed the number 255.<br />
</p>

<p>
The maximum number of elements both array can hold is \(2^{32}\) with each element occupying 1 byte (8 bits). In this way each array will occupy \(2^{30}\times2^{4}bytes\) =4 GB (1GB = \(2^{30}\) bytes) of RAM of GPU.<br />
</p>

<div id="The demonstration-Parallel Programming-Adding Two vectors (Parallel Programming)-Algorithm"><h4 id="Algorithm" class="header"><a href="#The demonstration-Parallel Programming-Adding Two vectors (Parallel Programming)-Algorithm">Algorithm</a></h4></div>
<ol>
<li>
Declare the size of both the array <code>size_t size1=1L&lt;&lt;32;</code>

<li>
Define and allocate the memory of host arrays.<code>uint8_t *host_pointer_array1 = new uint8_t[size1];</code>

<li>
Fill the array elements with numbers 1 and 2 in array1 and array2 respectively.

<li>
Allocate space for each of two vectors on GPU using <code>cudaMemcpy(device_pointer_array1,host_pointer_array1,size1*sizeof(uint8_t),cudaMemcpyHostToDevice);</code>

<li>
Define grid size <code>dim3 grid_size(1&lt;&lt;22)</code> and block sizes <code>dim3 block_size(1&lt;&lt;10)</code>. 

<li>
Define a function which runs on device to add two copied array on device and save the output on first device array.

<li>
wait for the function(kernel) to finish. <code>cudaDeviceSynchronize();</code>

<li>
Do it 50 times (in a loop).

<li>
Copy the results back to host_pointer_array1. <code>cudaMemcpy(host_pointer_array1,device_pointer_array1,size1*sizeof( uint8_t),cudaMemcpyDeviceToHost);</code>

<li>
Print the result.

</ol>
<div id="The demonstration-Parallel Programming-Adding Two vectors (Parallel Programming)-Code (parallel programming)"><h4 id="Code (parallel programming)" class="header"><a href="#The demonstration-Parallel Programming-Adding Two vectors (Parallel Programming)-Code (parallel programming)">Code (parallel programming)</a></h4></div>
<pre cuda>
/******************************************************************************
* File:             example_cuda.cpp
*
* Author:           Vishal Rao  
* Created:          01/30/24 
* Description:      This program will calculate the sum of vectors on gpu
*****************************************************************************/

#include &lt;cstdint&gt;
#include &lt;chrono&gt;
#include &lt;iostream&gt;
#include &lt;sys/types.h&gt;
using std::cout;
using std::endl;

__global__ void AddVectorsOnGPU( uint8_t *deviceptr1, uint8_t *deviceptr2, size_t size)
{
  size_t index=threadIdx.x + blockIdx.x * blockDim.x;
  //if(index==0) printf("Executing first thread \n");
 // if(index==size-1) printf("Executing last thread \n");
  if (index&lt;size)
  {
    deviceptr1[index]+=deviceptr2[index];
  }
}
int main(int argc, char *argv[])
{
  size_t size1=1L&lt;&lt;32;   //this allocates 8 GB(because of uint8_t data type of array) of RAM , so this is max we can do 
   uint8_t *host_pointer_array1 = new uint8_t[size1];
   uint8_t *host_pointer_array2 = new uint8_t[size1];

//let us fill first array elements with 1 and another array elements with 99. 
  auto time_0 = std::chrono::high_resolution_clock::now();
   for(size_t i=0; i&lt;size1;i++)
   {
     host_pointer_array1[i]=1;
     host_pointer_array2[i]=2;
   }
  auto time_1 = std::chrono::high_resolution_clock::now();
//let us allocate the memory for two vectors on gpu
   uint8_t *device_pointer_array1;
   uint8_t *device_pointer_array2;
  cudaMalloc((void**)&amp;device_pointer_array1,size1*sizeof( uint8_t));
  cudaMalloc((void**)&amp;device_pointer_array2,size1*sizeof( uint8_t));

//let us copy the arrays
  auto time_2 = std::chrono::high_resolution_clock::now();
  cudaMemcpy(device_pointer_array1,host_pointer_array1,size1*sizeof(uint8_t),cudaMemcpyHostToDevice);
  cudaMemcpy(device_pointer_array2,host_pointer_array2,size1*sizeof(uint8_t),cudaMemcpyHostToDevice);
  auto time_3 = std::chrono::high_resolution_clock::now();

  dim3 grid_size(1&lt;&lt;22);  //2^22 blocks, 
  dim3 block_size(1&lt;&lt;10); //2^10 threds per block

  auto time_4 = std::chrono::high_resolution_clock::now();
  for(int i=0;i&lt;=50;i++)
  {
  AddVectorsOnGPU&lt;&lt;&lt;grid_size,block_size&gt;&gt;&gt;(device_pointer_array1,device_pointer_array2,size1);
  cudaDeviceSynchronize();
}
  //we will add the vectors and store that in address of device_pointer_array1
  //we shall copy the data back to host
  auto time_5 = std::chrono::high_resolution_clock::now();
  cudaMemcpy(host_pointer_array1,device_pointer_array1,size1*sizeof( uint8_t),cudaMemcpyDeviceToHost);
  auto time_6 = std::chrono::high_resolution_clock::now();



  auto elapsed_time_1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_1 - time_0).count() / 1e6;
  auto elapsed_time_2 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_2 - time_1).count() / 1e6;
  auto elapsed_time_3 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_3 - time_2).count() / 1e6;
  auto elapsed_time_4 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_4 - time_3).count() / 1e6;
  auto elapsed_time_5 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_5 - time_4).count() / 1e6;
  auto elapsed_time_6 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_6 - time_5).count() / 1e6;

  //once copied we can print the array.
  printf("last 3 elements are (%d , %d, %d)   \n ",host_pointer_array1[size1-3],host_pointer_array1[size1-2],host_pointer_array1[size1-1]);

  //let us print the times
  cout&lt;&lt;"Time to perform the vector addition of "&lt;&lt;size1&lt;&lt;" elements done "&lt;&lt;50&lt;&lt;" times one after another is "&lt;&lt;elapsed_time_5&lt;&lt;" sec"&lt;&lt;endl;
  cout&lt;&lt;"Time to assign the vectors was "&lt;&lt;elapsed_time_1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"Time to copy the arrays to GPU "&lt;&lt;elapsed_time_3&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"Time to copy the array back to CPU "&lt;&lt;elapsed_time_6&lt;&lt;" seconds"&lt;&lt;endl;
  cudaFree(device_pointer_array1);
  cudaFree(device_pointer_array2);
  delete [] host_pointer_array1;
  delete [] host_pointer_array2;
  return 0;
}
</pre>

<p>
<span id="The demonstration-Parallel Programming-Adding Two vectors (Parallel Programming)-Code (parallel programming)-Output:"></span><strong id="Output:">Output:</strong><br />
</p>

<p>
last 3 elements are (103 , 103, 103)   <br />
Time to perform the vector addition of 4294967296 elements done 50 times one after another is 2.37934 sec<br />
Time to assign the vectors was 10.8694 seconds<br />
Time to copy the arrays to GPU 0.936566 seconds<br />
Time to copy the array back to CPU 0.558665 seconds<br />
</p>

<p>
real	0m15.330s<br />
user	0m12.975s<br />
sys	0m2.303s<br />
</p>


<div id="The demonstration-Comparing the same with serial programming"><h2 id="Comparing the same with serial programming" class="header"><a href="#The demonstration-Comparing the same with serial programming">Comparing the same with serial programming</a></h2></div>

<pre cpp>
/******************************************************************************
* File:             code7.cpp
*
* Author:           Vishal  
* Created:          01/30/24 
* Description:      This code is supposed to do vector addition for cpu for very large size array of size 2^32
*****************************************************************************/
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;iterator&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;chrono&gt;
using std::cout;
using std::endl;
void AddVectorsOnCPU(uint8_t *array1, uint8_t *array2, size_t size)
{
  for (size_t i=0;i&lt;size;i++)
  {
    //if(i==0) printf("adding first element \n");
   // if(i==size-1) printf("adding last element \n");
    array1[i]+=array2[i];
    /* *array1+=*array2; */
    /* array1+=1; */
    /* array2+=1; */
  }
}
int main(int argc, char *argv[])
{
  size_t size1=1L&lt;&lt;32; //1L denotes long data type of 1.
  size_t size2=size1; 
  uint8_t *vec1=new uint8_t[size1]; //dynamics_array allocation does not take any time comparable to stack memory 
  uint8_t *vec2=new uint8_t[size2]; //dynamics_array allocation does not take any time comparable to stack memory 

  //we can print the starting address of these array:
  cout&lt;&lt;"Printing the starting address of both array \n";
  cout&lt;&lt;static_cast&lt;void*&gt;(vec1)&lt;&lt;" "&lt;&lt;static_cast&lt;void*&gt;(vec2)&lt;&lt;endl;
  cout&lt;&lt;"Printing the last address of both array \n";
  cout&lt;&lt;static_cast&lt;void*&gt;(vec1+size1-1)&lt;&lt;" "&lt;&lt;static_cast&lt;void*&gt;(vec2+size1-1)&lt;&lt;endl;

  //let us fill the vector with 1 and 99 respectively.
  auto time_0 = std::chrono::high_resolution_clock::now();
  for (size_t i=0;i&lt;size1;i++)
  {
    vec1[i]=1;
    vec2[i]=2;
  }
  auto time_1 = std::chrono::high_resolution_clock::now();
  for(int i=0;i&lt;=50;i++)
  {
    AddVectorsOnCPU(vec1,vec2,size1);
  }
  auto time_2 = std::chrono::high_resolution_clock::now();

//finding elapsed_times
  auto elapsed_time_assigning_values = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_1 - time_0).count() / 1e6;
  auto elapsed_time_modify_mag = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_2 - time_1).count() / 1e6;

 printf(" Last 3 elements are ( %d, %d, %d ) \n",vec1[size1-3],vec1[size1-2],vec1[size1-1]);;
  cout&lt;&lt;"the time to assign vectors: "&lt;&lt;elapsed_time_assigning_values&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to add the vectors : "&lt;&lt;elapsed_time_modify_mag&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;" The total time shall be :"&lt;&lt;elapsed_time_assigning_values+elapsed_time_modify_mag&lt;&lt;" seconds"&lt;&lt;endl;
  delete[] vec1;
  delete[] vec2;
  return 0;
}
</pre>


<p>
<span id="The demonstration-Comparing the same with serial programming-Output:"></span><strong id="Output:">Output:</strong><br />
</p>

<p>
Printing the starting address of both array <br />
0x7ff8d42b0010 0x7ff7d42af010<br />
Printing the last address of both array <br />
0x7ff9d42b000f 0x7ff8d42af00f<br />
Last 3 elements are ( 103, 103, 103 ) <br />
the time to assign vectors: 10.954 seconds<br />
the time to add the vectors : 555.668 seconds<br />
The total time shall be :566.622 seconds<br />
</p>

<p>
real	9m26.644s<br />
user	9m23.875s<br />
sys 	0m1.867s<br />
</p>



<div id="The demonstration-Converting the code to Assembly language and then to machine language"><h2 id="Converting the code to Assembly language and then to machine language" class="header"><a href="#The demonstration-Converting the code to Assembly language and then to machine language">Converting the code to Assembly language and then to machine language</a></h2></div>

<ol>
<li>
<a href="Assembly_code_for_serial_programm_above.html">Assembly_code_for_serial_programm_above</a>

<li>
<a href="machine_language_for_serial_program_above.html">machine_language_for_serial_program_above</a>

</ol>
<div id="The demonstration-Additional resources"><h2 id="Additional resources" class="header"><a href="#The demonstration-Additional resources">Additional resources</a></h2></div>
<p>
<a href="https://aws.amazon.com/compare/the-difference-between-gpus-cpus/#:~:text=GPUs%20excel%20in%20parallel%20processing,them%20through%20at%20high%20speed.">https://aws.amazon.com/compare/the-difference-between-gpus-cpus/#:~:text=GPUs%20excel%20in%20parallel%20processing,them%20through%20at%20high%20speed.</a><br />
</p>

<p>
Thankyou! for reading...<br />
</p>

    </div>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script type="text/javascript">
        document.querySelectorAll('pre').forEach(block => hljs.highlightBlock(block));
    </script>
</body>
</html>

