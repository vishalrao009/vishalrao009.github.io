<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" type="text/css" href="../style.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="../rss.xml">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css" />
    <title>2024-02-01</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> 
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        body {
            background-image: url('../Images/parchment.jpg');
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            margin: 0;
            font-family: Arial, sans-serif;
            padding: 3cm; /* Add 3cm padding on all sides */
        }

        #content {
            color: #333;
            font-size: 16px;
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* Mobile Styles */
        @media only screen and (max-width: 600px) {
            body {
                padding: 1cm; /* Adjust padding for smaller screens */
            }

            #content {
                padding: 10px; /* Adjust padding for smaller screens */
            }
        }
    </style>
</head>
<body>
    <div id="content">
        
<div id="The demonstration"><h1 id="The demonstration" class="header"><a href="#The demonstration">The demonstration</a></h1></div>

<p>
It was decided that we meet at 3:30PM in a similar sitting space to discuss the ideas for the demonstrations. After a while it occurred to me that maybe the parallel programming can be of some fun. The idea got some encouragement and my quest to write the magical code begun.  <br />
</p>

<p>
On the day itself, I knew what to do, I came back from the office and started writing down the code which can show how parallel programming can be demonstrated to general public for the open day.  <br />
</p>

<p>
The idea was simple, but not that easy to write it an hour or a day.But I was writing the code with the will to finish it within few hours, because  <br />
</p>

<p>
The problem was simple, add two objects of type :  <br />
</p>
\[
\begin{bmatrix}
a_1 \\
a_2 \\
\vdots \\
a_n \\
\end{bmatrix}
+
\begin{bmatrix}
b_1 \\
b_2 \\
\vdots \\
b_n \\
\end{bmatrix}
=
\begin{bmatrix}
c_1 \\
c_2 \\
\vdots \\
c_n \\
\end{bmatrix}

\]


<p>
Simple, right. Let's do it then. We will start with the largest array(such column vectors/matrices are called as arrays) possible and write a C++ code to find the resulting addition.  <br />
</p>

<p>
The idea is to first do this task on CPU with a C++ program, and then add the same via use of parallel programming which require GPU and some programming Languages(like <a href="../Cuda Learning Center.html">CUDA</a>) which support use of <a href="../GPU and CPU basics.html">GPU</a>.  <br />
</p>

<div id="The demonstration-Beginning of the puzzles"><h2 id="Beginning of the puzzles" class="header"><a href="#The demonstration-Beginning of the puzzles">Beginning of the puzzles</a></h2></div>

<p>
So all I had to do is to write 2 programs to do the same task and produce the advantages of using parallel computing(programming on GPU) over serial programming (CPU).  <br />
</p>

<p>
So what's a program, it's just a set of instructions written Sequentially in a language which either can be read directly by computer (machine language) or by some software(compiler) which can translate it for the computer. Everything what we write, see and hear via the computer is written in form of 0's and 1's. Every word of set of instructions has to be converted into these 1's and 0's. Such form is often termed as binary language or the number system with base 2. It turns out that it is the way to store the information or instructions using 1(on) or 0(off) state of some very tiny switches(also known as transistors) which our computer is mostly made up of.  <br />
</p>

<p>
Since we can't write each instruction in form of 1's and 0's, we have developed a way to convert write down the instructions in some familiar language and the compiler for that language convert it to required machine language.  <br />
</p>

<p>
It turns out that C or C++ is the fastest language available. I chose C++ and started writing the desired code.  <br />
</p>

<p>
I might go bit technical here, will provide links to unknown keywords.  <br />
</p>

<div id="The demonstration-Algorithm (Man with Plan)"><h2 id="Algorithm (Man with Plan)" class="header"><a href="#The demonstration-Algorithm (Man with Plan)">Algorithm (Man with Plan)</a></h2></div>

<p>
The Algorithm or the way to write the code was simple, include some header files(to support some functionality to read and write, and write the main program (called as int main() or void main() which are main heart of the program)).  <br />
</p>

<p>
The program or the set of instructions can be reproduced from these steps:  <br />
</p>

<ol>
<li>
 Define a size(number of elements) of each array(both array has to be of equal size to add each respective \(n^{th}\) element).

<li>
 Store the size of array on some part of memory(size of array is just a number).

<li>
 Allocate space or memory of N( or size) numbers. Do it for another N such numbers too.

<li>
 Now fill up the memory space with some numbers.

<li>
 Write a piece of instruction to add these numbers \(a_{i}+b_{i}=c_{i}\) for all \(i\le N\).

<li>
 Store the respective addition of these N numbers into N memory spaces of first or second vector there itself. Therefore the first or second vector memory locations will have the answer of addition.

<li>
 Print the addition result for first or last few elements to confirm.

</ol>
<div id="The demonstration-Let the fun begin"><h2 id="Let the fun begin" class="header"><a href="#The demonstration-Let the fun begin">Let the fun begin</a></h2></div>
<p>
I started to finish the first step of plan(Algorithm).  <br />
</p>

<p>
So the program started with inclusion of header files, and defining main function. I knew that in order to show power of GPUs over CPUs, I have to start with arrays of largest possible size.  <br />
The largest possible size? Now the computer have two such memory locations:  <br />
</p>

<ol>
<li>
 RAM (Random Access Memory)

<li>
 Hard disk storage or Solid state drives

</ol>
<p>
I found that the size available was 256GB(1GB=1024x1024x1024x8 bits) of RAM, and 10TB(1TB=1024x1024x1024x1024x8) of Hard Disk space. I thought to use the maximum of these, to amaze the general populous.  <br />
</p>

<p>
Since the number of elements belongs to integers, I started with integer data type(All numbers and characters belongs to family of <a href="../fundamental data types.html">data types</a>.<br />
</p>

<pre cpp>
#include&lt;iostream&gt;
int main()
{
int N=10000000000;  //not allowed the maximum it can store is 2^{31}-1
}
</pre>

<p>
I kept pressing on key '0' to make the size (N) as large as possible, it wasn't long to realise that I just can't store any such large number in variable 'N'. Since 'N' is declared of data type (int) or integer, which compiler can only assign 4 bytes of memory with each byte having 8 bits of space, where place of a bit can be filled by either 0 or 1. With 4 such bytes I am left with 32 bits. So with these bits, the maximum number I can store was just \(2^{31} -1\) rather than \(2^{32}-1\), where did the 1 bit go, it turns out that the compiler also takes care of negative integers by taking one bit reserved for negative numbers.  <br />
</p>

<p>
With \(2^{31}-1\) as maximum size I can allocate with integer data type, I was bit off. Sooner I found that there is another data type which can store only positive integers(unsigned integers(no need for 1 bit reservation for negative numbers now)) making the total number of elements double. I was happy and so I tried and again this large number can't be stored in this variable..  <br />
</p>
<pre cpp>
unsigned int N= 10000000000; //again this large number can't be stored in this variable..
</pre>

<p>
The maximum number (\(2^{32}-1\)) can be stored using 'unsigned int' and binary shift operator (&lt;&lt; or &gt;&gt;).  <br />
but again error was on the way.....  <br />
</p>
<pre cpp>
unsigned int N = 1&lt;&lt;32 - 1 ; //here 1&lt;&lt;32 is just (100000000000000000000000000000000=2^32(in decimal number system(with base 10, our number system with 10 digits))) but we can't add to objects of where one piece is bigger than can be stored in unsigned int data type.
</pre>

<p>
We can't store 1&lt;&lt;32 or \(2^{32}\) in unsigned integer data type before we reduce 1 from it.  <br />
</p>

<p>
I then tried to look for other <a href="../fundamental data types.html">data types</a>, turns out that I can use 'long int(8 bytes)' or 'long long int(16 bytes)' or just 'long long(16 bytes)' to declare the sizes of the array, here the keywords like 'long' or 'long long' are termed as <a href="../Data modifiers.html.html">data modifiers</a>. These modifiers allocate the more number of space to store larger numbers into memory.  <br />
</p>

<p>
But if I choose a single number so large which can occupy the whole of available storage, then where will I store the N elements of both the arrays? It is better to look for the largest possible data type to store largest possible integer on the computer. It was 'unsigned long long int', which allocates 16 bytes for each variable of its type. For 16 bytes(16x8=128 bits), the maximum number I can store is \(2^{128} - 1\).  <br />
</p>

<p>
This number is so <a href="https://www.wolframalpha.com/input?i=2%5E128-1">huge</a> that even my text editor (NEOVIM which is used for writing this blog) takes minute to save the file.  <br />
</p>

<p>
For a moment even if we allocate memory for \(2^{127}\) elements(<code>int *array1=new int[N];</code>) and entered integers values (4 bytes) at all these \(2^{127}\) places for both column matrices. Even for entering the N+N values the CPU with (3400MHz clock frequency), will take 6 instructions per loop. In total it will take \(6\times2^{127}\) Instructions. And CPU can take care of \(3400.10^{6}\) instructions per second.  <br />
So the time CPU will take to assign the N+N values will be : \(\frac{6.2^{127}}{34. 10^{8}} = 3.022\times10^{29}\) sec. or \(3.022\times10^{22}\) years. We don't have that much time obviously.  <br />
Also storing 4 bytes at \(2^{127}\) places of memory is not possible as it requires huge amount of memory \(2^{102}\) GB of storage.  <br />
</p>

<pre cpp>
unsigned long long int N=1&lt;&lt;127;
//define both the column matrices and name these array1 and array2
for (unsigned long long int i=0;i&lt;N;i++) //2 instructions to enter into loop each time(i++ and i&lt;N)
{
    array1[i]=7;  //2 instruction or,  *(array+i)=7;
    array2[i]=3;  //2 instruction or, *(array+i)=3;
}
</pre>

<p>
Later, I found that the number of instructions I was guessing were not entirely correct (correct number of instructions are little more then anticipated), it is better to generate assembly code using <code>g++ -S programName.cpp</code> to generate the assembly file and look for number of instructions for the above 'for' loop.  <br />
</p>

<div id="The demonstration-Starting from basic (modifying single array)"><h2 id="Starting from basic (modifying single array)" class="header"><a href="#The demonstration-Starting from basic (modifying single array)">Starting from basic (modifying single array)</a></h2></div>

<p>
So it can't be the largest possible number a data type(<code>unsigned long long int</code>) can store, and with two such array the amount of required memory becomes double. I then thought to just store a single array with some numbers, and write a code to modify these numbers and store the result at same memory locations.  <br />
</p>

<p>
I thought to find the largest possible array which can be stored on 250GB of RAM. With 4 bytes at each locations(aiming to store integers or float/real numbers), I can store \(\frac{250.(1024.1024.1024)}{4}=67108864000\) numbers on the RAM. This number (67108864000) first needed to be registered in memory and we can't use integer data type(since <code>int N=67108864000;</code> can't be stored with 4 bytes or 32 bits of 1 and 0) , so we have to use <code>unsigned long int</code> data type which can store this number at some memory location (since <code>unsigned long int</code> reserves 8 bytes for data, we can store maximum of \(2^{64} - 1\) = <a href="https://www.wolframalpha.com/input/?i=2%5E63-1">huge number</a>.  <br />
</p>

<p>
Good news, we now have a number which can be stored using data type <code>unsigned long int</code> and we can reserve size of 4 bytes (for integers upto some large number), for each of the N=\(2^{64}-1\) numbers. For the moment we can start with just \(2^{63}\) numbers.  <br />
</p>

<p>
I tried with following:  <br />
</p>
<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1&lt;&lt;63; //wrong as we need to explicitly tell that 1 is Long literal
}
</pre>

<p>
<code>output: Error: shift count &gt; = Width of type</code>, which can be get rid with use of  <br />
</p>

<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63; //telling 1 belongs to Long int rather than 'int' data type
}
</pre>

<p>
I am now planning to store integers on these N memory locations with the following code:  <br />
</p>
<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63;
int arr[N];
for (int i=0;i&lt;N;i++)
{
    arr[i]=i; //storing i at each place of the array.
}
return 0;
}
</pre>

<p>
For most of the people the code will make sense, unless we really observe. The first error is in declaring an array of size N using <code>int arr[N];</code>, because this method allocate memory in <a href="Memory allocation.html">stack</a>, and since the stack memory is limited from 1MB to 8MB, we can't store 250GB sized array on these locations.  <br />
One has to look at <a href="dynamic memory allocation.html">dynamic memory allocation</a> of the array, which is done by <code>int *dynamic_array= new int[N];</code> or by using <code>std::vector&lt;int&gt; arr(N);</code>. This allocates memory in RAM region of space, so I thought that this is the best the compiler can do (Later while writing about this task, I found that it is possible to write on Hard disk and read from there and modify the vectors, but this story is saved for the end part.)  <br />
</p>

<p>
The second error is just a warning as the loop will not continue N times, since we have declared that variable 'i' is an integer, which will only run from 0 to \(2^{31}-1\) rather then 0 to \(2^{63}-1\). We have to use correct data types for variable 'i'.  <br />
</p>

<p>
I tried with 'std::vector&lt;int&gt; arr(N);'  <br />
</p>
<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63;
std::vector&lt;int&gt; arr(N); //takes a lot of instructions to assign memory ( so many seconds just to execute this line of code )
for (unsigned long int i=0;i&lt;N;i++)
{
    arr[i]=i; //storing i at each place of the array.
}
return 0;
}
</pre>

<p>
Turns out that there is some faster way of allocating the memory, it was the <code>int *arr=new int[N];</code>.  <br />
</p>

<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63;
int *arr= new int[N]; //allocates memory in no time.
for (unsigned long int i=0;i&lt;N;i++)
{
    arr[i]=i; //storing i at each place of the array. Still wrong, as it won't store 'i' at a[i] locations for i&gt;2^{31}-1
}
return 0;
}
</pre>

<p>
This method returns the first address of the allocated memory for 'N' integer variables. To store an address in variable 'arr' we have to declare it with some symbol which makes the variable 'arr' an <a href="../Pointers in c++.html">pointer variable</a>. <br />
</p>

<p>
Now it seems that we are fine, with the above code, but there is still something wrong, we have declared that the array locations can only store integer (integers store from \(-2^{31}\) to  \(2^{31}-1\) and not upto \(2^{63}-1\), which is full range of 'i'), but in the loop I am instructing compiler to store value of 'i' which could be greater than what an integer data type can store. If I increase data type of array to be 'unsigned long int', then each of N elements require double the memory (8 bytes instead of 4 bytes per memory location); i.e. if I use <code>long int * arr=new long int[N];</code>, this will try to allocate 500GB of space, which I don't have.<br />
</p>
<pre cpp>
#include&lt;iostream&gt;
int main()
{
unsigned long int N=1L&lt;&lt;63;
unsigned long int *arr= new unsigned long int[N]; //I don't have 500GB of RAM
for (unsigned long int i=0;i&lt;N;i++)
{
    arr[i]=i; //storing i at each place of the array.
}
return 0;
}
</pre>

<p>
If I am stubborn to insert the integers at each memory location with value of indices (i), then I am constrained to use the largest possible array to be of type unsigned integer.<br />
</p>

<p>
Later it turns out that there are similar data types to store such variables which are 'uint64_t, uint32_t, uint16_t, uint8_t' to store 64bits, 32bits, 16bits and 8bit respectively.<br />
</p>


<div id="The demonstration-Moving back to int"><h2 id="Moving back to int" class="header"><a href="#The demonstration-Moving back to int">Moving back to int</a></h2></div>
<p>
With all the high hopes in mind, I was constrained to chose the unsigned integers data types (which only store positive numbers).<br />
</p>

<p>
I gave my first try with the following code:<br />
</p>
<pre cpp>

//This program is intended to demonstrate simple serial programming where a vectors element gets modified serially. 
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using std::cout;
using std::endl;
using std::vector;

void increase_magnitude(float *starting_address,unsigned int size_vec, float mag_multiplyer)
{
  //the variable *starting_address is a pointer which will point to (or contain address of), the first element of the array.
  for (int i=0;i&lt;size_vec;i++)
  {
    //let us multiply the whole vector by 2
    //since we have address of first element of vector, we can take its value by use of *
    *starting_address=*starting_address * 2;
    //now we shall increase its address by 1.
    starting_address+=1;

  }
  //in this way at the same memory location we will have modified the vector.
}
float magnitude_finder(float *starting_address_vec,unsigned int size)
{
  //This function will return the magnitude of the vector. 
  float sum=0.0;
  for (int i=0;i&lt;size;i++)
  {
    sum+=pow((*starting_address_vec),2);
  }
 return pow(sum,0.5); 
}

int main()
{
  unsigned int N=1&lt;&lt;31; //the number implies 31 zeroes in front of 1. So it is 2^31.
  vector&lt;float&gt; vec(N); //whenever we declare an vector, it has undefined size(if we don't provide the size). Unless we declare it with some size. 
  //declaring vector of finite size; vector&lt;int&gt; v(100);
  //declaring vector without size; vector&lt;int&gt; vec;

  //let us fill the vector with N natural numbers(1,2,.......N).
  for (int i=0;i&lt;N;i++)
  {
      vec[i]=i;
  }
  //let us define a pointer to integer vector
  float *ptr_to_vec=&amp;vec[0]; //giving address of first element. Or we can just write: 

  //we shall modify the vector by multiply it with some real number. 
  //Real numbers are stored in float data types(require 4byte per real number) and double data types(8bytes).
  float multiplier=4.0;
  //Let us find the magnitude before changing the vector, 
  float mag_before=magnitude_finder(ptr_to_vec,N);
  increase_magnitude(ptr_to_vec,N,multiplier);
  float mag_after=magnitude_finder(ptr_to_vec,N);
  float ratio_of_magnitudes=mag_after/mag_before;
  cout&lt;&lt;"the final vector has magnitude "&lt;&lt;ratio_of_magnitudes&lt;&lt;" times the earlier one"&lt;&lt;endl&lt;&lt;"which should be equal to "&lt;&lt;pow(multiplier,0.5)&lt;&lt;endl;
  return 0;
}

</pre>
 
<p>
 <u>There are still some mistakes, I hope you can find these out</u>. <br />
</p>

<p>
 <span id="The demonstration-Moving back to int-Think what are these mistakes, think really hard."></span><strong id="Think what are these mistakes, think really hard.">Think what are these mistakes, think really hard.</strong><br />
</p>

<p>
<span id="The demonstration-Moving back to int-Mistakes"></span><strong id="Mistakes">Mistakes</strong>:<br />
</p>
<ol>
<li>
Normal person who does day to day programming is habitual of assigning the index an data type of integer, as the index never exceed such a large number an integer data type can store. It was the same mistake I described before.  

<li>
The second mistake is to assigning the float data type to each elements (\(a_{i}\)), but it is not that hard to see that once we multiply the largest possible number by 4.2, it won't be stored with just 31 bits (1 bit reserved for negative numbers). 

<li>
Third mistake is similar to second one, In the function defined to find the magnitude of the vector, we have declared the variable 'sum' as of type 'float', which can only store real numbers with 4 bytes. Inside the loop we are finding square of very large numbers, after squaring the numbers become too large to be stored in 'float'  data type. One has to use 'double' data type for variable 'sum'. 

</ol>
<p>
Let me show the tryouts to resolve.<br />
</p>

<div id="The demonstration-Try outs"><h2 id="Try outs" class="header"><a href="#The demonstration-Try outs">Try outs</a></h2></div>
<div id="The demonstration-Try outs-Code 1"><h3 id="Code 1" class="header"><a href="#The demonstration-Try outs-Code 1">Code 1</a></h3></div>
<pre cpp>

//This program is intended to demonstrate simple serial programming where a vectors element gets modified serially. 
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using std::cout;
using std::endl;
using std::vector;

void increase_magnitude(float *starting_address,unsigned int size_vec, float mag_multiplyer)
{
  //the variable *starting_address is a pointer which will point to (or contain address of), the first element of the array.
  for (int i=0;i&lt;size_vec;i++)
  {
    //let us multiply the whole vector by 2
    //since we have address of first element of vector, we can take its value by use of *
    *starting_address=*starting_address * 2;
    //now we shall increase its address by 1.
    starting_address+=1;

  }

  //in this way at the same memory location we will have modified the vector.

}

float magnitude_finder(float *starting_address_vec,unsigned int size)
{
  //This function will return the magnitude of the vector. 
  float sum=0.0;
  for (int i=0;i&lt;size;i++)
  {
    sum+=pow((*starting_address_vec),2);
  }
 return pow(sum,0.5); 
}


int main(int argc, char *argv[])
{
  unsigned int N=1&lt;&lt;31; //the number implies 31 zeroes in front of 1. So it is 2^31.
  vector&lt;float&gt; vec(N); //whenever we declare an vector, it has undefined size(if we don't provide the size). Unless we declare it with some size. 
  //declaring vector of finite size; vector&lt;int&gt; v(100);
  /* vector&lt;int&gt;v1(100); */
  //declaring vector without size; vector&lt;int&gt; vec;

  //let us define a pointer to integer vector
  //let us fill the vector with N natural numbers(1,2,.......N).
  cout&lt;&lt;N&lt;&lt;endl;

  for (int i=0;i&lt;N;i++)
  {
      vec[i]=i;
  }

  float *ptr_to_vec=&amp;vec[0]; //giving address of first element. Or we can just write: 

  //we shall modify the vector by multiply it with some real number. 
  //Real numbers are stored in float data types(require 4byte per real number) and double data types(8bytes).
  float multiplier=4.0;

  //Let us find the magnitude before changing the vector, 
  float mag_before=magnitude_finder(ptr_to_vec,N);
  increase_magnitude(ptr_to_vec,N,multiplier);
  float mag_after=magnitude_finder(ptr_to_vec,N);
  float ratio_of_magnitudes=mag_after/mag_before;
  cout&lt;&lt;"the final vector has magnitude "&lt;&lt;ratio_of_magnitudes&lt;&lt;" times the earlier one"&lt;&lt;endl&lt;&lt;"which should be equal to "&lt;&lt;pow(multiplier,0.5)&lt;&lt;endl;
  return 0;
}

</pre>

<p>
```<br />
<span id="The demonstration-Try outs-Code 1-Output"></span><strong id="Output">Output</strong>:<br />
</p>

<p>
2147483648<br />
the final vector has magnitude -nan times the earlier one<br />
which should be equal to 2<br />
</p>

<p>
```<br />
</p>

<p>
<span id="The demonstration-Try outs-Code 1-Remarks: The magnitude can't handle large numbers in float data type, one must use double or long double."></span><strong id="Remarks: The magnitude can't handle large numbers in float data type, one must use double or long double.">Remarks: The magnitude can't handle large numbers in float data type, one must use double or long double.</strong> <br />
</p>

<div id="The demonstration-Try outs-Code 2"><h3 id="Code 2" class="header"><a href="#The demonstration-Try outs-Code 2">Code 2</a></h3></div>

<pre cpp>

//This program is intended to demonstrate simple serial programming where a vectors element gets modified serially. 
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;

using std::cout;
using std::endl;
using std::vector;

void increase_magnitude(float *starting_address,unsigned int size_vec, float mag_multiplyer)
{
  //the variable *starting_address is a pointer which will point to (or contain address of), the first element of the array.
  for (int i=0;i&lt;size_vec;i++) 
  {
    *starting_address=*starting_address * mag_multiplyer;
    starting_address+=1; 
  } 
  //in this way at the same memory location we will have modified the vector.
}

double magnitude_finder(float *starting_address_vec,unsigned int size)
{
  //This function will return the magnitude of the vector. 
  double sum=0.0;
  for (int i=0;i&lt;size;i++) 
  {
    sum+=pow((*starting_address_vec),2); 
    starting_address_vec+=1; 
  }
 return pow(sum,0.5); 
}


int main(int argc, char *argv[])
{
  unsigned int N=1&lt;&lt;31; //the number implies 31 zeroes in front of 1. So it is 2^31.
  vector&lt;float&gt; vec; //whenever we declare an vector, it has undefined size(if we don't provide the size). Unless we declare it with some size. 
  //let us fill the vector with N natural numbers(1,2,.......N).
  for (int i=0;i&lt;N;i++)
  {
      vec.push_back(i);
  }
  //let us define a pointer to integer vector
  float *ptr_to_vec=&amp;vec[0]; //giving address of first element. Or we can just write: 
  //we shall modify the vector by multiply it with some real number. 
  //Real numbers are stored in float data types(require 4byte per real number) and double data types(8bytes).
  float multiplier=4.0;
  //Let us find the magnitude before changing the vector, 
  double mag_before=magnitude_finder(ptr_to_vec,N);
  increase_magnitude(ptr_to_vec,N,multiplier);
  double mag_after=magnitude_finder(ptr_to_vec,N);
  double ratio_of_magnitudes=mag_after/mag_before;
  printf("Value of magnitude before multiplying the vector is %0.f  \n",mag_before);
  printf("Value of magnitude after multiplying the vector is %0.f   \n",mag_after);
  cout&lt;&lt;"the final vector has magnitude "&lt;&lt;ratio_of_magnitudes&lt;&lt;" times the earlier one"&lt;&lt;endl&lt;&lt;"which should be equal to the multiplier (which is: "&lt;&lt;multiplier&lt;&lt;")"&lt;&lt;endl;
  return 0;
}
</pre>

<p>
<span id="The demonstration-Try outs-Code 2-Output:"></span><strong id="Output:">Output:</strong><br />
```<br />
Value of magnitude before multiplying the vector is 57455839005302  <br />
Value of magnitude after multiplying the vector is 229823356021209   <br />
the final vector has magnitude 4 times the earlier one<br />
which should be equal to the multiplier (which is: 4)<br />
</p>

<p>
real	3m8.202s<br />
user	2m59.683s<br />
sys	0m6.290s<br />
</p>

<p>
```<br />
</p>

<p>
<span id="The demonstration-Try outs-Code 2-Remarks: we can have a look at the time it takes for different parts of the code"></span><strong id="Remarks: we can have a look at the time it takes for different parts of the code">Remarks: we can have a look at the time it takes for different parts of the code</strong> <br />
</p>

<div id="The demonstration-Try outs-Code 3 (checking time):"><h3 id="Code 3 (checking time):" class="header"><a href="#The demonstration-Try outs-Code 3 (checking time):">Code 3 (checking time):</a></h3></div>
<pre cpp>


//This program is intended to demonstrate simple serial programming where a vectors element gets modified serially. 
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;chrono&gt;

using std::cout;
using std::endl;
using std::vector;

void increase_magnitude(float *starting_address,unsigned int size_vec, float mag_multiplyer)
{
  //the variable *starting_address is a pointer which will point to (or contain address of), the first element of the array.
  for (int i=0;i&lt;size_vec;i++) 
  {
    //let us multiply the whole vector by 2
    //since we have address of first element of vector, we can take its value by use of *
    *starting_address=*starting_address * mag_multiplyer;
    //now we shall increase its address by 1.
    starting_address+=1; 

  } 

  //in this way at the same memory location we will have modified the vector.

}

double magnitude_finder(float *starting_address_vec,unsigned int size)
{
  //This function will return the magnitude of the vector. 
  double sum=0.0;
  for (int i=0;i&lt;size;i++) 
  {
    sum+=pow((*starting_address_vec),2); 
    starting_address_vec+=1; 
  }
 return pow(sum,0.5); 
}


int main(int argc, char *argv[])
{
  auto time_0 = std::chrono::high_resolution_clock::now();
  unsigned int N=1&lt;&lt;31; //the number implies 31 zeroes in front of 1. So it is 2^31.
  auto time_1 = std::chrono::high_resolution_clock::now();
  vector&lt;float&gt; vec; //whenever we declare an vector, it has undefined size(if we don't provide the size). Unless we declare it with some size. 

  //let us fill the vector with N natural numbers(1,2,.......N).
  auto time_2 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_2 - time_1).count() / 1e6;
  auto elapsed_time_storing_N = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_1 - time_1).count() / 1e6;
  for (int i=0;i&lt;N;i++)
  {
      vec.push_back(i);
  }
  auto time_3 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_assigning_values = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_3 - time_2).count() / 1e6;

  //let us define a pointer to integer vector
  float *ptr_to_vec=&amp;vec[0]; //giving address of first element. Or we can just write: 

  //we shall modify the vector by multiply it with some real number. 
  //Real numbers are stored in float data types(require 4byte per real number) and double data types(8bytes).
  float multiplier=4.0;

  //Let us find the magnitude before changing the vector, 

  double mag_before=magnitude_finder(ptr_to_vec,N);
  auto time_4 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_4 - time_3).count() / 1e6;



  increase_magnitude(ptr_to_vec,N,multiplier);
  auto time_5 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_modify_mag = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_5 - time_4).count() / 1e6;


  double mag_after=magnitude_finder(ptr_to_vec,N);
  auto time_6 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag2 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_6 - time_5).count() / 1e6;

  double ratio_of_magnitudes=mag_after/mag_before;

  printf("Value of magnitude before multiplying the vector is %0.f  \n",mag_before);
  printf("Value of magnitude after multiplying the vector is %0.f   \n",mag_after);
  cout&lt;&lt;"the final vector has magnitude "&lt;&lt;ratio_of_magnitudes&lt;&lt;" times the earlier one"&lt;&lt;endl&lt;&lt;"which should be equal to the multiplier (which is: "&lt;&lt;multiplier&lt;&lt;")"&lt;&lt;endl;

  cout&lt;&lt;"the time to assign N: "&lt;&lt;elapsed_time_storing_N&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to declare vector of N with doubles data type : "&lt;&lt;elapsed_time_1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to assign vector: "&lt;&lt;elapsed_time_assigning_values&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to find magnitude of vector_in: "&lt;&lt;elapsed_time_mag1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to modify the vector_in: "&lt;&lt;elapsed_time_modify_mag&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to calculate magnitude of modified vector_in: "&lt;&lt;elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;" The total time shall be :"&lt;&lt;elapsed_time_1+elapsed_time_assigning_values+elapsed_time_mag1+elapsed_time_modify_mag+elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;

  return 0;
}

</pre>

<p>
<span id="The demonstration-Try outs-Code 3 (checking time):-Output:"></span><strong id="Output:">Output:</strong><br />
</p>

<p>
```<br />
Value of magnitude before multiplying the vector is 57455839005302  <br />
Value of magnitude after multiplying the vector is 229823356021209   <br />
the final vector has magnitude 4 times the earlier one<br />
which should be equal to the multiplier (which is: 4)<br />
the time to assign N: 0 seconds<br />
the time to declare vector of N with doubles data type : 0 seconds<br />
the time to assign vector: 85.9075 seconds<br />
the time to find magnitude of vector_in: 47.2924 seconds<br />
the time to modify the vector_in: 4.6991 seconds<br />
the time to calculate magnitude of modified vector_in: 47.2303 seconds<br />
 The total time shall be :185.129 seconds<br />
</p>

<p>
real	3m5.443s<br />
user	2m58.632s<br />
sys	0m6.317s<br />
```<br />
</p>


<p>
<span id="The demonstration-Try outs-Code 3 (checking time):-Remarks: Note that the time taken in assigning vector and finding magnitude is very large"></span><strong id="Remarks: Note that the time taken in assigning vector and finding magnitude is very large">Remarks: Note that the time taken in assigning vector and finding magnitude is very large</strong><br />
</p>


<div id="The demonstration-Try outs-Code 4"><h3 id="Code 4" class="header"><a href="#The demonstration-Try outs-Code 4">Code 4</a></h3></div>
<pre cpp>

//This program is intended to demonstrate simple serial programming where a vectors element gets modified serially. 
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;chrono&gt;

using std::cout;
using std::endl;
using std::vector;

void increase_magnitude(float *starting_address,unsigned int size_vec, float mag_multiplyer)
{
  //the variable *starting_address is a pointer which will point to (or contain address of), the first element of the array.
  for (int i=0;i&lt;size_vec;i++) //2 instructions per loop for updating i, and checking i&lt;size  
  {
    //let us multiply the whole vector by 2
    //since we have address of first element of vector, we can take its value by use of *
    *starting_address=*starting_address * mag_multiplyer; //4 instructions
    //now we shall increase its address by 1.
    starting_address+=1; //2 instructions (add sum, and update sum)

  } 
  //in total loop shall have 8 instructions per loop, so time taken shall be (size/clockspeed)*instructions per loop

  //in this way at the same memory location we will have modified the vector.

}

double magnitude_finder(float *starting_address_vec,unsigned int size)
{
  //This function will return the magnitude of the vector. 
  double sum=0.0;
  for (int i=0;i&lt;size;i++) //2 instructions per loop for updating i, and checking i&lt;size
  {
    /* sum+=pow((*starting_address_vec),2); //power function is slow (10 times)*/
    sum+=(*starting_address_vec)*(*starting_address_vec); //5 instructions
    starting_address_vec+=1; //2 instructions
  }
  //9 instructions per loop
 return pow(sum,0.5); 
}


int main(int argc, char *argv[])
{
  auto time_0 = std::chrono::high_resolution_clock::now();
  unsigned int N=1&lt;&lt;31; //the number implies 31 zeroes in front of 1. So it is 2^31.
  auto time_1 = std::chrono::high_resolution_clock::now();
  vector&lt;float&gt; vec; //whenever we declare an vector, it has undefined size(if we don't provide the size). Unless we declare it with some size. 
  /* float *vec=new float[N]; //dynamics_array allocation does not take any time comparable to stack memory */
  //declaring vector of finite size; vector&lt;int&gt; v(100);
  /* vector&lt;int&gt;v1(100); */
  //declaring vector without size; vector&lt;int&gt; vec;

  //let us define a pointer to integer vector
  //let us fill the vector with N natural numbers(1,2,.......N).
  auto time_2 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_2 - time_1).count() / 1e6;
  auto elapsed_time_storing_N = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_1 - time_1).count() / 1e6;
  for (int i=0;i&lt;N;i++)
  {
      vec.push_back(i);
  }
  auto time_3 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_assigning_values = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_3 - time_2).count() / 1e6;
  /* cout&lt;&lt;vec[0]&lt;&lt;vec[1]&lt;&lt;vec[2]&lt;&lt;vec[3]&lt;&lt;endl; */

  float *ptr_to_vec=&amp;vec[0]; //giving address of first element. Or we can just write: 

  //we shall modify the vector by multiply it with some real number. 
  //Real numbers are stored in float data types(require 4byte per real number) and double data types(8bytes).
  float multiplier=4.0;

  //Let us find the magnitude before changing the vector, 

  double mag_before=magnitude_finder(ptr_to_vec,N);
  auto time_4 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_4 - time_3).count() / 1e6;



  increase_magnitude(ptr_to_vec,N,multiplier);
  auto time_5 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_modify_mag = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_5 - time_4).count() / 1e6;


  double mag_after=magnitude_finder(ptr_to_vec,N);
  auto time_6 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag2 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_6 - time_5).count() / 1e6;

  double ratio_of_magnitudes=mag_after/mag_before;

  printf("Value of magnitude before multiplying the vector is %0.f  \n",mag_before);
  printf("Value of magnitude after multiplying the vector is %0.f   \n",mag_after);
  cout&lt;&lt;"the final vector has magnitude "&lt;&lt;ratio_of_magnitudes&lt;&lt;" times the earlier one"&lt;&lt;endl&lt;&lt;"which should be equal to the multiplier (which is: "&lt;&lt;multiplier&lt;&lt;")"&lt;&lt;endl;

  cout&lt;&lt;"the time to assign N: "&lt;&lt;elapsed_time_storing_N&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to declare vector of N with doubles data type : "&lt;&lt;elapsed_time_1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to assign vector: "&lt;&lt;elapsed_time_assigning_values&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to find magnitude of vector_in: "&lt;&lt;elapsed_time_mag1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to modify the vector_in: "&lt;&lt;elapsed_time_modify_mag&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to calculate magnitude of modified vector_in: "&lt;&lt;elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;" The total time shall be :"&lt;&lt;elapsed_time_1+elapsed_time_assigning_values+elapsed_time_mag1+elapsed_time_modify_mag+elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;

  /* delete[] vec; */
  return 0;
}


</pre>

<p>
<span id="The demonstration-Try outs-Code 4-Output:"></span><strong id="Output:">Output:</strong><br />
```<br />
Value of magnitude before multiplying the vector is 57455839005566  <br />
Value of magnitude after multiplying the vector is 229823356022263   <br />
the final vector has magnitude 4 times the earlier one<br />
which should be equal to the multiplier (which is: 4)<br />
the time to assign N: 0 seconds<br />
the time to declare vector of N with doubles data type : 0 seconds<br />
the time to assign vector: 86.8617 seconds<br />
the time to find magnitude of vector_in: 5.79997 seconds<br />
the time to modify the vector_in: 4.67525 seconds<br />
the time to calculate magnitude of modified vector_in: 5.77226 seconds<br />
 The total time shall be :103.109 seconds<br />
</p>

<p>
real	1m43.422s<br />
user	1m37.196s<br />
sys	0m5.959s<br />
```<br />
</p>

<p>
Remarks: Need to stop using methods of objects like : vec.push_back(), might include too many instructions per loop<br />
</p>


<div id="The demonstration-Try outs-Code 5"><h3 id="Code 5" class="header"><a href="#The demonstration-Try outs-Code 5">Code 5</a></h3></div>
<pre cpp>

//This program is intended to demonstrate simple serial programming where a vectors element gets modified serially. 
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;chrono&gt;

using std::cout;
using std::endl;
using std::vector;

void increase_magnitude(float *starting_address,unsigned int size_vec, float mag_multiplyer)
{
  //the variable *starting_address is a pointer which will point to (or contain address of), the first element of the array.
  for (int i=0;i&lt;size_vec;i++) //2 instructions per loop for updating i, and checking i&lt;size  
  {
    //let us multiply the whole vector by 2
    //since we have address of first element of vector, we can take its value by use of *
    *starting_address=*starting_address * mag_multiplyer; //4 instructions
    //now we shall increase its address by 1.
    starting_address+=1; //2 instructions (add sum, and update sum)

  } 
  //in total loop shall have 8 instructions per loop, so time taken shall be (size/clockspeed)*instructions per loop

  //in this way at the same memory location we will have modified the vector.

}

double magnitude_finder(float *starting_address_vec,unsigned int size)
{
  //This function will return the magnitude of the vector. 
  double sum=0.0;
  for (int i=0;i&lt;size;i++) //2 instructions per loop for updating i, and checking i&lt;size
  {
    /* sum+=pow((*starting_address_vec),2); //power function is slow (10 times)*/
    sum+=(*starting_address_vec)*(*starting_address_vec); //5 instructions
    starting_address_vec+=1; //2 instructions
  }
  //9 instructions per loop
 return pow(sum,0.5); 
}


int main(int argc, char *argv[])
{
  auto time_0 = std::chrono::high_resolution_clock::now();
  unsigned int N=1&lt;&lt;31; //the number implies 31 zeroes in front of 1. So it is 2^31.
  auto time_1 = std::chrono::high_resolution_clock::now();
  vector&lt;float&gt; vec(N); //whenever we declare an vector, it has undefined size(if we don't provide the size). Unless we declare it with some size. 
  /* float *vec=new float[N]; //dynamics_array allocation does not take any time comparable to stack memory */

  //let us fill the vector with N natural numbers(1,2,.......N).
  auto time_2 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_2 - time_1).count() / 1e6;
  auto elapsed_time_storing_N = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_1 - time_1).count() / 1e6;
  for (int i=0;i&lt;N;i++)
  {
    vec[i]=i;
  }
  auto time_3 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_assigning_values = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_3 - time_2).count() / 1e6;
  /* cout&lt;&lt;vec[0]&lt;&lt;vec[1]&lt;&lt;vec[2]&lt;&lt;vec[3]&lt;&lt;endl; */

  //let us define a pointer to integer vector
  float *ptr_to_vec=&amp;vec[0]; //giving address of first element. Or we can just write: 

  //we shall modify the vector by multiply it with some real number. 
  //Real numbers are stored in float data types(require 4byte per real number) and double data types(8bytes).
  float multiplier=4.0;

  //Let us find the magnitude before changing the vector, 

  double mag_before=magnitude_finder(ptr_to_vec,N);
  auto time_4 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_4 - time_3).count() / 1e6;



  increase_magnitude(ptr_to_vec,N,multiplier);
  auto time_5 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_modify_mag = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_5 - time_4).count() / 1e6;


  double mag_after=magnitude_finder(ptr_to_vec,N);
  auto time_6 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag2 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_6 - time_5).count() / 1e6;

  double ratio_of_magnitudes=mag_after/mag_before;

  printf("Value of magnitude before multiplying the vector is %0.f  \n",mag_before);
  printf("Value of magnitude after multiplying the vector is %0.f   \n",mag_after);
  cout&lt;&lt;"the final vector has magnitude "&lt;&lt;ratio_of_magnitudes&lt;&lt;" times the earlier one"&lt;&lt;endl&lt;&lt;"which should be equal to the multiplier (which is: "&lt;&lt;multiplier&lt;&lt;")"&lt;&lt;endl;

  cout&lt;&lt;"the time to assign N: "&lt;&lt;elapsed_time_storing_N&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to declare vector of N with doubles data type : "&lt;&lt;elapsed_time_1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to assign vector: "&lt;&lt;elapsed_time_assigning_values&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to find magnitude of vector_in: "&lt;&lt;elapsed_time_mag1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to modify the vector_in: "&lt;&lt;elapsed_time_modify_mag&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to calculate magnitude of modified vector_in: "&lt;&lt;elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;" The total time shall be :"&lt;&lt;elapsed_time_1+elapsed_time_assigning_values+elapsed_time_mag1+elapsed_time_modify_mag+elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;

  return 0;
}

</pre>

<p>
<span id="The demonstration-Try outs-Code 5-Output"></span><strong id="Output">Output</strong><br />
```<br />
Value of magnitude before multiplying the vector is 57455839005566  <br />
Value of magnitude after multiplying the vector is 229823356022263   <br />
the final vector has magnitude 4 times the earlier one<br />
which should be equal to the multiplier (which is: 4)<br />
the time to assign N: 0 seconds<br />
the time to declare vector of N with doubles data type : 8.45935 seconds<br />
the time to assign vector: 7.44733 seconds<br />
the time to find magnitude of vector_in: 5.80138 seconds<br />
the time to modify the vector_in: 4.68935 seconds<br />
the time to calculate magnitude of modified vector_in: 5.81678 seconds<br />
 The total time shall be :32.2142 seconds<br />
</p>

<p>
real	0m32.528s<br />
user	0m28.995s<br />
sys	0m3.434s<br />
</p>

<p>
```<br />
</p>

<p>
Remarks: We can try allocating the N sized vector using new keyword. (dynamic memoery allocation)<br />
</p>

<div id="The demonstration-Try outs-Code 6:"><h3 id="Code 6:" class="header"><a href="#The demonstration-Try outs-Code 6:">Code 6:</a></h3></div>
<pre cpp>
//This program is intended to demonstrate simple serial programming where a vectors element gets modified serially. 
//
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;chrono&gt;

using std::cout;
using std::endl;
using std::vector;

void increase_magnitude(float *starting_address,unsigned int size_vec, float mag_multiplyer)
{
  //the variable *starting_address is a pointer which will point to (or contain address of), the first element of the array.
  for (int i=0;i&lt;size_vec;i++) //2 instructions per loop for updating i, and checking i&lt;size  
  {
    //let us multiply the whole vector by 2
    //since we have address of first element of vector, we can take its value by use of *
    *starting_address=*starting_address * mag_multiplyer; //4 instructions
    //now we shall increase its address by 1.
    starting_address+=1; //2 instructions (add sum, and update sum)

  } 
  //in total loop shall have 8 instructions per loop, so time taken shall be (size/clockspeed)*instructions per loop

  //in this way at the same memory location we will have modified the vector.

}

double magnitude_finder(float *starting_address_vec,unsigned int size)
{
  //This function will return the magnitude of the vector. 
  double sum=0.0;
  for (int i=0;i&lt;size;i++) //2 instructions per loop for updating i, and checking i&lt;size
  {
    /* sum+=pow((*starting_address_vec),2); //power function is slow (10 times)*/
    sum+=(*starting_address_vec)*(*starting_address_vec); //5 instructions
    starting_address_vec+=1; //2 instructions
  }
  //9 instructions per loop
 return pow(sum,0.5); 
}


int main(int argc, char *argv[])
{
  auto time_0 = std::chrono::high_resolution_clock::now();
  unsigned int N=1&lt;&lt;31; //the number implies 31 zeroes in front of 1. So it is 2^31.
  auto time_1 = std::chrono::high_resolution_clock::now();
  float *vec=new float[N]; //dynamics_array allocation does not take any time comparable to stack memory 

  //let us fill the vector with N natural numbers(1,2,.......N).
  auto time_2 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_2 - time_1).count() / 1e6;
  auto elapsed_time_storing_N = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_1 - time_1).count() / 1e6;
  for (int i=0;i&lt;N;i++)
  {
    vec[i]=i;
  }
  auto time_3 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_assigning_values = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_3 - time_2).count() / 1e6;
  /* cout&lt;&lt;vec[0]&lt;&lt;vec[1]&lt;&lt;vec[2]&lt;&lt;vec[3]&lt;&lt;endl; */

  //let us define a pointer to integer vector
  float *ptr_to_vec=&amp;vec[0]; //giving address of first element. Or we can just write: 

  //we shall modify the vector by multiply it with some real number. 
  //Real numbers are stored in float data types(require 4byte per real number) and double data types(8bytes).
  float multiplier=4.0;

  //Let us find the magnitude before changing the vector, 

  double mag_before=magnitude_finder(ptr_to_vec,N);
  auto time_4 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_4 - time_3).count() / 1e6;



  increase_magnitude(ptr_to_vec,N,multiplier);
  auto time_5 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_modify_mag = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_5 - time_4).count() / 1e6;


  double mag_after=magnitude_finder(ptr_to_vec,N);
  auto time_6 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag2 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_6 - time_5).count() / 1e6;

  double ratio_of_magnitudes=mag_after/mag_before;

  printf("Value of magnitude before multiplying the vector is %0.f  \n",mag_before);
  printf("Value of magnitude after multiplying the vector is %0.f   \n",mag_after);
  cout&lt;&lt;"the final vector has magnitude "&lt;&lt;ratio_of_magnitudes&lt;&lt;" times the earlier one"&lt;&lt;endl&lt;&lt;"which should be equal to the multiplier (which is: "&lt;&lt;multiplier&lt;&lt;")"&lt;&lt;endl;

  cout&lt;&lt;"the time to assign N: "&lt;&lt;elapsed_time_storing_N&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to declare vector of N with doubles data type : "&lt;&lt;elapsed_time_1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to assign vector: "&lt;&lt;elapsed_time_assigning_values&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to find magnitude of vector_in: "&lt;&lt;elapsed_time_mag1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to modify the vector_in: "&lt;&lt;elapsed_time_modify_mag&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to calculate magnitude of modified vector_in: "&lt;&lt;elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;" The total time shall be :"&lt;&lt;elapsed_time_1+elapsed_time_assigning_values+elapsed_time_mag1+elapsed_time_modify_mag+elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;
  delete[] vec;
  return 0;
}
</pre>

<p>
<span id="The demonstration-Try outs-Code 6:-Output:"></span><strong id="Output:">Output:</strong><br />
```<br />
Value of magnitude before multiplying the vector is 57455839005566  <br />
Value of magnitude after multiplying the vector is 229823356022263   <br />
the final vector has magnitude 4 times the earlier one<br />
which should be equal to the multiplier (which is: 4)<br />
the time to assign N: 0 seconds<br />
the time to declare vector of N with doubles data type : 9e-06 seconds<br />
the time to assign vector: 7.3436 seconds<br />
the time to find magnitude of vector_in: 5.81952 seconds<br />
the time to modify the vector_in: 4.70668 seconds<br />
the time to calculate magnitude of modified vector_in: 5.79976 seconds<br />
 The total time shall be :23.6696 seconds<br />
</p>

<p>
real	0m23.983s<br />
user	0m20.541s<br />
sys	0m3.373s<br />
```<br />
</p>

<p>
Remarks: I totaly forgot the answer I am printing is wrong. <br />
</p>

<div id="The demonstration-Try outs-Code 7"><h3 id="Code 7" class="header"><a href="#The demonstration-Try outs-Code 7">Code 7</a></h3></div>
<p>
I am trying to increase the size of array, I tried with long int, long long int, to store bigger numbers than what int or unsigned int can store. It did not work untill I found the data type 'uint64_t', which worked fine. <br />
</p>

<p>
Here is the code .<br />
</p>
<pre cpp>
/******************************************************************************
* File:             code7.cpp
* Author:           Vishal  
* Created:          01/30/24 
* Description:      This code is supposed to do vector modification for cpu for very large size array of size 2^34
*****************************************************************************/

//This program is intended to demonstrate simple serial programming where a vectors element gets modified serially. 
//
#include &lt;cstdint&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;chrono&gt;

using std::cout;
using std::endl;

void increase_magnitude(float *starting_address,uint64_t  size_vec, float mag_multiplyer)
{
  //the variable *starting_address is a pointer which will point to (or contain address of), the first element of the array.
  for (uint64_t i=0;i&lt;size_vec;i++) //2 instructions per loop for updating i, and checking i&lt;size  
  {
    //let us multiply the whole vector by 2
    //since we have address of first element of vector, we can take its value by use of *
    *starting_address=*starting_address * mag_multiplyer; //4 instructions
    //now we shall increase its address by 1.
    starting_address+=1; //2 instructions (add sum, and update sum)

  } 
  //in total loop shall have 8 instructions per loop, so time taken shall be (size/clockspeed)*instructions per loop

  //in this way at the same memory location we will have modified the vector.

}

long double magnitude_finder(float *starting_address_vec,uint64_t size)
{
  //This function will return the magnitude of the vector. 
  long double sum=0.0;
  for (uint64_t i=0;i&lt;size;i++) //2 instructions per loop for updating i, and checking i&lt;size
  {
    /* sum+=pow((*starting_address_vec),2); //power function is slow (10 times)*/
    sum+=(*starting_address_vec)*(*starting_address_vec); //5 instructions
    starting_address_vec+=1; //2 instructions
  }
  //9 instructions per loop
 return pow(sum,0.5); 
}

long double sum(float *starting_address_vec,uint64_t size)
{
  //This function will return the magnitude of the vector. 
  long double sum=0.0;
  for (uint64_t i=0;i&lt;size;i++) //2 instructions per loop for updating i, and checking i&lt;size
  {
    /* sum+=pow((*starting_address_vec),2); //power function is slow (10 times)*/
    sum+=(*starting_address_vec); //5 instructions
    starting_address_vec+=1; //2 instructions
  }
  //9 instructions per loop
 return sum;
}

int main(int argc, char *argv[])
{
  auto time_0 = std::chrono::high_resolution_clock::now();
  uint64_t N=1L&lt;&lt;34; //1L denotes long data type of 1.
  auto time_1 = std::chrono::high_resolution_clock::now();
  float *vec=new float[N]; //dynamics_array allocation does not take any time comparable to stack memory 

  //let us fill the vector with N natural numbers(1,2,.......N).
  auto time_2 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_2 - time_1).count() / 1e6;
  auto elapsed_time_storing_N = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_1 - time_1).count() / 1e6;
  for (uint64_t i=0;i&lt;N;i++)
  {
    vec[i]=i+1;
  }
  auto time_3 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_assigning_values = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_3 - time_2).count() / 1e6;
  /* cout&lt;&lt;vec[0]&lt;&lt;vec[1]&lt;&lt;vec[2]&lt;&lt;vec[3]&lt;&lt;endl; */

  //let us define a pointer to integer vector
  float *ptr_to_vec=&amp;vec[0]; //giving address of first element. Or we can just write: 

  //we shall modify the vector by multiply it with some real number. 
  //Real numbers are stored in float data types(require 4byte per real number) and double data types(8bytes).
  float multiplier=4.476;

  //Let us find the magnitude before changing the vector, 

  long double mag_before=sum(ptr_to_vec,N);
  auto time_4 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag1 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_4 - time_3).count() / 1e6;



  increase_magnitude(ptr_to_vec,N,multiplier);
  auto time_5 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_modify_mag = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_5 - time_4).count() / 1e6;


  long double mag_after=sum(ptr_to_vec,N);
  auto time_6 = std::chrono::high_resolution_clock::now();
  auto elapsed_time_mag2 = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(time_6 - time_5).count() / 1e6;

  long double ratio_of_magnitudes=mag_after/mag_before;

  printf("Value of sum before multiplying the vector is %Lf  \n",mag_before);
  printf("Value of sum after multiplying the vector is %Lf   \n",mag_after);
  cout&lt;&lt;"the final vector has sum "&lt;&lt;ratio_of_magnitudes&lt;&lt;" times the earlier one"&lt;&lt;endl&lt;&lt;"which should be equal to the multiplier (which is: "&lt;&lt;multiplier&lt;&lt;")"&lt;&lt;endl;

  cout&lt;&lt;"the time to assign N: "&lt;&lt;elapsed_time_storing_N&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to declare vector of N with doubles data type : "&lt;&lt;elapsed_time_1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to assign vector: "&lt;&lt;elapsed_time_assigning_values&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to find sum of vector_in: "&lt;&lt;elapsed_time_mag1&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to modify the vector_in: "&lt;&lt;elapsed_time_modify_mag&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;"the time to calculate sum of modified vector_in: "&lt;&lt;elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;
  cout&lt;&lt;" The total time shall be :"&lt;&lt;elapsed_time_1+elapsed_time_assigning_values+elapsed_time_mag1+elapsed_time_modify_mag+elapsed_time_mag2&lt;&lt;" seconds"&lt;&lt;endl;
  delete[] vec;
  return 0;
}
</pre>

<p>
<span id="The demonstration-Try outs-Code 7-Output:"></span><strong id="Output:">Output:</strong><br />
```<br />
Value of sum before multiplying the vector is 147573952598266347520.000000  <br />
Value of sum after multiplying the vector is 660540987060031083840.000000   <br />
the final vector has sum 4.476 times the earlier one<br />
which should be equal to the multiplier (which is: 4.476)<br />
the time to assign N: 0 seconds<br />
the time to declare vector of N with doubles data type : 1e-05 seconds<br />
the time to assign vector: 62.9423 seconds<br />
the time to find sum of vector_in: 94.2152 seconds<br />
the time to modify the vector_in: 40.244 seconds<br />
the time to calculate sum of modified vector_in: 63.339 seconds<br />
 The total time shall be :260.741 seconds<br />
</p>

<p>
real	4m22.348s<br />
user	3m27.879s<br />
sys	0m53.909s<br />
</p>

<p>
```<br />
</p>

    </div>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script type="text/javascript">
        document.querySelectorAll('pre').forEach(block => hljs.highlightBlock(block));
    </script>
</body>
</html>

