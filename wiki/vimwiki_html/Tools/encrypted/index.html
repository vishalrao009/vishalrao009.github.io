<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f04372970b2dc9798be8b69a387830e4d5f3542932dafe1b6d8b3c7ea4d1f3c50ca18fcef56bdbf513e149ccf62c58b50d50def0ae9f9a1532661307fc18c0b201b565efb9cc1d3ebc767de8c13ac2a13177686d8d5bcf9323ac5e14750e3366f8409bfaba3ebc154ea37818f223df984b2d22a0254417c45b9f740d713210223ac9b680974bf2eccf9d75bf280e7ebaecb4bb693941716f580fa850053a66d4daa7a3e7053bd9aae838a315592e43a1221ff761f4c479583d5cac8bf9f2857ba1489f5a005b3317c39c56c8a138fbd8e93c2eecbcecef7339a312390fdaa11c52b3eb6673832f8b0fea09cb947f8eade4e0d9248af7279d0d8e0b3590780e1bae278015b5634b56e43ca559f1068e1c40c0ecd5e1320f3aba34f8931c88e6a0fc8094a3354cad306f910fa569247d850a2a92bacfa168b3906a60a9dfd255bac20fd51499ed89af80101f5a69fd04cdbb5625bbdd15d0eaf40702ba8f100b9f1c4e7dab47a4a7dcc2efe24b8e8500910449ee6e7da3d36c7210352c182d177c2408d20650d4c15a951865c85659acc138249c5a4dac528c3687638ffb1843c023d18ec7d64a13f776deee760d0b4871e7a051be81fa25182f66dca68d6caa89e181fa216275000a339c873dc6b350ac3945ecf69f8287625f46da2fa5d7bfa29d1fa546bb8ff1e988506d58c7935d7d34ac83d0cca0263d63c45ed1dac9498c3126099cfbc1a9c1682b69e10a5281a451bc351003e38921c04d4c4224aa7bef5c3c767de5443068631d3c8fc7c580bab4d360bdf9eab388e1f8ffa64b0c36b68e307eb00faa9c1afdb5c748dadce4e86389dbbaaff72b8dfeead9f32a3cee20b1fd2b292fee4d1285f621ad1421f0b6bde5fddd1112dac236e5c791da453a1477b04c29ac5fd4c23c2011e54750b18893e3c73b6c85c841f5b14a571df8fc8c986cdd450642f2b10867412fc8fbb7dcd2c1f7850b177f875bb671f4c163f43f25842c54200c8da6774b40aa822902dae17046be12835550aae45d804046359a3b073ea414550cc4d6660c25c0e29a7ba4c98d50ecdf238d8ca5c60d13f39351d401b10dd12c73b9054f6612af6348d04bc22b8805b30ee6558eaa819a90b55c82ee7a82e927cde99c2b008cc9ef3347ee642d162929ad57012a1e5383879b3022d6d989723e8aee7599e621684d2fae24b9ed421ced459207d3c9c5059f74be5590c16b0966e64ff78d7094d6af9da3545b4518e110b85e91606cb2f3262973447d6c3db8bc5aa21eaae421d916e33e54a3c1dd48cdfb0db7760f50b8d75c1ee4fabbb32c1c9c47ea3b7e7ea08e0ec5690e8dfa7513f1137e86c1adf321bfaf5d29ed8f179a9dcbc82525e9e985057efec1585e36c3b61447583e2efcef8d11b440505f319faea3697000b00a64ad8d198c1d7c9b8970704d4ffa796ebacf2c4f74c864c0879fbe15a3d1b5552ab5538c4f76e883bb89c1bc2b647924ca7e193e97ff13b1639d93dd4d30bc78bb928e5cb6804651d7cde772a51cd9f08747397f22a7ef64e25652de151956f534b244a54bdc860ea900ea798ac7aadf8fb0195a4f8e06a9c8dc1935f37cd312b66cfd91f5f6e096e8ac887b5d244a6392226ef9a6899e64a7ac8df5d03a838e866007afd1665cb10b2ec2cf149f3913eba816f75388ef4a882937e91d1008aa3a294732359cb5e5b7c9f850b6d0d1695c68a82f92405beca5c993ae4cf15d2156e399dcae43a7565140c14d61593040f1a1784def4a55d292376e5337daace31fcc605012bf211e08e374838f19ea1e193c469864be9e5806f9c2c0068937d9060bf75801b61e667dcf434519d6488e28879f2331bfabc9a32616eba162b850aa20b1ee6c48b44ed1519d4ed4ea37e9a23b65e5aa4dab40482bcd4cbf2f9cbc607cbdba4b1232a24801894503620d5e9850a5bb2a9c0c4f770c12af26963cf23d835a3c6cd567e71fc552df4bdf81001fad16d54e1cc861041f5ea4db6bb060e7c3a38958467b2ec3db3b70649b4f7a279073026dfd2ee6f922e073c2d610e703390bca80fb7320c4e7be9ab31948715fe7d47f8a6332c79fe694bbdb9ece698efe65d9b81f8a8c31a4b7b01639af8aad79e320da0982420cca78713644e5a971a0d951e5bd3909aaa86ea53a0a6983cbcc9ffa1796fc7605eab2434b4c1f9f4701ed3f84a1a252efd59b22181605499391fe5cd9ef352e3fb0023422632aab39df53c39428d2075525e8678d86c1e6e5e904472328a541de94e9c32da1ea37f79c441217b0fde2d169da7686fc801e9a856b5359b64ad73860f00abcc4d90153d53010b083cc4646a83e5bb44e2103eda5d6142b4854533a0d7d36e78d5f196993edec7751008e6ace5caf29695da18cb430a5c64bf537a06a0c5554bbafcdd05546a4b21dbafee616a0f7ee2b28ce58349c3f6b52e85f662a7b62f567f1c3c2916724a1128ce32ea755a7d245a0422ce9da270a29923970e4c01da6d43d00fba2c4c6641eba1edb8859012a465cf83fe44d96377b3d006c36be4088adf1e440693480282e9b6151f7480dcf95df39e5173696cd37de3748fd25bf8fe395b2cf5c616ad04306b61844e7f22d267aeaa49257a4d1022236dfce214be8df230d567818ae93832c511bf4e707d895a5e0921908d310b0fecc7a5225caa16c8b2d8791eba7ddce9999785a3572eed7b93255e8db44e5a6ecde84ae48be991f300c39379081bd980e47b3083384a026166721454e1627c40bdf7074870adf2f076dabfb48716dfa169fdb0c261d57c4d07e9baa661c89233b33afdb5b74892314885a51c85dd812fcc04bd753e64e3a97b3f838408b8c559fa037e328eff6bc7142c0d4aeea15b55e5cd49453f4460cb17a3d9345885f1be4abd292a879d6199b5511de910c18559977ffc8e5e3f42b054552993a38be87e0b7be0d46f8bcba89f1c2d310ca6e9b6ac04779c6d7cc3951da06ea129926a5ba8c3923e135c152c049933ae825577b5e39a53579d0ecb87adc566ba03ff9c77291208bece0c2e63e1e657b998aa7d032ec5aa94a5c3a5173839769ef0ffa98aa8428d2acd8f97209caf5280629051d4818b30e58ad17273e95439ffcc334e61c4f130e69b1bd880eaee913dae194d55d3c4000aae7a4e76a400c59790fbb1d3b97b29f363306d498fc4317d677ea0133d062cd71ec65aa69d77c4bbb710b4cdaa15cc17a7152911207eb8d35ccfba7a106ccb419bf09c1b190d4c6d4e2a485deb3a402e93348dc8e5cc1b7bc12fffd2ac125e161c48dd8a3a894f1290e7e10415d8b155ae9ba45614ff2092e1c8a9f5ea8e83483b2b23ebb7764f91e43fe3edf20b9e835eac9517ebb16f1ea171a6c763eebf5e683c92b55784283c0e9fcbcbaf74d15f2b2cec49d2f1d460c609605f76dcaa29a6d80630f7f7b7bbc5ba66d4ae2660e9f10e0b59228f2062d4ffbfe336dd061670fb855d5cc704ec3bf97d7443e80492372df40f8b39f0f90ed74c2ca68b760950bb551c15ffa4e410985aa52c83629265e2c4f40b15f9ab11d1fa1bfe901dec6c0409e942722b29b490768aceb0102a920da98ea7f7bdfbee2d57a4d93d973b1bb25a8c4323e261c75b78b90c41af970052abf674ffe054d7226ffafb65b076a1380bca4a48970c64c4bdef56d97dfa2f39604bec0539af7c09f05ccdbad620820a3419d575637feaa7c77a366b01a1d8cc94de55cb589bf9650314722b28af58efd6c8c7736e07129d79b8993168a9c1744f5b255949274949bfe4e85a1d6b6a22b3fc80f200d1c85ba6b54ce2b1c135b73099bebdeb46d33ce6462c0ef3521a01a746ed556d15719135e536e9f0284234f536938144d8db443661b1a47a3225a5f3031a46a0b558c36a5a3ee24df007578d5ae7c45eee5299e4426ba50d457d61ae020629e7ae8f6d92ce8124bb74d961a671146a714538634ae544477ce34ee83da79583f2863f569b4bd2b420fdf87ce87417899f98e0d49f554117059e5cf058853b0a51d370f0cb1175e4785e7d8ec5a1f012cfb38c06ec7f37a4cee0698a7d315eee3cdf5b4a9c1c32dd81c7a174e1dc828c27cf73d577518842387926f44e93a0b29c9df84ce19c11a7dd6002b96e5bce6648c1978565163e9830215dd48a806ca084153616e866bd0503569d50228e2edbe54be3a93f198ab5bf54c73e76307ec94adee9e9be3cb1985e52aa3ed7601d25c996c65ace612a1e2935e2ebf9db724bfb4bcbf5b89ff4f5e5d267ec35ccf3bf1b884c24a3ec4375193823199f8286a035425ac647324d7866bf33a4be42945dc14b464522ddf06cc28447f49ddc4ffad2f5ced5951070513c9dd54166e5214a1fd4ccd559afb2aa2c6512c1607dd4a861c18da20799b96a6a3ab1f8739217952803b38f17fe735a44e71c70a12ac4294f674c7199806cabd19590ade89dc4bae7cd96436b93cc46264901cd1bc6e7db6b507a9e97947f7a557c2fde78550e808c817715332517ecbe5303fc4960d0d5915c7c7ffa47f3096b15ab6d62258c38836fcdf121c091e2e7d27ea697319fe0bf7dd03b4a71c7fc3f9f84c8ce7b0fcdd3bc1030c54e83fc60b85786481d5678e2984103ae3fc6e1561d4831b403ebb152701fb75746d7f13d5eb8e855f42d64c055eafff781394fd2d4098496ae5dbff27b5a86fc38869ac1e3efa286b7e51871cd92d365839a225a6f69926d331a5593e3f713a29f0e46bc62ef40c79237c8ed1cf30d3755c0a3c055db67e7b7b109f9520d68291edeeeaa38fed03d30969024b11b246bb076d99f84ddde79d9dd65d300fdcf451063b0649ff659554f0261f96718bb11172946a89d635a5f0b7db2877bd5a2a43538c8c529698b918e337fe09d7aa3a62e79ae9735d88d42972cfe12423506521b3f23b5d264008ecdf77e644f271a8bb6dad7226b7393bc8936050e2283ca9d6674763ae4b948ae277a8bc0b3c72ef5b4ce8f3e956c90998b9f4084d328fb284a353dea5363a40f00421cb7f4c05ec255f570a484f441566535bceb7066b487a4d8008b882efd33a89da299109639c6fc0776a81e7d3265a5635c16ebacfea81459d8b3bf29161e33410cb7a30c439b34490c2c2b04a64167ae8086eab7c6ce811d7d5f5a703bbe4d7262493dc776491b8529b7b560f82f76208da66a9b3976b927a7970bdca2363f1162b478576bf48a3071ab9d0bc6469cb3b05ac5d27336dd12d98b67da1ee2e0cc6d953d1203fb5005a5a929cb299d402833f5e48653ce65dabf90f35fab3b14edb5995a8f532feb1f93f4d29b3185387087154f7d057c34bb04b2bd56df52fa9c6d1c842","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"b90bc29a6e87fd886a263b088815e55b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
