<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css" />
    <title>Data Structures in c++</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> 
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        body {
            background-image: url('../Images/parchment.jpg');
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            margin: 0;
            font-family: Arial, sans-serif;
            padding: 3cm;
        }

        #content {
            color: #333;
            font-size: 20px;
            line-height: 1.6;
            max-width: 1200px;
            margin: 0 auto;
            padding: 10px;
            background-color: rgba(255, 255, 255, 0.5);
        }

        h1 {
            font-size: 28px;
        }

        h2 {
            font-size: 24px;
        }

        h3 {
            font-size: 20px;
        }

        h4, h5, h6 {
            font-size: 18px;
        }

        img {
            display: block;
            max-width: 100%;
            max-height: 500px;
            margin: 30px auto;
        }

        /* Mobile Styles */
        @media only screen and (max-width: 600px) {
            body {
                padding: 1cm;
            }

            #content {
                padding: 10px;
                max-width: 100%;
            }
        }

        /* Link Preview Styles */
        .link-preview {
            display: none;
            position: absolute;
            background-color: white;
            border: 1px solid #ccc;
            padding: 10px;
            width: 300px;
            z-index: 100;
            box-shadow: 0px 4px 8px rgba(0, 0, 0, 0.2);
        }

        a {
            position: relative;
        }

        a:hover .link-preview {
            display: block;
        }

    </style>
</head>
<body>
    <div id="content">
        <!-- Example link without preloaded preview -->
        <a href="article1.html" class="link">Article 1</a>
        <div class="link-preview"></div>

        <a href="article2.html" class="link">Article 2</a>
        <div class="link-preview"></div>

        
<div id="Contents" class="toc"><h1 id="Contents" class="header"><a href="#Contents">Contents</a></h1></div>
<ul>
<li>
<a href="Data Structures in c++.html#References">#References</a>

<li>
<a href="Data Structures in c++.html#Introduction">#Introduction</a>

<ul>
<li>
<a href="Data Structures in c++.html#Structures">#Structures</a>

<ul>
<li>
<a href="Data Structures in c++.html#Example1 (without multiple files)">#Example1 (without multiple files)</a>

</ul>
<li>
<a href="Data Structures in c++.html#Classes">#Classes</a>

<ul>
<li>
<a href="Data Structures in c++.html#Example">#Example</a>

<li>
<a href="Data Structures in c++.html#Constructor and Destructor">#Constructor and Destructor</a>

<ul>
<li>
<a href="Data Structures in c++.html#Constructors">#Constructors</a>

<ul>
<li>
<a href="Data Structures in c++.html#Default Constructor">#Default Constructor</a>

<li>
<a href="Data Structures in c++.html#Custom Constructor">#Custom Constructor</a>

<li>
<a href="Data Structures in c++.html#Remarks (this-&gt; pointer)">#Remarks (this-&gt; pointer)</a>

</ul>
<li>
<a href="Data Structures in c++.html#Destructor">#Destructor</a>

</ul>
<li>
<a href="Data Structures in c++.html#Working with Objects">#Working with Objects</a>

<li>
<a href="Data Structures in c++.html#Encapsulation">#Encapsulation</a>

<ul>
<li>
<a href="Data Structures in c++.html#Getters And Setters">#Getters And Setters</a>

</ul>
<li>
<a href="Data Structures in c++.html#Static Data Members">#Static Data Members</a>

<li>
<a href="Data Structures in c++.html#Operator Overloading">#Operator Overloading</a>

<ul>
<li>
<a href="Data Structures in c++.html#Example1 addition operator (defining inside class)">#Example1 addition operator (defining inside class)</a>

<li>
<a href="Data Structures in c++.html#Example2 Comparison Operator{==} (defining outside the class)">#Example2 Comparison Operator{==} (defining outside the class)</a>

<li>
<a href="Data Structures in c++.html#Example 3 Insertion(&gt;&gt;) and Extraction(&lt;&lt;) operator">#Example 3 Insertion(&gt;&gt;) and Extraction(&lt;&lt;) operator</a>

</ul>
<li>
<a href="Data Structures in c++.html#Friend functions to access private Members">#Friend functions to access private Members</a>

<ul>
<li>
<a href="Data Structures in c++.html#Example (without overloading)">#Example (without overloading)</a>

<li>
<a href="Data Structures in c++.html#Example (with overloading)">#Example (with overloading)</a>

</ul>
<li>
<a href="Data Structures in c++.html#Classes Across Multiple Program files">#Classes Across Multiple Program files</a>

<ul>
<li>
<a href="Data Structures in c++.html#Defining header file: classes.h">#Defining header file: classes.h</a>

<li>
<a href="Data Structures in c++.html#Defining all functions">#Defining all functions</a>

<li>
<a href="Data Structures in c++.html#Using headerfile.h and the definition_file.cpp">#Using headerfile.h and the definition_file.cpp</a>

</ul>
<li>
<a href="Data Structures in c++.html#Inheritance">#Inheritance</a>

<ul>
<li>
<a href="Data Structures in c++.html#Example1 (without header files)">#Example1 (without header files)</a>

<li>
<a href="Data Structures in c++.html#Example2 (with header files)">#Example2 (with header files)</a>

</ul>
<li>
<a href="Data Structures in c++.html#Polymorphism">#Polymorphism</a>

<ul>
<li>
<a href="Data Structures in c++.html#Example (virtual functions):">#Example (virtual functions):</a>

</ul>
</ul>
</ul>
</ul>
<div id="References"><h1 id="References" class="header"><a href="#References">References</a></h1></div>
<p>
<a href="https://www.youtube.com/watch?v=_bYFu9mBnr4&amp;list=PL_c9BZzLwBRJ55lLw8PdPlTVblIlPKfX5">Celeb curry cpp</a><br />
</p>



<div id="Introduction"><h1 id="Introduction" class="header"><a href="#Introduction">Introduction</a></h1></div>

<p>
In C++ classes and structures are essentially the same thing. They both are going to create an object. The difference is conventional, they can be both used to do same task, but people choose structures to handle smaller data sets. The major difference lies in default access modifiers (public, private, protected(only be used in inheritance)). For structures the default access modifier for members or methods are public and for classes the default access modifiers is private.  <br />
</p>

<p>
Both structures and classes can have instances(objects),constructors and methods to access variables, they both pass by value. Structures are used for small data structures and classes are used to handle large data structures. <br />
</p>

<p>
Variables, methods, and constructors are termed as members of classes or structures. <br />
</p>


<div id="Introduction-Structures"><h2 id="Structures" class="header"><a href="#Introduction-Structures">Structures</a></h2></div>

<ol>
<li>
Used for smaller data. 

<li>
Private Members can be accessed only within the body of structure definition, whereas public members are accessed by objects / or outside the definition of structures. 

<li>
Structures members are by default <code>Public</code>. 

</ol>
<div id="Introduction-Structures-Example1 (without multiple files)"><h3 id="Example1 (without multiple files)" class="header"><a href="#Introduction-Structures-Example1 (without multiple files)">Example1 (without multiple files)</a></h3></div>

<pre cpp>
#include&lt;iostream&gt;

	struct person{
	std::string name;
	std::string job;
	int age;
	float salary;
	float get_bank_info()
	{
		return Bank_balance;
	}
	private:
		float Bank_balance=15000;
	};

	int main()
	{
	person me;
	me.age=28;
	me.name="vishal rao";
	me.job="Phd Student";
	me.salary=37000;
	std::cout&lt;&lt;"my age is "&lt;&lt;me.age&lt;&lt;std::endl;
	std::cout&lt;&lt;"bank balance is :"&lt;&lt;me.Bank_balance&lt;&lt;std::endl; //will generate error as we can't access private members of object me, which is instance of structure 'person'
	std::cout&lt;&lt;"bank info is :"&lt;&lt;me.get_bank_info();

	return 0;
	}


</pre>


<div id="Introduction-Classes"><h2 id="Classes" class="header"><a href="#Introduction-Classes">Classes</a></h2></div>

<ul>
<li>
Used to handle complex tasks, data sets. We can even use structures rather than classes, but conventional approach is to use classes for complex data structure. 

<li>
By default members of classes are Private. 

</ul>
<div id="Introduction-Classes-Example"><h3 id="Example" class="header"><a href="#Introduction-Classes-Example">Example</a></h3></div>

<pre cpp>

#include&lt;iostream&gt;

	class person{
	float Bank_balance=15000;
	public:
		std::string name;
		std::string job;
		int age;
		float salary;
		float get_bank_info()
		{
			return Bank_balance;
		}
	};

	int main()
	{
	person me;
	me.age=28;
	me.name="vishal rao";
	me.job="Phd Student";
	me.salary=37000;
	std::cout&lt;&lt;"my age is "&lt;&lt;me.age&lt;&lt;std::endl;
	/* std::cout&lt;&lt;"bank balance is :"&lt;&lt;me.Bank_balance&lt;&lt;std::end; //will generate error as we can't access private members of object me, which is instance of structure 'person' */
	std::cout&lt;&lt;"bank info is :"&lt;&lt;me.get_bank_info()&lt;&lt;std::endl;

	return 0;
	}
</pre>

<div id="Introduction-Classes-Constructor and Destructor"><h3 id="Constructor and Destructor" class="header"><a href="#Introduction-Classes-Constructor and Destructor">Constructor and Destructor</a></h3></div>
<div id="Introduction-Classes-Constructor and Destructor-Constructors"><h4 id="Constructors" class="header"><a href="#Introduction-Classes-Constructor and Destructor-Constructors">Constructors</a></h4></div>
<ul>
<li>
Constructors are used to quickly create instances of classes. It is special method of class, which can be used to create instance quickly. <u>These are methods with same name as of class name but with no return type</u>. Example:

<li>
Constructors allows us to initialise objects with particular values.

<li>
<u>constructors are not members of class, these are special functions/methods to create or initialise the object. Note that constructor is never inherited by child classes.</u>

</ul>
<div id="Introduction-Classes-Constructor and Destructor-Constructors-Default Constructor"><h5 id="Default Constructor" class="header"><a href="#Introduction-Classes-Constructor and Destructor-Constructors-Default Constructor">Default Constructor</a></h5></div>
<ul>
<li>
Default constructor is created implicitly if not defined inside the definition of class. Provided that implicitly defined constructor uses absolutely bare minimum required to crate a user. Example: when we don't define any constructor and crate instance of class <code>person</code> by using : person p1; then the default implicit constructor person(){ //nothing } will be called. 

<li>
Default constructor / implicit constructor is only available if we don't define any custom constructor.

<li>
If we need default constructor provided we have declared custom constructor then we have to define it explicitly along with custom constructor. Example: <code>classname(){//this is explicitly defined default constructor}</code>

</ul>
<div id="Introduction-Classes-Constructor and Destructor-Constructors-Custom Constructor"><h5 id="Custom Constructor" class="header"><a href="#Introduction-Classes-Constructor and Destructor-Constructors-Custom Constructor">Custom Constructor</a></h5></div>
<ul>
<li>
These constructors uses parameters in definition of constructor. Example: 
<pre cpp>
class person(){
	float Bank_balance=15000;
	public:
		string name;
		string job;
		int age;
		float salary;
		float get_bank_info()
		{
			return Bank_balance;
		}
//Below is example of custom constructor which is mostly used.
person(string name, string job_name,int age_user, float salary_user ){
		cout&lt;&lt;"a custom constructor is called since an object is created using custom constructor\n";
		this-&gt;name=name;           // or we can just use name=name
		this-&gt;job=job_name;       // or job=job_name;
		this-&gt;age=age_user;       // or age=age_user;
		this-&gt;salary=salary_user;
		}
		};
</pre>

</ul>
<div id="Introduction-Classes-Constructor and Destructor-Constructors-Remarks (this-&gt; pointer)"><h5 id="Remarks (this-&gt; pointer)" class="header"><a href="#Introduction-Classes-Constructor and Destructor-Constructors-Remarks (this-&gt; pointer)">Remarks (this-&gt; pointer)</a></h5></div>
<ul>
<li>
Note that we are using this-&gt; pointer here, which is useful when we use same name of parameters to that of members of class. Above we are not using the same name, so we can just write : this-&gt;name=name; job=job_name; age=age_user; salary=salary_user;

</ul>
<div id="Introduction-Classes-Constructor and Destructor-Destructor"><h4 id="Destructor" class="header"><a href="#Introduction-Classes-Constructor and Destructor-Destructor">Destructor</a></h4></div>
<ul>
<li>
We don't need to define custom/default Destructors, as they destroy the object created and it happens automatically, we can also define Destructor explicitly using <code>~</code> prefix before name of destructor which have same name to that of class. Example: <code>~ class_name(){cout&lt;&lt;"an object is destroyed\n"}</code>
<pre cpp>

#include&lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;
using std::string;

	class person{
	float Bank_balance=15000;
	public:
		string name;
		string job;
		int age;
		float salary;
		float get_bank_info()
		{
			return Bank_balance;
		}
		person(string name, string job_name,int age_user, float salary_user ){
		cout&lt;&lt;"a custom constructor is called since an object is created using custom constructor\n";
		this-&gt;name=name;           // or we can just use name=name
		this-&gt;job=job_name;       // or job=job_name;
		this-&gt;age=age_user;       // or age=age_user;
		this-&gt;salary=salary_user;
		}
		
		//Since we have created our custom constructor(custom constructor takes parameters), we need to create default constructor with no parameters, since it will not be created by compiler once we have created custom constructor.
		person(){cout&lt;&lt;"a default constructor is called since an object is created with default constructor\n"}
		~person(){cout&lt;&lt;"object is destroyed using this destructor \n";} //unnecessary as it is automatically / implicitly created by compiler.

	};

	int main()
	{
	//person me; will not work as implicit constructor is only there if we don't define any constructor.
	person me("vishal rao","jrf",28,37000); 
	cout&lt;&lt;"my age is "&lt;&lt;me.age&lt;&lt;endl;
	/* std::cout&lt;&lt;"bank balance is :"&lt;&lt;me.Bank_balance&lt;&lt;std::end; //will generate error as we can't access private members of object me, which is instance of structure 'person' */
	cout&lt;&lt;"bank info is :"&lt;&lt;me.get_bank_info()&lt;&lt;endl;
	person p1("naresh rao","software engineer",29,120000);
	cout&lt;&lt;p1.age&lt;&lt;endl;
	person yogesh;
	yogesh.name="Yogesh";
	yogesh.age=23;
	cout&lt;&lt;"name of yogesh is "&lt;&lt;yogesh.name&lt;&lt;endl;
	cout&lt;&lt;"age of yogesh is "&lt;&lt;yogesh.age&lt;&lt;endl;
	return 0;
	}
</pre>

</ul>
<div id="Introduction-Classes-Working with Objects"><h3 id="Working with Objects" class="header"><a href="#Introduction-Classes-Working with Objects">Working with Objects</a></h3></div>

<ul>
<li>
Once we have crated objects, let us see what we can do with them. 
<pre cpp>
#include&lt;iostream&gt;
#include&lt;vector&gt;
using std::cout;
using std::endl;
using std::string;
using std::vector;

	class person{
	float Bank_balance=15000;
	public:
		string name;
		string job;
		int age;
		float salary;
		float get_bank_info()
		{
			return Bank_balance;
		}
		person(string name_user, string job_name,int age_user, float salary_user ){
		cout&lt;&lt;"a custom constructor is called since an object is created using custom constructor\n";
		this-&gt;name=name_user;           // or we can just use name=name_user
		this-&gt;job=job_name;       // or job=job_name;
		this-&gt;age=age_user;       // or age=age_user;
		this-&gt;salary=salary_user;
		}
		
		//Since we have created our custom constructor(custom constructor takes parameters), we need to create default constructor with no parameters, since it will not be created by compiler once we have created custom constructor.
		person(){cout&lt;&lt;"a default constructor is called since an object is created with default constructor\n";}
		~person(){cout&lt;&lt;"object is destroyed using this destructor \n";} //unnecessary as it is automatically / implicitly created by compiler.

	};
	void add_to_vector_object_if_not_exit(vector &lt;person&gt; &amp;VectorObject, person obj)
	{
		//this function will return the index of VectorObject each time it finds the match with previous records, and will also return the new position of newly added vector if new object to be added is new. 
		bool found=false;
		for(int i=0;i&lt;VectorObject.size();i++)
		{
			if (VectorObject[i].name==obj.name &amp;&amp; VectorObject[i].age==obj.age){
			cout&lt;&lt;"object already exist at location"&lt;&lt;i&lt;&lt;endl;
			found=true;
			break;
			}}
		if (!found){
		VectorObject.push_back(obj);
		cout&lt;&lt;"the new object is added to the position"&lt;&lt;VectorObject.size()-1&lt;&lt;endl;
		}

		
	}
	int main()
	{
	//person me; will not work as implicit constructor is only there if we don't define any constructor.
	person vishal("vishal rao","jrf",28,37000); 
	person naresh("naresh rao","software engineer",29,120000);
	person yogesh("Yogesh rao","student",22,0);
	vector&lt;person&gt; VectorObject;
	VectorObject.push_back(vishal);
	VectorObject.push_back(naresh);
	VectorObject.push_back(yogesh);
	// we can now access the values of this vector using array.
	cout&lt;&lt;"the name of first object is "&lt;&lt;VectorObject[0].name&lt;&lt;endl;
	cout&lt;&lt;"the name of second object is "&lt;&lt;VectorObject[1].name&lt;&lt;endl;
	cout&lt;&lt;"the name of third object is "&lt;&lt;VectorObject[2].name&lt;&lt;endl;
	person vishal1("vishal","jrf",28,37000);
	add_to_vector_object_if_not_exit(VectorObject,  vishal1);
	return 0;
}

</pre>

</ul>
<div id="Introduction-Classes-Encapsulation"><h3 id="Encapsulation" class="header"><a href="#Introduction-Classes-Encapsulation">Encapsulation</a></h3></div>

<ul>
<li>
Data Encapsulation is the way of making the class user friendly and let the user have only the necessary tools / info to interact with class and not the whole class definition. 

<li>
It is similar to how much knowledge a driver of car requires to drive a car (starring wheel, gear, brakes, clutch, brake and accelerator), a driver does not need to know inner workings of engine and other stuff. 

</ul>
<p>
<span id="Introduction-Classes-Encapsulation-There are two ways to achieve Encapsulation: 1. Access Modifiers and 2. Getters and setters"></span><strong id="There are two ways to achieve Encapsulation: 1. Access Modifiers and 2. Getters and setters">There are two ways to achieve Encapsulation: 1. Access Modifiers and 2. Getters and setters</strong><br />
</p>

<ul>
<li>
With use of Access modifiers (public, private and protected) we can achieve Encapsulation. Where as getters and setters are methods to interact with private or protected members of class. 

</ul>
<div id="Introduction-Classes-Encapsulation-Getters And Setters"><h4 id="Getters And Setters" class="header"><a href="#Introduction-Classes-Encapsulation-Getters And Setters">Getters And Setters</a></h4></div>
<ul>
<li>
The Getters methods are to access the private/protected members of class. We can print them or access them. 

<li>
Setters are methods to set the private / protected members to some value. 

<li>
In order to access these methods(Getters and Setters) we need to declare them  <code>public</code>.

<li>
Within these functions we can add more layers of functionality to make it user friendly.

</ul>
<p>
Example:<br />
In Below program the function get_bank_balance(getter) and set_bank_balance(is setter)<br />
</p>
<pre cpp>
#include&lt;iostream&gt;
using std::cout;
using std::endl;
using std::string;

	class person{
	float Bank_balance=15000;
	public:
		string name;
		string job;
		int age;
		float salary;
		float get_bank_balance()
		{
			return Bank_balance;
		}
		void set_bank_balance(float balance)
		{
		if (balance&gt;=200000){
			cout&lt;&lt;"have you forgot to pay the mess+hostel+fee"&lt;&lt;endl;
			Bank_balance=balance;}
		else:
			Bank_balance=balance;
		}
		person(string name_user, string job_name,int age_user, float salary_user ){
		cout&lt;&lt;"a custom constructor is called since an object is created using custom constructor\n";
		this-&gt;name=name_user;           // or we can just use name=name_user
		this-&gt;job=job_name;       // or job=job_name;
		this-&gt;age=age_user;       // or age=age_user;
		this-&gt;salary=salary_user;
		}
		
		person(){cout&lt;&lt;"a default constructor is called since an object is created with default constructor\n";}
		~person(){cout&lt;&lt;"object is destroyed using this destructor \n";} //unnecessary as it is automatically / implicitly created by compiler.

	};
	int main()
	{
	//person me; will not work as implicit constructor is only there if we don't define any constructor.
	person vishal("vishal rao","jrf",28,37000); 
	vishal.set_bank_balance(300000);
	cout&lt;&lt;"new bank balance is "&lt;&lt;vishal.get_bank_balance()&lt;&lt;endl;
	return 0;
}

</pre>


<div id="Introduction-Classes-Static Data Members"><h3 id="Static Data Members" class="header"><a href="#Introduction-Classes-Static Data Members">Static Data Members</a></h3></div>

<p>
These data members are specific to class and no instance(object) of class can use them. We can define Static variables, and Static Methods for any class. Example:<br />
</p>


<pre cpp>
#include&lt;iostream&gt;
using std::cout;
using std::endl;
using std::string;

	class person{
	float bank_balance=15000;
	static int user_count;
	public:
		string name;
		string job;
		int age;
		float salary;
		static void get_user_count()
		{
			cout&lt;&lt;"total number of users are:"&lt;&lt;user_count&lt;&lt;endl; //each time an object is created we shall increase the count and each time an object is destroyed we decrease the count.
	//		cout&lt;&lt;age; //will throw some error as we can't use non static member inside static member method
		}
		float get_bank_balance()
		{
			return bank_balance;
		}
		
		person(string name, string job_name,int age_user, float salary_user ){
		cout&lt;&lt;"a custom constructor is called since an object is created using custom constructor\n";
		this-&gt;name=name;           // since both names are same, we need this-&gt; pointer
		job=job_name;       // or job=job_name;
		age=age_user;       // or age=age_user;
		salary=salary_user;
		user_count++;
		}
		
		person(){
		user_count++;
		cout&lt;&lt;"a default constructor is called since an object is created with default constructor\n";}
		~person(){
		user_count--;
		cout&lt;&lt;"object is destroyed using this destructor \n";} //unnecessary as it is automatically / implicitly created by compiler.

	};
	
// we need to initialise the user_count and we can only do that outside the definition of class. (since there can be more users before we implement this program)
int person::user_count=0; 

	int main()
	{
	person user1,user2,user3,user4;
	user1.get_user_count(); 
	person::get_user_count();              //get_user_count is static member, it can't be called from users. 
	user1.~person(); //user1 gets destroyed. 
	person::get_user_count();
	return 0;
}


</pre>



<div id="Introduction-Classes-Operator Overloading"><h3 id="Operator Overloading" class="header"><a href="#Introduction-Classes-Operator Overloading">Operator Overloading</a></h3></div>

<ul>
<li>
We use Operator overloading to redefine the use of Operators, we have so many Operators in c++, example: 

<ol>
<li>
Arithmetic Operators: +, -, x, /, %

<li>
Comparison Operators: ==, &gt;=, &lt;=, &lt;, &gt; 

<li>
Insert and extraction Operators: &gt;&gt;, &lt;&lt;

<li>
and many more

</ol>
<li>
while we create objects of class, and we let us say add the objects, then we need to define / overload the <code>+</code> Operator. 

<li>
Syntax is : <code>return_type operator + (argument with type){}</code> Such operator overloading is defined inside a class, or can be define outside using <code>return_type classname::operator + (argument with type){} </code>

</ul>
<div id="Introduction-Classes-Operator Overloading-Example1 addition operator (defining inside class)"><h4 id="Example1 addition operator (defining inside class)" class="header"><a href="#Introduction-Classes-Operator Overloading-Example1 addition operator (defining inside class)">Example1 addition operator (defining inside class)</a></h4></div>
<pre cpp>
#include&lt;iostream&gt;
using std::endl;
using std::cout;

class position{
	public:
		int x;
		int y;
		position operator+ (position pos){
		position new_position;
		new_position.x=x+pos.x;
		new_position.y=y+pos.y;
		return new_position;
		}
	
};

int main()
{

position a,b;
a.x=10;
a.y=15;
b.x=3;
b.y=5;

//we cant define position c=a+b; as operator + is not defined for such objects of type position(user defined data type)
//we need to define the operator overloading in public access modifier.
position c;
c=a+b;
cout&lt;&lt;"The x coordinates of c is "&lt;&lt;c.x&lt;&lt;" "&lt;&lt;c.y&lt;&lt;endl;
return 0;
}
</pre>

<div id="Introduction-Classes-Operator Overloading-Example2 Comparison Operator{==} (defining outside the class)"><h4 id="Example2 Comparison Operator{==} (defining outside the class)" class="header"><a href="#Introduction-Classes-Operator Overloading-Example2 Comparison Operator{==} (defining outside the class)">Example2 Comparison Operator{==} (defining outside the class)</a></h4></div>
<p>
we first need to declare the operator overloading method inside the class, then only we can define it outside the class.<br />
</p>

<pre cpp>
#include&lt;iostream&gt;
using std::endl;
using std::cout;

class position{
	public:
		int x;
		int y;
		position operator+ (position pos){
		position new_position;
		new_position.x=x+pos.x;
		new_position.y=y+pos.y;
		return new_position;
		}
		bool operator==(position pos);
};

//let us do the operator overloading definition outside the class, since it has been declared inside once. 
bool position::operator ==(position pos){
	if(pos.x==position::x &amp;&amp; pos.y==position::y){
		return true;
	}
	else{
	return false;
	}
}
int main()
{
	position a,b;
	a.x=10;
	a.y=15;
	b.x=3;
	b.y=5;

	//we cant define position c=a+b; as operator + is not defined for such objects of type position(user defined data type)
	//we need to define the operator overloading in public access modifier.
	position c;
	c=a+b;
	cout&lt;&lt;"The x coordinates of c is "&lt;&lt;c.x&lt;&lt;" "&lt;&lt;c.y&lt;&lt;endl;
	if (a==b){
		cout&lt;&lt;"a and b are equal"&lt;&lt;endl;
	}
	else{
		cout&lt;&lt;"a and b are different"&lt;&lt;endl;
	}
return 0;
}
</pre>

<div id="Introduction-Classes-Operator Overloading-Example 3 Insertion(&gt;&gt;) and Extraction(&lt;&lt;) operator"><h4 id="Example 3 Insertion(&gt;&gt;) and Extraction(&lt;&lt;) operator" class="header"><a href="#Introduction-Classes-Operator Overloading-Example 3 Insertion(&gt;&gt;) and Extraction(&lt;&lt;) operator">Example 3 Insertion(&gt;&gt;) and Extraction(&lt;&lt;) operator</a></h4></div>
<pre cpp>

#include&lt;iostream&gt;
using std::endl;
using std::cout;
using std::cin;

class position{
	public:
		int x;
		int y;
		};

//let us do the operator overloading definition outside the class, since it has been declared inside once. 
std::istream&amp; operator &gt;&gt; (std::istream &amp;input, position &amp;pos){
cout&lt;&lt;"enter x coordinates of this position"&lt;&lt;endl;
input&gt;&gt;pos.x;
cout&lt;&lt;"enter y coordinates of this position"&lt;&lt;endl;
input&gt;&gt;pos.y; 
cout&lt;&lt;"Thanks, position has been entered"&lt;&lt;endl;
return input;
}
std::ostream&amp; operator &lt;&lt; (std::ostream &amp;output, position &amp;pos){
output&lt;&lt;"x coordinates:"&lt;&lt;pos.x&lt;&lt;" Y coordinates:"&lt;&lt;pos.y;
return output;
}

int main()
{
	position a,b;
	// we would like to take entries from user and print the positions a and b.
	//cin&gt;&gt;a,b; won't work as cin is object of type std::istream and a is object of type position.we need to define what does &gt;&gt; mean if we like to use this functionality.
	cin&gt;&gt;a; 
	cin&gt;&gt;b;
	cout&lt;&lt;a&lt;&lt;endl;
	cout&lt;&lt;b&lt;&lt;endl;
return 0;
}
</pre>

<div id="Introduction-Classes-Friend functions to access private Members"><h3 id="Friend functions to access private Members" class="header"><a href="#Introduction-Classes-Friend functions to access private Members">Friend functions to access private Members</a></h3></div>

<p>
We can define Friend functions in private member list of class and within definition of friend functions we can use private members. <br />
Note: we can not give any parameters to friend function, we have to provide object of type class as parameter to friend function.<br />
</p>

<div id="Introduction-Classes-Friend functions to access private Members-Example (without overloading)"><h4 id="Example (without overloading)" class="header"><a href="#Introduction-Classes-Friend functions to access private Members-Example (without overloading)">Example (without overloading)</a></h4></div>
<pre cpp>
#include &lt;iostream&gt;
#include &lt;cmath&gt;
using std::cout;
using std::endl;

class position{
	public:
		float x=0;
		float y=0;
		friend float get_position(position pos);
	private:
		float radius(float xcord, float ycord){
		return std::pow((xcord*xcord+ycord*ycord),0.5);
		}
};
float get_position(position pos){
	return pos.radius(pos.x,pos.y); // accessing private member radius() to calculate the radius.
}
int main(){
	position a;
	a.x=3;
	a.y=4;
	cout&lt;&lt;"the distance to origin is  "&lt;&lt;get_position(a)&lt;&lt;endl;
	return 0;
 }
</pre>

<div id="Introduction-Classes-Friend functions to access private Members-Example (with overloading)"><h4 id="Example (with overloading)" class="header"><a href="#Introduction-Classes-Friend functions to access private Members-Example (with overloading)">Example (with overloading)</a></h4></div>
<pre cpp>

#include&lt;iostream&gt;
using std::endl;
using std::cout;
using std::cin;

class position{
	public:
		int x;
		int y;
		friend std::ostream&amp; operator &lt;&lt; (std::ostream &amp;output, position &amp;pos);
	private:
		std::string status="Real";
		};

//let us do the operator overloading definition outside the class, since it has been declared inside once. 
std::istream&amp; operator &gt;&gt; (std::istream &amp;input, position &amp;pos){
cout&lt;&lt;"enter x coordinates of this position"&lt;&lt;endl;
input&gt;&gt;pos.x;
cout&lt;&lt;"enter y coordinates of this position"&lt;&lt;endl;
input&gt;&gt;pos.y; 
cout&lt;&lt;"Thanks, position has been entered"&lt;&lt;endl;
return input;
}
std::ostream&amp; operator &lt;&lt; (std::ostream &amp;output, position &amp;pos){
output&lt;&lt;"x coordinates:"&lt;&lt;pos.x&lt;&lt;" Y coordinates:"&lt;&lt;pos.y&lt;&lt;endl;
output&lt;&lt;"these are "&lt;&lt;pos.status&lt;&lt;endl; //using private member as it is a friend function declared in public access of class.
return output;
}

int main()
{
	position a,b;
	// we would like to take entries from user and print the positions a and b.
	//cin&gt;&gt;a,b; won't work as cin is object of type std::istream and a is object of type position.we need to define what does &gt;&gt; mean if we like to use this functionality.
	cin&gt;&gt;a; 
	cin&gt;&gt;b;
	cout&lt;&lt;a&lt;&lt;endl;
	cout&lt;&lt;b&lt;&lt;endl;
return 0;
}
</pre>

<div id="Introduction-Classes-Classes Across Multiple Program files"><h3 id="Classes Across Multiple Program files" class="header"><a href="#Introduction-Classes-Classes Across Multiple Program files">Classes Across Multiple Program files</a></h3></div>
<p>
What if we have to write a huge program with so many classes, namespaces and functions, it is always better to write the function definitions, in one file(named as program.cpp) and all variables, data structure(class and structures), and functions declaration in separate file(program.h). <br />
</p>

<p>
Steps:<br />
</p>
<ol>
<li>
Move all function, members,data structures in header file and name it "headerfile.h". {we have to make sure that we don't define these variables/members twice, to do that we use 
	`#ifndef HEADERFILE_H
	#define HEADERFILE_H
	//all function definitions
	#endif
	`

<li>
Define all functions (method of class/ methods of structures and any functions) in separate file "program.cpp", inside this file , include header file "headerfile.h".

<li>
Now write a separate program for int main() and include the header file using <code>#include "headerfile.h"</code>

</ol>
<p>
<span id="Introduction-Classes-Classes Across Multiple Program files-Now I am going to do it for above functions and class methods and class members"></span><strong id="Now I am going to do it for above functions and class methods and class members">Now I am going to do it for above functions and class methods and class members</strong><br />
</p>

<div id="Introduction-Classes-Classes Across Multiple Program files-Defining header file: classes.h"><h4 id="Defining header file: classes.h" class="header"><a href="#Introduction-Classes-Classes Across Multiple Program files-Defining header file: classes.h">Defining header file: classes.h</a></h4></div>
<pre cpp>
#ifndef CLASSES_H
#define CLASSES_H

#include&lt;iostream&gt;
#include &lt;ostream&gt;
using std::string;

class person{
	float Bank_balance=15000;
 	public:
		std::string name;
		std::string job;
		int age;
		float salary;
		float get_bank_info();
		person(std::string name, string job_name,int age_user, float salary_user );
		person();
		~person();
};
class position{
	public:
		int x;
		int y;
		position operator+ (position pos);
		bool operator==(position pos);
	
};
std::istream&amp; operator&gt;&gt;(std::istream&amp; input, position pos);
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; output, position pos);
#endif

</pre>
<div id="Introduction-Classes-Classes Across Multiple Program files-Defining all functions"><h4 id="Defining all functions" class="header"><a href="#Introduction-Classes-Classes Across Multiple Program files-Defining all functions">Defining all functions</a></h4></div>
<p>
<code>definition_program.cpp</code><br />
</p>

<pre cpp>
#include &lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;
#include "headerfiles/classes.h"

/* float person::Bank_balance=15000; */
float person::get_bank_info()
		{
			return Bank_balance;
		}
person::person(string name, string job_name,int age_user, float salary_user ){
		cout&lt;&lt;"a custom constructor is called since an object is created using custom constructor\n";
		this-&gt;name=name;
		this-&gt;job=job_name;
		this-&gt;age=age_user;
		this-&gt;salary=salary_user;
		}
person::person(){cout&lt;&lt;"a default constructor is called since an object is created \n";} //defining default constructor as it won't be created by compiler if we have defined our custom constructor with parameters above.
person::~person(){cout&lt;&lt;"object is destroyed \n";} //unnecessary as it is automatically / implicitly created by compiler.
												   //
position position::operator+ (position pos){
position new_position;
new_position.x=x+pos.x;
new_position.y=y+pos.y;
return new_position;
}

bool position::operator ==(position pos){
	if(pos.x==position::x &amp;&amp; pos.y==position::y){
		return true;
	}
	else{
	return false;
	}
}

std::istream&amp; operator &gt;&gt; (std::istream &amp;input, position &amp;pos){
cout&lt;&lt;"enter x coordinates of this position"&lt;&lt;endl;
input&gt;&gt;pos.x;
cout&lt;&lt;"enter y coordinates of this position"&lt;&lt;endl;
input&gt;&gt;pos.y; 
cout&lt;&lt;"Thanks, position has been entered"&lt;&lt;endl;
return input;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; output, position pos){
output&lt;&lt;"x coordinates:"&lt;&lt;pos.x&lt;&lt;" Y coordinates:"&lt;&lt;pos.y&lt;&lt;endl;
return output;
}

</pre>

<div id="Introduction-Classes-Classes Across Multiple Program files-Using headerfile.h and the definition_file.cpp"><h4 id="Using headerfile.h and the definition_file.cpp" class="header"><a href="#Introduction-Classes-Classes Across Multiple Program files-Using headerfile.h and the definition_file.cpp">Using headerfile.h and the definition_file.cpp</a></h4></div>

<p>
Now compile the program with <code>g++ thisprogramname.cpp definition_program.cpp</code><br />
</p>

<pre cpp>
#include &lt;iostream&gt;
#include "headerfiles/classes.h"
using std::cout;
using std::endl;

int main()

{
	person p1, p2;
	p1.name="vishal";
	p2.name="naresh";
	position a,b;
	a.x=2;
	a.y=4;
	b.x=2;
	b.y=4;
	cout&lt;&lt;a&lt;&lt;" "&lt;&lt;b&lt;&lt;endl;
	if (a==b){
		cout&lt;&lt;"both positions are same"&lt;&lt;endl;
	}
	else{
		cout&lt;&lt;"both positions are different"&lt;&lt;endl;
	}

	
	return 0;
}

</pre>
<p>
`output:<br />
a default constructor is called since an object is created <br />
a default constructor is called since an object is created <br />
x coordinates:2 Y coordinates:4<br />
 x coordinates:2 Y coordinates:4<br />
</p>

<p>
both positions are same<br />
object is destroyed <br />
object is destroyed <br />
`<br />
</p>

<div id="Introduction-Classes-Inheritance"><h3 id="Inheritance" class="header"><a href="#Introduction-Classes-Inheritance">Inheritance</a></h3></div>
<p>
Assume that we have created a class for school_members. Now school_members can be teacher and students. We now want to create separate classes for student and teacher and inherit the methods and members of parent class (school_members), we can do so by just using : <br />
</p>

<p>
<code>class teacher: Public school_members{}</code><br />
<code>class student: Public school_members{}</code><br />
</p>

<p>
Even though we have not defined these classes, we can still create the objects and use the already available public members of Parent class. <br />
`teacher t1,t2;<br />
student s1,s2;<br />
s1.name="vishal";<br />
s2.name="naresh";<br />
t1.age=45;<br />
t2.age=50;<br />
`<br />
</p>
<div id="Introduction-Classes-Inheritance-Example1 (without header files)"><h4 id="Example1 (without header files)" class="header"><a href="#Introduction-Classes-Inheritance-Example1 (without header files)">Example1 (without header files)</a></h4></div>
<pre cpp>


#include&lt;iostream&gt;
using std::cout;
using std::endl;
using std::string;
class person{
	float bank_balance=15000;
	static int user_count;
	public:
		string name;
		string job;
		int age;
		float salary;
		static void get_user_count()
		{
			cout&lt;&lt;"total number of users are:"&lt;&lt;user_count&lt;&lt;endl; //each time an object is created we shall increase the count and each time an object is destroyed we decrease the count.
	//		cout&lt;&lt;age; //will throw some error as we can't use non static member inside static member method
		}
		float get_bank_balance()
		{
			return bank_balance;
		}
		
		person(string name, string job_name,int age_user, float salary_user ){
		cout&lt;&lt;"a custom constructor is called since an object is created using custom constructor\n";
		this-&gt;name=name;           // since both names are same, we need this-&gt; pointer
		job=job_name;       // or job=job_name;
		age=age_user;       // or age=age_user;
		salary=salary_user;
		user_count++;
		}
		
		person(){
		user_count++;
		cout&lt;&lt;"a default constructor is called since an object is created with default constructor\n";}
		~person(){
		user_count--;
		cout&lt;&lt;"object is destroyed using this destructor \n";} //unnecessary as it is automatically / implicitly created by compiler.

	};
	
int person::user_count = 0;

// here we can define new child classes called as teacher and student

class teacher : public person{
	public:
		teacher(string name, string job_name,int age_user, float salary_user ){
			this-&gt;name=name;           // since both names are same, we need this-&gt; pointer
			job=job_name;       // or job=job_name;
			age=age_user;       // or age=age_user;
			salary=salary_user;

		}
};
class student : public person{
	public:
		student(string name, string job_name,int age_user, float salary_user ){
			this-&gt;name=name;           // since both names are same, we need this-&gt; pointer
			job=job_name;       // or job=job_name;
			age=age_user;       // or age=age_user;
			salary=salary_user;

		}
};
int main()
{
teacher t1("teacher1","teacher",44,230000);
person::get_user_count();
student s1("student1","student",16,0000);
person::get_user_count();
cout&lt;&lt;"name of teacher1 is "&lt;&lt;t1.name&lt;&lt;endl;
cout&lt;&lt;"name of student is "&lt;&lt;s1.name&lt;&lt;endl;

return 0;
}


</pre>

<p>
`output:<br />
</p>

<p>
a default constructor is called since an object is created with default constructor<br />
total number of users are:1<br />
a default constructor is called since an object is created with default constructor<br />
total number of users are:2<br />
name of teacher1 is teacher1<br />
name of student is student1<br />
object is destroyed using this destructor <br />
object is destroyed using this destructor <br />
`<br />
</p>


<div id="Introduction-Classes-Inheritance-Example2 (with header files)"><h4 id="Example2 (with header files)" class="header"><a href="#Introduction-Classes-Inheritance-Example2 (with header files)">Example2 (with header files)</a></h4></div>

<ol>
<li>
first we will create the main function 
<pre cpp>


/* #include &lt;iostream&gt; //defined in classes.h so no need */
/* #include &lt;string.h&gt;  //defined in classes.h so no need*/
#include "classes.h"
/* using std::cout; //defined in classes.h so no need*/

int main(int argc, char *argv[])
{
	teacher t1;	
	t1.age=25;
	t1.name="prof. A J";
	cout&lt;&lt;t1.name&lt;&lt;" "&lt;&lt;t1.age&lt;&lt;endl;
	return 0;
}

</pre>

<li>
Then we shall add the declaration in header file , here in "classes.h"
<pre cpp>

#ifndef CLASSES_H
#define CLASSES_H

#include&lt;iostream&gt;
#include &lt;ostream&gt;
using std::string;
using std::endl;
using std::cout;
class person{
	float Bank_balance=15000;
 	public:
		std::string name;
		std::string job;
		int age;
		float salary;
		float get_bank_info();
		person(std::string name, string job_name,int age_user, float salary_user );
		person();
		~person();
};
class position{
	public:
		int x;
		int y;
		position operator+ (position pos);
		bool operator==(position pos);
	
};

class teacher: public person{
	public:
		teacher();
};
class student: public person{
	public:
		student();
};

std::istream&amp; operator&gt;&gt;(std::istream&amp; input, position pos);
std::ostream&amp; operator&lt;&lt;(std::ostream&amp; output, position pos);
#endif

</pre>

<li>
Then we shall define these functions in classes_across_files.cpp
<pre cpp>



#include &lt;iostream&gt;
using std::cout;
using std::endl;
#include "classes.h"

/* float person::Bank_balance=15000; */
float person::get_bank_info()
		{
			return Bank_balance;
		}
person::person(string name, string job_name,int age_user, float salary_user ){
		cout&lt;&lt;"a custom constructor is called since an object is created using custom constructor\n";
		this-&gt;name=name;
		this-&gt;job=job_name;
		this-&gt;age=age_user;
		this-&gt;salary=salary_user;
		}
person::person(){cout&lt;&lt;"a default constructor is called since an object is created \n";} //defining default constructor as it won't be created by compiler if we have defined our custom constructor with parameters above.
person::~person(){cout&lt;&lt;"object is destroyed \n";} //unnecessary as it is automatically / implicitly created by compiler.


teacher::teacher(){
	cout&lt;&lt;"teacher object is created with default constructor"&lt;&lt;endl;
}

student::student(){
	cout&lt;&lt;"student object is created with default constructor"&lt;&lt;endl;
}


//
position position::operator+ (position pos){
position new_position;
new_position.x=x+pos.x;
new_position.y=y+pos.y;
return new_position;
}

bool position::operator ==(position pos){
	if(pos.x==position::x &amp;&amp; pos.y==position::y){
		return true;
	}
	else{
	return false;
	}
}

std::istream&amp; operator &gt;&gt; (std::istream &amp;input, position &amp;pos){
cout&lt;&lt;"enter x coordinates of this position"&lt;&lt;endl;
input&gt;&gt;pos.x;
cout&lt;&lt;"enter y coordinates of this position"&lt;&lt;endl;
input&gt;&gt;pos.y; 
cout&lt;&lt;"Thanks, position has been entered"&lt;&lt;endl;
return input;
}

std::ostream&amp; operator&lt;&lt;(std::ostream&amp; output, position pos){
output&lt;&lt;"x coordinates:"&lt;&lt;pos.x&lt;&lt;" Y coordinates:"&lt;&lt;pos.y&lt;&lt;endl;
return output;
}


</pre>

<li>
Then we shall compile the main.cpp program  <code>g++ inheritance_with_header_files.cpp classes_across_files.cpp</code>

</ol>
<p>
`output: <br />
</p>

<p>
a default constructor is called since an object is created <br />
teacher object is created with default constructor<br />
prof. A J 25<br />
object is destroyed <br />
`<br />
</p>

<div id="Introduction-Classes-Polymorphism"><h3 id="Polymorphism" class="header"><a href="#Introduction-Classes-Polymorphism">Polymorphism</a></h3></div>
<p>
If we define same functions again in child class then which function will be called? , to resolve the conflict we use <code>virtual</code> keyword before the function which we want to ignore. Functions can be overloaded in case we have different types of arguments, or no arguments at all, but there can be two similar functions with same type of parameters. In that case we need the <code>virtual</code> keyword before the name of function which we would like to ignore. <br />
</p>

<p>
It is of two type:<br />
</p>
<ol>
<li>
Compile type

<ol>
<li>
function overloading (simply define same name functions with different data types, return types, or no parameters, better to use generic programming or use of templates.)

<li>
operator overloading

</ol>
<li>
Run type

<ol>
<li>
virtual functions

</ol>
</ol>
<p>
We have looked at function overloading and operator overloading. Now we shall look at virtual functions.<br />
</p>
<div id="Introduction-Classes-Polymorphism-Example (virtual functions):"><h4 id="Example (virtual functions):" class="header"><a href="#Introduction-Classes-Polymorphism-Example (virtual functions):">Example (virtual functions):</a></h4></div>
<pre cpp>

#include&lt;iostream&gt;
using std::cout;
using std::cin;
using std::endl;

class base{
	public:
		virtual	void fun(){
		cout&lt;&lt;"this is function of base class with no parameters"&lt;&lt;endl;
		}
		virtual	void fun(int a){
		cout&lt;&lt; "this is function of base class with some argument "&lt;&lt;endl;
		}

		virtual	void fun(double b){
		cout&lt;&lt;"this is function of base class for double parameters "&lt;&lt;endl;
		}
		
};

class child: public base{
public:
	void fun(){
	cout&lt;&lt;"this is function of child class and has no arguments"&lt;&lt;endl;
	}
	void fun(int a){
		cout&lt;&lt; "this is function in child class with some int argument "&lt;&lt;endl;
	}

	void fun(double b){
		cout&lt;&lt;"this is function called in child class for double parameters "&lt;&lt;endl;
	}
};

int main(){

child c1;
//now since c1 is object of child class , it inherits all public methods of base class, so if I call c1.fun() then which function will be called? It will call function of child class.
c1.fun(); 
//what if I define a pointer of base class and store address of child object in it?
base *basePtr;
basePtr = &amp;c1;
basePtr-&gt;fun(); //which function will be called now? it will call function of base class, but since we have given the address of child object, it must call function for child class objects.To do that we will put `virtual` keyword in front of function definition of base classes.
c1.fun(4);
c1.fun(4.3);
return 0;
}
</pre>

<p>
`output:<br />
</p>

<p>
this is function of child class and has no arguments<br />
this is function of child class and has no arguments<br />
this is function in child class with some int argument <br />
this is function called in child class for float parameters <br />
</p>

<p>
`<br />
</p>

    </div>

    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script type="text/javascript">
        document.querySelectorAll('pre').forEach(block => hljs.highlightBlock(block));

        // Fetch the linked page content and display the preview
        document.addEventListener("DOMContentLoaded", function () {
            const links = document.querySelectorAll("a.link");

            links.forEach(link => {
                link.addEventListener("mouseover", async function (event) {
                    let previewBox = link.nextElementSibling;

                    if (previewBox && previewBox.innerHTML.trim() === "") {
                        const url = link.href;
                        
                        try {
                            // Fetch the linked content
                            const response = await fetch(url);
                            const text = await response.text();

                            // Parse the response HTML and extract the first paragraph or a few lines
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(text, "text/html");
                            const firstParagraph = doc.querySelector('p') ? doc.querySelector('p').textContent : "No preview available.";
                            
                            // Truncate the content to 200 characters
                            const previewText = firstParagraph.slice(0, 200) + "...";
                            previewBox.innerHTML = previewText;

                        } catch (err) {
                            previewBox.innerHTML = "Preview not available.";
                        }

                        previewBox.style.display = "block";
                    }
                });

                link.addEventListener("mouseout", function () {
                    const previewBox = link.nextElementSibling;
                    if (previewBox) {
                        previewBox.style.display = "none";
                    }
                });
            });
        });
    </script>
</body>
</html>

