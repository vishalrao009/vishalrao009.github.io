<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="alternate" type="application/rss+xml" title="RSS" href="rss.xml">
    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css" />
    <title>gradientFLow</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> 
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <style>
        body {
            background-image: url('../Images/parchment.jpg');
            background-size: cover;
            background-repeat: no-repeat;
            background-attachment: fixed;
            margin: 0;
            font-family: Arial, sans-serif;
            padding: 3cm; /* Add 3cm padding on all sides */
        }

        #content {
            color: #333;
            font-size: 16px;
            line-height: 1.6;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: rgba(255, 255, 255, 0.5);
        }

        /* Mobile Styles */
        @media only screen and (max-width: 600px) {
            body {
                padding: 1cm; /* Adjust padding for smaller screens */
            }

            #content {
                padding: 10px; /* Adjust padding for smaller screens */
            }
        }
    </style>
</head>
<body>
    <div id="content">
        
<p>
Integrate the gradient flow equation using the Wilson or Zeuthen action with fixed or adaptive step sizes and measure various gauge constructs at each step. 
</p>


<pre cpp>

/*
 * main_gradientFlow.cpp
 *
 * Lukas Mazur
 *
 * Application for computing observables on configurations that have been smoothed using the gradient flow. If you have
 * a new observable that you would like to measure on flowed configurations, please add your code here. Try to follow
 * the example of other observables, e.g. by including an optional flag for measuring your observable, outputting using
 * the FileWriter, and so on.
 *
 */

#include "../simulateqcd.h"
#include "../modules/gradientFlow/gradientFlow.h"
#include "../modules/observables/topology.h"
#include "../modules/observables/weinberg.h"
#include "../modules/observables/blocking.h"
#include "../modules/observables/energyMomentumTensor.h"
#include "../modules/observables/colorElectricCorr.h"
#include "../modules/observables/colorMagneticCorr.h"
#include "../modules/gaugeFixing/gfix.h"
#include "../modules/gaugeFixing/polyakovLoopCorrelator.h"


#define USE_GPU true
//define precision
#if SINGLEPREC
#define PREC float
#else
#define PREC double
#endif


template&lt;class floatT&gt;
struct gradientFlowParam : LatticeParameters {

    //! ---------------------------------basic options you probably care about------------------------------------------
    Parameter&lt;std::string&gt; measurements_dir; //! where the output gets stored
    Parameter&lt;std::string&gt; force; //! wilson or zeuthen flow
    Parameter&lt;std::string&gt; RK_method; //! RK_method = {fixed_stepsize, adaptive_stepsize, adaptive_stepsize_allgpu}
    Parameter&lt;floatT&gt; start_step_size;
    Parameter&lt;floatT&gt; accuracy; //! only used for adaptive stepsize. difference between 2nd and 3rd order RK
    DynamicParameter&lt;floatT&gt; necessary_flow_times; //! these flow times will not be skipped over in the integration
    Parameter&lt;floatT, 2&gt; measurement_intervall; //! measurement_intervall[0]: start, [1]: stop

    //! ---------------------------------which observables should be measured on the flowed configuration?--------------

    Parameter&lt;bool&gt; plaquette;
    Parameter&lt;bool&gt; clover;
    Parameter&lt;bool&gt; cloverTimeSlices;
    Parameter&lt;bool&gt; topCharge;
    Parameter&lt;bool&gt; topChargeTimeSlices;
    Parameter&lt;bool&gt; topCharge_imp;
    Parameter&lt;bool&gt; topChargeTimeSlices_imp;
    Parameter&lt;bool&gt; topCharge_imp_imp;
    Parameter&lt;bool&gt; topChargeTimeSlices_imp_imp;
    Parameter&lt;bool&gt; weinberg;
    Parameter&lt;bool&gt; weinbergTimeSlices;
    Parameter&lt;bool&gt; weinberg_imp;
    Parameter&lt;bool&gt; weinbergTimeSlices_imp;
    Parameter&lt;bool&gt; weinberg_imp_imp;
    Parameter&lt;bool&gt; weinbergTimeSlices_imp_imp;
    Parameter&lt;bool&gt; ColorElectricCorrTimeSlices_naive;
    Parameter&lt;bool&gt; ColorElectricCorrTimeSlices_clover;
    Parameter&lt;bool&gt; ColorMagneticCorrTimeSlices_naive;
    Parameter&lt;bool&gt; ColorMagneticCorrTimeSlices_clover;
    Parameter&lt;bool&gt; RenormPolyakovSusc;

    Parameter&lt;bool&gt; topCharge_imp_block;
    Parameter&lt;bool&gt; topCharge_imp_imp_block;
    Parameter&lt;bool&gt; shear_bulk_corr_block;
    Parameter&lt;bool&gt; energyMomentumTensorTracelessTimeSlices;
    Parameter&lt;bool&gt; energyMomentumTensorTracefullTimeSlices;
    Parameter&lt;int&gt; binsize; //! the binsize used in the blocking method

    Parameter&lt;bool&gt; PolyakovLoopCorrelator;
    Parameter&lt;floatT&gt; GaugeFixTol;
    Parameter&lt;int&gt; GaugeFixNMax;
    Parameter&lt;int&gt; GaugeFixNUnitarize;

    Parameter&lt;std::string&gt; normFileDir; //! Normalization file needed for correlator class calcuations.

    //! ---------------------------------advanced options---------------------------------------------------------------

    Parameter&lt;bool&gt; use_unit_conf; //! for testing (or benchmarking purposes using fixed stepsize)
    Parameter&lt;bool&gt; save_conf;
    //! ignore start_step_size and integrate to the necessary_flow_times without steps in between.
    //! only useful when using RK_method fixed_stepsize
    Parameter&lt;bool&gt; ignore_fixed_startstepsize;

    gradientFlowParam() {
        addDefault(force, "force", std::string("zeuthen"));

        add(start_step_size, "start_step_size");

        addDefault(RK_method, "RK_method", std::string("adaptive_stepsize"));
        addDefault(accuracy, "accuracy", floatT(1e-5));

        addDefault(binsize, "binsize", 8);

        add(measurements_dir, "measurements_dir");

        addOptional(necessary_flow_times, "necessary_flow_times");
        addDefault(ignore_fixed_startstepsize, "ignore_start_step_size", false);

        addDefault(save_conf, "save_configurations", false);  //! write gauge conf to disk at each flow time

        addDefault(use_unit_conf, "use_unit_conf", false);

        add(measurement_intervall, "measurement_intervall");

        addDefault(plaquette, "plaquette", true);
        addDefault(clover, "clover", false);
        addDefault(cloverTimeSlices, "cloverTimeSlices", false);
        addDefault(topCharge, "topCharge", false);
        addDefault(topChargeTimeSlices, "topChargeTimeSlices", false);
        addDefault(topCharge_imp, "topCharge_imp", false);
        addDefault(topChargeTimeSlices_imp, "topChargeTimeSlices_imp", false);
        addDefault(topCharge_imp_imp, "topCharge_imp_imp", false);
        addDefault(topChargeTimeSlices_imp_imp, "topChargeTimeSlices_imp_imp", false);
        addDefault(topCharge_imp_block, "topCharge_imp_block", false);
        addDefault(topCharge_imp_imp_block, "topCharge_imp_imp_block", false);
        addDefault(weinberg, "Weinberg", false);
        addDefault(weinbergTimeSlices, "WeinbergTimeSlices", false);
        addDefault(weinberg_imp, "Weinberg_imp", false);
        addDefault(weinbergTimeSlices_imp, "WeinbergTimeSlices_imp", false);
        addDefault(weinberg_imp_imp, "Weinberg_imp_imp", false);
        addDefault(weinbergTimeSlices_imp_imp, "WeinbergTimeSlices_imp_imp", false);
        addDefault(shear_bulk_corr_block, "shear_bulk_corr_block", false);
        addDefault(energyMomentumTensorTracelessTimeSlices, "energyMomentumTensorTracelessTimeSlices", false);
        addDefault(energyMomentumTensorTracefullTimeSlices, "energyMomentumTensorTracefullTimeSlices", false);
        addDefault(ColorElectricCorrTimeSlices_naive, "ColorElectricCorrTimeSlices_naive", false);
        addDefault(ColorElectricCorrTimeSlices_clover, "ColorElectricCorrTimeSlices_clover", false);
        addDefault(ColorMagneticCorrTimeSlices_naive, "ColorMagneticCorrTimeSlices_naive", false);
        addDefault(ColorMagneticCorrTimeSlices_clover, "ColorMagneticCorrTimeSlices_clover", false);
        addDefault(RenormPolyakovSusc, "RenormPolyakovSusc", false);

        addDefault(PolyakovLoopCorrelator, "PolyakovLoopCorrelator", false);
        addDefault(GaugeFixTol, "GaugeFixTol", floatT(1e-6));
        addDefault(GaugeFixNMax, "GaugeFixNMax", 9000);
        addDefault(GaugeFixNUnitarize, "GaugeFixNUnitarize", 20);

        addDefault(normFileDir, "normFileDir", std::string("./"));
    }
};

template&lt;typename floatT, bool onDevice, size_t HaloDepth, RungeKuttaMethod RK_method, Force force&gt;
void run(CommunicationBase &amp;commBase, gradientFlowParam&lt;floatT&gt; &amp;lp) {

    initIndexer(HaloDepth, lp, commBase);
    Gaugefield&lt;floatT, onDevice, HaloDepth&gt; gauge(commBase);
    gradientFlow&lt;floatT, HaloDepth, RK_method, force&gt; gradFlow(gauge, lp.start_step_size(),
                                                                     lp.measurement_intervall()[0],
                                                                     lp.measurement_intervall()[1],
                                                                     lp.necessary_flow_times.get(), lp.accuracy());

    //! check for blocking method
    size_t numBlocks=lp.latDim()[0]/size_t(lp.binsize());

    if ( lp.topCharge_imp_block() || lp.shear_bulk_corr_block() ) {
        if (lp.latDim()[0]%(lp.nodeDim()[0]*lp.binsize()) != 0 || lp.latDim()[1]%(lp.nodeDim()[1]*lp.binsize()) != 0 || lp.latDim()[2]%(lp.nodeDim()[2]*lp.binsize()) != 0) {
            throw std::runtime_error(stdLogger.fatal("bin can not span between gpus"));
        }
        if (lp.latDim()[0]/lp.nodeDim()[0]&lt;lp.binsize() || lp.latDim()[1]/lp.nodeDim()[1]&lt;lp.binsize() || lp.latDim()[2]/lp.nodeDim()[2]&lt;lp.binsize()) {
            throw std::runtime_error(stdLogger.fatal("each gpu should be able to hold at least one block. please check your blocksize and nodeDim"));
        }
    }

    //! -------------------------------prepare file output--------------------------------------------------------------

    std::stringstream prefix, datName, datNameConf, datNameCloverSlices, datNameTopChSlices, datNameTopChSlices_imp, datNameTopChSlices_imp_imp,
            datNameBlockShear, datNameBlockBulk, datName_normEMT, datNameColElecCorrSlices_naive, datNameColMagnCorrSlices_naive,
            datNamePolyCorrSinglet, datNamePolyCorrOctet, datNamePolyCorrAverage, datNameColElecCorrSlices_clover,
            datNameColMagnCorrSlices_clover, datNameBlockTopCharge, datNameEMTUTimeSlices, datNameEMTETimeSlices,
            datNameRenormPolySuscA, datNameRenormPolySuscL, datNameRenormPolySuscT,
            datNameWeinbergSlices, datNameWeinbergSlices_imp, datNameWeinbergSlices_imp_imp;
    // fill stream with 0's
    datName.fill('0');
    // get the data file name
    if ( lp.RK_method() == "adaptive_stepsize" || lp.RK_method() == "adaptive_stepsize_allgpu" )
        prefix &lt;&lt; lp.force() &lt;&lt; "Flow_acc" &lt;&lt; std::fixed &lt;&lt; std::setprecision(6)
               &lt;&lt; lp.accuracy() &lt;&lt; "_sts" &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; lp.start_step_size();
    else {
        prefix &lt;&lt; lp.force() &lt;&lt; "Flow";
        if (not lp.ignore_fixed_startstepsize()) {
            prefix &lt;&lt; "_sts" &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; lp.start_step_size();
        }
    }
    datName &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; lp.fileExt();
    datNameConf &lt;&lt; lp.measurements_dir()&lt;&lt; "conf_" &lt;&lt; prefix.str() &lt;&lt; lp.fileExt();
    datNameCloverSlices &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_CloverTimeSlices" &lt;&lt; lp.fileExt();
    datNameTopChSlices &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_TopChTimeSlices" &lt;&lt; lp.fileExt();
    datNameTopChSlices_imp &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_TopChTimeSlicesImp" &lt;&lt; lp.fileExt();
    datNameTopChSlices_imp_imp &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_TopChTimeSlicesImpImp" &lt;&lt; lp.fileExt();
    datNameWeinbergSlices &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_WeinbergTimeSlices" &lt;&lt; lp.fileExt();
    datNameWeinbergSlices_imp &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_WeinbergTimeSlicesImp" &lt;&lt; lp.fileExt();
    datNameWeinbergSlices_imp_imp &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_WeinbergTimeSlicesImpImp" &lt;&lt; lp.fileExt();
    datNameColElecCorrSlices_naive &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_ColElecCorrTimeSlices_naive" &lt;&lt; lp.fileExt();
    datNameColMagnCorrSlices_naive &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_ColMagnCorrTimeSlices_naive" &lt;&lt; lp.fileExt();
    datNamePolyCorrSinglet &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_PolyakovCorrSinglet" &lt;&lt; lp.fileExt();
    datNamePolyCorrOctet &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_PolyakovCorrOctet" &lt;&lt; lp.fileExt();
    datNamePolyCorrAverage &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_PolyakovCorrAverage" &lt;&lt; lp.fileExt();
    datNameRenormPolySuscA &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_RenormPolySuscA" &lt;&lt; lp.fileExt();
    datNameRenormPolySuscL &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_RenormPolySuscL" &lt;&lt; lp.fileExt();
    datNameRenormPolySuscT &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_RenormPolySuscT" &lt;&lt; lp.fileExt();
    datNameBlockTopCharge &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_BlockTopCharge" &lt;&lt; lp.fileExt();
    datNameBlockShear &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_BlockShear" &lt;&lt; lp.fileExt();
    datNameBlockBulk &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_BlockBulk" &lt;&lt; lp.fileExt();
    datName_normEMT &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_NormEMT" &lt;&lt; lp.fileExt();
    datNameColElecCorrSlices_clover &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_ColElecCorrTimeSlices_clover" &lt;&lt; lp.fileExt();
    datNameColMagnCorrSlices_clover &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_ColMagnCorrTimeSlices_clover" &lt;&lt; lp.fileExt();
    datNameEMTUTimeSlices &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_EMTUTimeSlices" &lt;&lt; lp.fileExt();
    datNameEMTETimeSlices &lt;&lt; lp.measurements_dir() &lt;&lt; prefix.str() &lt;&lt; "_EMTETimeSlices" &lt;&lt; lp.fileExt();
    FileWriter file(gauge.getComm(), lp, datName.str());

    //! write header
    LineFormatter header = file.header();
    header &lt;&lt; "Flow time ";
    if (lp.plaquette()) header &lt;&lt; "Plaquette ";
    if (lp.clover()) header &lt;&lt; "Clover ";
    if (lp.topCharge()) header &lt;&lt; "Top. Charge ";
    if (lp.topCharge_imp() || lp.topCharge_imp_block()) header &lt;&lt; "Impr. top. Charge ";
    if (lp.topCharge_imp_imp() || lp.topCharge_imp_imp_block()) header &lt;&lt; "O(a^6) Impr. top. Charge ";
    if (lp.weinberg()) header &lt;&lt; "Weinberg ";
    if (lp.weinberg_imp()) header &lt;&lt; "Impr. Weinberg ";
    if (lp.weinberg_imp_imp()) header &lt;&lt; "O(a^6) Impr. Weinberg ";
    header.endLine();

    FileWriter file_BlockTopCharge(gauge.getComm(), lp);
    FileWriter file_normEMT(gauge.getComm(), lp);
    FileWriter file_BlockShear(gauge.getComm(), lp);
    FileWriter file_BlockBulk(gauge.getComm(), lp);
    if (lp.shear_bulk_corr_block()) {
        file_normEMT.createFile(datName_normEMT.str());
        file_BlockShear.createFile(datNameBlockShear.str());
        file_BlockBulk.createFile(datNameBlockBulk.str());
        LineFormatter header_normEMT = file_normEMT.header();
        header_normEMT &lt;&lt; "#flowtime E U00 U11 U22 U33 U01 U02 U03 U12 U13 U23" &lt;&lt; "\n";
        header_normEMT.endLine();
        LineFormatter header_BlockShear = file_BlockShear.header();
        header_BlockShear &lt;&lt; "#flowtime tau/a=0: #r/a1 #corr1 #r/a2 #corr2.... tau/a=1: #r/a1 #corr1...." &lt;&lt; "\n";
        header_BlockShear.endLine();
        LineFormatter header_BlockBulk = file_BlockBulk.header();
        header_BlockBulk&lt;&lt; "#flowtime tau/a=0: #r/a1 #corr1 #r/a2 #corr2.... tau/a=1: #r/a1 #corr1...." &lt;&lt; "\n";
        header_BlockBulk.endLine();
    }

    FileWriter file_EMTUTimeSlices(gauge.getComm(), lp);
    if (lp.energyMomentumTensorTracelessTimeSlices()) {
        file_EMTUTimeSlices.createFile(datNameEMTUTimeSlices.str());
        LineFormatter header_EMTUTimeSlices = file_EMTUTimeSlices.header();
        header_EMTUTimeSlices &lt;&lt; "#flowtime U00 U11 U22 U33 U01 U02 U03 U12 U13 U23 for tau=0, ... for tau=1 ..." &lt;&lt; "\n";
        header_EMTUTimeSlices.endLine();
    }

    FileWriter file_EMTETimeSlices(gauge.getComm(), lp);
    if (lp.energyMomentumTensorTracefullTimeSlices()) {
        file_EMTETimeSlices.createFile(datNameEMTETimeSlices.str());
        LineFormatter header_EMTETimeSlices = file_EMTETimeSlices.header();
        header_EMTETimeSlices &lt;&lt; "#flowtime E for tau=0, ... for tau=1 ..." &lt;&lt; "\n";
        header_EMTETimeSlices.endLine();
    }

    if (lp.topCharge_imp_block()) {
        file_BlockTopCharge.createFile(datNameBlockTopCharge.str());
        LineFormatter header_BlockTopCharge = file_BlockTopCharge.header();
        header_BlockTopCharge&lt;&lt; "#flow time tau/a=0: #r/a1 #corr1 #r/a2 #corr2.... tau/a=1: #r/a1 #corr1...." &lt;&lt; "\n";
        header_BlockTopCharge.endLine();
    }

    FileWriter filePolyCorrSinglet(gauge.getComm(), lp);
    FileWriter filePolyCorrOctet(gauge.getComm(), lp);
    FileWriter filePolyCorrAverage(gauge.getComm(), lp);
    if (lp.PolyakovLoopCorrelator()) {
        filePolyCorrSinglet.createFile(datNamePolyCorrSinglet.str());
        filePolyCorrOctet.createFile(datNamePolyCorrOctet.str());
        filePolyCorrAverage.createFile(datNamePolyCorrAverage.str());
    }

    FileWriter fileRenormPolySuscA(gauge.getComm(), lp);
    FileWriter fileRenormPolySuscL(gauge.getComm(), lp);
    FileWriter fileRenormPolySuscT(gauge.getComm(), lp);
    if (lp.RenormPolyakovSusc()) {
        fileRenormPolySuscA.createFile(datNameRenormPolySuscA.str());
        fileRenormPolySuscL.createFile(datNameRenormPolySuscL.str());
        fileRenormPolySuscT.createFile(datNameRenormPolySuscT.str());
    }

    FileWriter fileCloverSl(gauge.getComm(), lp);
    if (lp.cloverTimeSlices()) {
        fileCloverSl.createFile(datNameCloverSlices.str());
        LineFormatter headerClSl = fileCloverSl.header();
        headerClSl &lt;&lt; "Flow time ";
        for (int nt = 0; nt &lt; lp.latDim[3]; nt++) {
            headerClSl &lt;&lt; "Nt=" + std::to_string(nt) + " ";
        }
        headerClSl.endLine();
    }

    FileWriter fileTopChSl(gauge.getComm(), lp);
    if (lp.topChargeTimeSlices()) {
        fileTopChSl.createFile(datNameTopChSlices.str());
        LineFormatter headerThSl = fileTopChSl.header();
        headerThSl &lt;&lt; "Flow time ";
        for (int nt = 0; nt &lt; lp.latDim[3]; nt++) {
            headerThSl &lt;&lt; "Nt=" + std::to_string(nt) + " ";
        }
        headerThSl.endLine();
    }

    FileWriter fileTopChSl_imp(gauge.getComm(), lp);
    if (lp.topChargeTimeSlices_imp()) {
        fileTopChSl_imp.createFile(datNameTopChSlices_imp.str());
        LineFormatter headerThSl_imp = fileTopChSl_imp.header();
        headerThSl_imp &lt;&lt; "Flow time ";
        for (int nt = 0; nt &lt; lp.latDim[3]; nt++) {
            headerThSl_imp &lt;&lt; "Nt=" + std::to_string(nt) + " ";
        }
        headerThSl_imp.endLine();
    }

    FileWriter fileTopChSl_imp_imp(gauge.getComm(), lp);
    if (lp.topChargeTimeSlices_imp_imp()) {
        fileTopChSl_imp_imp.createFile(datNameTopChSlices_imp_imp.str());
        LineFormatter headerThSl_imp_imp = fileTopChSl_imp_imp.header();
        headerThSl_imp_imp &lt;&lt; "Flow time ";
        for (int nt = 0; nt &lt; lp.latDim[3]; nt++) {
            headerThSl_imp_imp &lt;&lt; "Nt=" + std::to_string(nt) + " ";
        }
        headerThSl_imp_imp.endLine();
    }

    FileWriter fileWeinbergSl(gauge.getComm(), lp);
    if (lp.weinbergTimeSlices()) {
        fileWeinbergSl.createFile(datNameWeinbergSlices.str());
        LineFormatter headerThSl = fileWeinbergSl.header();
        headerThSl &lt;&lt; "Flow time ";
        for (int nt = 0; nt &lt; lp.latDim[3]; nt++) {
            headerThSl &lt;&lt; "Nt=" + std::to_string(nt) + " ";
        }
        headerThSl.endLine();
    }
    
    FileWriter fileWeinbergSl_imp(gauge.getComm(), lp);
    if (lp.weinbergTimeSlices_imp()) {
        fileWeinbergSl_imp.createFile(datNameWeinbergSlices_imp.str());
        LineFormatter headerThSl_imp = fileWeinbergSl_imp.header();
        headerThSl_imp &lt;&lt; "Flow time ";
        for (int nt = 0; nt &lt; lp.latDim[3]; nt++) {
            headerThSl_imp &lt;&lt; "Nt=" + std::to_string(nt) + " ";
        }
        headerThSl_imp.endLine();
    }

    FileWriter fileWeinbergSl_imp_imp(gauge.getComm(), lp);
    if (lp.weinbergTimeSlices_imp_imp()) {
        fileWeinbergSl_imp_imp.createFile(datNameWeinbergSlices_imp_imp.str());
        LineFormatter headerThSl_imp_imp = fileWeinbergSl_imp_imp.header();
        headerThSl_imp_imp &lt;&lt; "Flow time ";
        for (int nt = 0; nt &lt; lp.latDim[3]; nt++) {
            headerThSl_imp_imp &lt;&lt; "Nt=" + std::to_string(nt) + " ";
        }
        headerThSl_imp_imp.endLine();
    }
    
    FileWriter fileColElecCorrSl_naive(gauge.getComm(), lp);
    if (lp.ColorElectricCorrTimeSlices_naive()) {
        fileColElecCorrSl_naive.createFile(datNameColElecCorrSlices_naive.str());
        LineFormatter headerColElecCorrSl_naive = fileColElecCorrSl_naive.header();
        headerColElecCorrSl_naive &lt;&lt; "Flow time ";
        headerColElecCorrSl_naive &lt;&lt; "Re(PolyLoop) ";
        headerColElecCorrSl_naive &lt;&lt; "Im(PolyLoop) ";
        for (int dt = 1; dt &lt;= lp.latDim[3]/2; dt++) {
            headerColElecCorrSl_naive &lt;&lt; "dt=" + std::to_string(dt) + "_real ";
        }
        for (int dt = 1; dt &lt;= lp.latDim[3]/2; dt++) {
            headerColElecCorrSl_naive &lt;&lt; "dt=" + std::to_string(dt) + "_imag ";
        }
        headerColElecCorrSl_naive.endLine();
    }

    FileWriter fileColMagnCorrSl_naive(gauge.getComm(), lp);
    if (lp.ColorMagneticCorrTimeSlices_naive()) {
        fileColMagnCorrSl_naive.createFile(datNameColMagnCorrSlices_naive.str());
        LineFormatter headerColMagnCorrSl_naive = fileColMagnCorrSl_naive.header();
        headerColMagnCorrSl_naive &lt;&lt; "Flow time ";
        headerColMagnCorrSl_naive &lt;&lt; "Re(PolyLoop) ";
        headerColMagnCorrSl_naive &lt;&lt; "Im(PolyLoop) ";
        for (int dt = 1; dt &lt;= lp.latDim[3]/2; dt++) {
            headerColMagnCorrSl_naive &lt;&lt; "dt=" + std::to_string(dt) + "_real ";
        }
        for (int dt = 1; dt &lt;= lp.latDim[3]/2; dt++) {
            headerColMagnCorrSl_naive &lt;&lt; "dt=" + std::to_string(dt) + "_imag ";
        }
        headerColMagnCorrSl_naive.endLine();
    }

    FileWriter fileColElecCorrSl_clover(gauge.getComm(), lp);
    if (lp.ColorElectricCorrTimeSlices_clover()) {
        fileColElecCorrSl_clover.createFile(datNameColElecCorrSlices_clover.str());
        LineFormatter headerColElecCorrSl_clover = fileColElecCorrSl_clover.header();
        headerColElecCorrSl_clover &lt;&lt; "Flow time ";
        headerColElecCorrSl_clover &lt;&lt; "Re(PolyLoop) ";
        headerColElecCorrSl_clover &lt;&lt; "Im(PolyLoop) ";
        for (int dt = 1; dt &lt;= lp.latDim[3]/2; dt++) {
            headerColElecCorrSl_clover &lt;&lt; "dt=" + std::to_string(dt) + "_real ";
        }
        for (int dt = 1; dt &lt;= lp.latDim[3]/2; dt++) {
            headerColElecCorrSl_clover &lt;&lt; "dt=" + std::to_string(dt) + "_imag ";
        }
        headerColElecCorrSl_clover.endLine();
    }

    FileWriter fileColMagnCorrSl_clover(gauge.getComm(), lp);
    if (lp.ColorMagneticCorrTimeSlices_clover()) {
        fileColMagnCorrSl_clover.createFile(datNameColMagnCorrSlices_clover.str());
        LineFormatter headerColMagnCorrSl_clover = fileColMagnCorrSl_clover.header();
        headerColMagnCorrSl_clover &lt;&lt; "Flow time ";
        headerColMagnCorrSl_clover &lt;&lt; "Re(PolyLoop) ";
        headerColMagnCorrSl_clover &lt;&lt; "Im(PolyLoop) ";
        for (int dt = 1; dt &lt;= lp.latDim[3]/2; dt++) {
            headerColMagnCorrSl_clover &lt;&lt; "dt=" + std::to_string(dt) + "_real ";
        }
        for (int dt = 1; dt &lt;= lp.latDim[3]/2; dt++) {
            headerColMagnCorrSl_clover &lt;&lt; "dt=" + std::to_string(dt) + "_imag ";
        }
        headerColMagnCorrSl_clover.endLine();
    }

    //! -------------------------------read in configuration------------------------------------------------------------

    if (lp.use_unit_conf()){
        rootLogger.info("Using unit configuration for tests/benchmarks");
        gauge.one();
    } else {
        if (lp.format() == "nersc") {
            gauge.readconf_nersc(lp.GaugefileName());
        } else if (lp.format() == "ildg") {
            gauge.readconf_ildg(lp.GaugefileName());
        } else if (lp.format() == "milc") {
            gauge.readconf_milc(lp.GaugefileName()); 
        } else if (lp.format() == "openqcd") {
            gauge.readconf_openqcd(lp.GaugefileName());
        } else {
            throw (std::runtime_error(rootLogger.fatal("Invalid specification for format ", lp.format())));
        }
    }
    gauge.updateAll();

    //! -------------------------------set up observable measurement classes--------------------------------------------

    GaugeAction&lt;floatT, USE_GPU, HaloDepth&gt; gAction(gauge);
    Topology&lt;floatT, USE_GPU, HaloDepth&gt; topology(gauge);
    Weinberg&lt;floatT, USE_GPU, HaloDepth&gt; weinberg(gauge);
    EnergyMomentumTensor&lt;floatT, USE_GPU, HaloDepth&gt; EMT(gauge);

    BlockingMethod&lt;floatT, true, HaloDepth, floatT, topChargeDens_imp&lt;floatT, HaloDepth, true&gt;, CorrType&lt;floatT&gt;&gt; BlockTopChDens(gauge);
    BlockingMethod&lt;floatT, true, HaloDepth, floatT, EMTtrace&lt;floatT, true, HaloDepth&gt;, CorrType&lt;floatT&gt;&gt; BlockBulk(gauge);
    BlockingMethod&lt;floatT, true, HaloDepth, Matrix4x4Sym&lt;floatT&gt;, EMTtraceless&lt;floatT, true, HaloDepth&gt;, CorrType&lt;floatT&gt;&gt; BlockShear(gauge);

    ColorElectricCorr&lt;floatT, USE_GPU, HaloDepth&gt; CEC(gauge);
    ColorMagneticCorr&lt;floatT, USE_GPU, HaloDepth&gt; CMC(gauge);
    PolyakovLoop&lt;floatT, USE_GPU, HaloDepth&gt; poly(gauge);
    GaugeFixing&lt;floatT,true,HaloDepth&gt; gFix(gauge);
    PolyakovLoopCorrelator&lt;floatT,true,HaloDepth&gt; PLC(gauge);
    CorrelatorTools&lt;floatT,true,HaloDepth&gt; corrTools;

    //! -------------------------------variables for the observables----------------------------------------------------

    floatT plaq, clov, topChar, wb;
    std::vector&lt;floatT&gt; resultClSl, resultThSl, resultThSl_imp, resultThSl_imp_imp, resultEMTETimeSlices;
    std::vector&lt;Matrix4x4Sym&lt;floatT&gt;&gt; resultEMTUTimeSlices;
    std::vector&lt;COMPLEX(floatT)&gt; resultColElecCorSl_naive, resultColMagnCorSl_naive, resultColElecCorSl_clover,
                                  resultColMagnCorSl_clover;

    COMPLEX(floatT) resultPoly;

    std::vector&lt;floatT&gt; vec_plca, vec_plc1, vec_plc8;
    std::vector&lt;int&gt;    vec_factor, vec_weight;
    if (lp.PolyakovLoopCorrelator()) {
        vec_plca   = std::vector&lt;floatT&gt;(corrTools.distmax);
        vec_plc1   = std::vector&lt;floatT&gt;(corrTools.distmax);
        vec_plc8   = std::vector&lt;floatT&gt;(corrTools.distmax);
        vec_factor = std::vector&lt;int&gt;(corrTools.distmax);
        vec_weight = std::vector&lt;int&gt;(corrTools.distmax);
        corrTools.getFactorArray(vec_factor, vec_weight);
    }

    std::vector&lt;Matrix4x4Sym&lt;floatT&gt;&gt; EMTUBlock(numBlocks*numBlocks*numBlocks*lp.latDim()[3]);
    std::vector&lt;floatT&gt; EMTEBlock(numBlocks*numBlocks*numBlocks*lp.latDim()[3]);
    std::vector&lt;floatT&gt; ShearCorr, BulkCorr;
    floatT EnergyDensity;
    Matrix4x4Sym&lt;floatT&gt; EMTensorTraceless;

    std::vector&lt;floatT&gt; TopChargeBlock(numBlocks*numBlocks*numBlocks*lp.latDim()[3]);
    std::vector&lt;floatT&gt; TopChargeDensCorr;
    size_t Rsq_size = (numBlocks/2+1)*(numBlocks/2+1)*3;
    floatT TopologicalCharge;

    floatT norm, suscL, suscT;
    COMPLEX(floatT) suscA;

    //! -------------------------------flow the field until max flow time-----------------------------------------------

    std::stringstream logStream;
    StopWatch&lt;true&gt; timer;
    timer.start();
    floatT flow_time = 0.;
    bool continueFlow = true;

    while (continueFlow) {

        //! -------------------------------prepare log output-----------------------------------------------------------

        logStream.str("");
        logStream &lt;&lt; std::fixed &lt;&lt; std::setprecision(7) &lt;&lt; "   t = " &lt;&lt; flow_time &lt;&lt; ": ";
        LineFormatter newLine = file.tag("");
        newLine &lt;&lt; flow_time;

        //! -------------------------------calculate observables on flowed field----------------------------------------

        if (lp.save_conf() &amp;&amp; gradFlow.checkIfnecessaryTime()){
            gauge.writeconf_nersc( datNameConf.str() + "_FT" + std::to_string(flow_time));
        }

        if (lp.plaquette()) {
            plaq = gAction.plaquette();
            logStream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; "   Plaquette = " &lt;&lt; plaq;
            newLine &lt;&lt; plaq;
        }

        if (lp.cloverTimeSlices()) {
            LineFormatter newLineCl = fileCloverSl.tag("");
            gAction.cloverTimeSlices(resultClSl);
            newLineCl &lt;&lt; flow_time;
            for (auto &amp;elem : resultClSl) {
                newLineCl &lt;&lt; elem;
            }
            gAction.dontRecomputeField();
        }

        if (lp.clover()) {
            clov = gAction.clover();
            logStream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; "   Clover = " &lt;&lt; clov;
            newLine &lt;&lt; clov;
            gAction.recomputeField();
        }

        if (lp.topChargeTimeSlices()) {
            LineFormatter newLineTh = fileTopChSl.tag("");
            topology.topChargeTimeSlices(resultThSl);
            newLineTh &lt;&lt; flow_time;
            for (auto &amp;elem : resultThSl) {
                newLineTh &lt;&lt; elem;
            }
            topology.dontRecomputeField();
        }

        if (lp.topCharge()) {
            topChar = topology.topCharge();
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; "   topCharge = " &lt;&lt; topChar;
//            logStream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; "   topCharge = " &lt;&lt; topChar;
            newLine &lt;&lt; topChar;
            topology.recomputeField();
        }

        if (lp.topChargeTimeSlices_imp()) {
            LineFormatter newLineTh = fileTopChSl_imp.tag("");
            topology.template topChargeTimeSlices&lt;true,false&gt;(resultThSl_imp);
            newLineTh &lt;&lt; flow_time;
            logStream &lt;&lt; "   topCharge_imp TimeSlices = ";
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; resultThSl_imp[0];
            for (auto &amp;elem : resultThSl_imp) {
                newLineTh &lt;&lt; elem;
            }
            topology.dontRecomputeField();
        }

        if (lp.topCharge_imp() &amp;&amp; !lp.topCharge_imp_block()) {
            topChar = topology.template topCharge&lt;true,false&gt;();
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; "   topCharge_imp = " &lt;&lt; topChar;
//            logStream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; "   topCharge_imp = " &lt;&lt; topChar;
            newLine &lt;&lt; topChar;
            topology.recomputeField();
        }

        if (lp.topChargeTimeSlices_imp_imp()) {
            LineFormatter newLineTh = fileTopChSl_imp_imp.tag("");
//            std::cout &lt;&lt; "topChargeTimeSlices_imp_imp" &lt;&lt; std::endl;
            topology.template topChargeTimeSlices&lt;false,true&gt;(resultThSl_imp_imp);
            newLineTh &lt;&lt; flow_time;
            logStream &lt;&lt; "   topCharge_imp_imp TimeSlices = ";
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; resultThSl_imp_imp[0];
            for (auto &amp;elem : resultThSl_imp_imp) {
                newLineTh &lt;&lt; elem;
            }
            topology.dontRecomputeField();
        }

        if (lp.topCharge_imp_imp()) {
            topChar = topology.template topCharge&lt;false,true&gt;();
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; "   topCharge_imp_imp = " &lt;&lt; topChar;
            newLine &lt;&lt; topChar;
            topology.recomputeField();
        }

        if (lp.topCharge_imp_block()) {
            TopologicalCharge = BlockTopChDens.updateBlock(TopChargeBlock, lp.binsize());
            TopChargeDensCorr = BlockTopChDens.getCorr(TopChargeBlock, lp.binsize());

            LineFormatter newLine_BlockTopCharge = file_BlockTopCharge.tag("");
            newLine_BlockTopCharge &lt;&lt; flow_time &lt;&lt; " ";

            for (size_t i=0;i&lt;TopChargeDensCorr.size();i++) {
                if (fabs(TopChargeDensCorr[i])&gt;1e-50) {
                    newLine_BlockTopCharge &lt;&lt; sqrt(i%Rsq_size)*lp.binsize() &lt;&lt; " " &lt;&lt; std::scientific &lt;&lt; std::setprecision(15) &lt;&lt; TopChargeDensCorr[i] &lt;&lt;" ";
                }
            }
            newLine_BlockTopCharge &lt;&lt; "\n";

            logStream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; "   topCharge_imp = " &lt;&lt; TopologicalCharge;
            newLine &lt;&lt; TopologicalCharge;
        }

      
        if (lp.weinbergTimeSlices()) {
            LineFormatter newLineTh = fileWeinbergSl.tag("");
            weinberg.WBTimeSlices(resultThSl);
            newLineTh &lt;&lt; flow_time;
            for (auto &amp;elem : resultThSl) {
                newLineTh &lt;&lt; elem;
            }
            weinberg.dontRecomputeField();
        }

        if (lp.weinberg()) {
            wb = weinberg.WB();
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; "   Weinberg = " &lt;&lt; wb;
//            logStream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; "   topCharge = " &lt;&lt; topChar;
            newLine &lt;&lt; wb;
            weinberg.recomputeField();
        }

        if (lp.weinbergTimeSlices_imp()) {
            LineFormatter newLineTh = fileWeinbergSl_imp.tag("");
            weinberg.template WBTimeSlices&lt;true,false&gt;(resultThSl_imp);
            newLineTh &lt;&lt; flow_time;
            logStream &lt;&lt; "   Weinberg_imp TimeSlices = ";
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; resultThSl_imp[0];
            for (auto &amp;elem : resultThSl_imp) {
                newLineTh &lt;&lt; elem;
            }
            weinberg.dontRecomputeField();
        }

        if (lp.weinberg_imp()) {
            wb = weinberg.template WB&lt;true,false&gt;();
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; "   Weinberg_imp = " &lt;&lt; topChar;
//            logStream &lt;&lt; std::fixed &lt;&lt; std::setprecision(6) &lt;&lt; "   topCharge_imp = " &lt;&lt; topChar;
            newLine &lt;&lt; wb;
            weinberg.recomputeField();
        }

        if (lp.weinbergTimeSlices_imp_imp()) {
            LineFormatter newLineTh = fileWeinbergSl_imp_imp.tag("");
            weinberg.template WBTimeSlices&lt;false,true&gt;(resultThSl_imp_imp);
            newLineTh &lt;&lt; flow_time;
            logStream &lt;&lt; "   Weinberg_imp_imp TimeSlices = ";
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; resultThSl_imp_imp[0];
            for (auto &amp;elem : resultThSl_imp_imp) {
                newLineTh &lt;&lt; elem;
            }
            weinberg.dontRecomputeField();
        }

        if (lp.weinberg_imp_imp()) {
            wb = weinberg.template WB&lt;false,true&gt;();
            logStream &lt;&lt; std::scientific &lt;&lt; std::setprecision(14) &lt;&lt; "   Weinberg_imp_imp = " &lt;&lt; topChar;
            newLine &lt;&lt; wb;
            weinberg.recomputeField();
        }



        if (lp.energyMomentumTensorTracelessTimeSlices() &amp;&amp; gradFlow.checkIfnecessaryTime()) {
            LineFormatter newLineEMTUTimeSlices = file_EMTUTimeSlices.tag("");
            EMT.EMTUTimeSlices(resultEMTUTimeSlices);
            newLineEMTUTimeSlices &lt;&lt; flow_time &lt;&lt; " ";
            for (auto &amp;elem : resultEMTUTimeSlices) {
                newLineEMTUTimeSlices &lt;&lt; std::scientific &lt;&lt; std::setprecision(15) &lt;&lt; elem.elems[0] &lt;&lt; " "
                                  &lt;&lt; elem.elems[1] &lt;&lt; " " &lt;&lt; elem.elems[2] &lt;&lt; " " &lt;&lt; elem.elems[3] &lt;&lt; " "
                                  &lt;&lt; elem.elems[4] &lt;&lt; " " &lt;&lt; elem.elems[5] &lt;&lt; " " &lt;&lt; elem.elems[6] &lt;&lt; " "
                                  &lt;&lt; elem.elems[7] &lt;&lt; " " &lt;&lt; elem.elems[8] &lt;&lt; " " &lt;&lt; elem.elems[9] &lt;&lt; " ";
            }
        }

        if (lp.energyMomentumTensorTracefullTimeSlices() &amp;&amp; gradFlow.checkIfnecessaryTime()) {
            LineFormatter newLineEMTETimeSlices = file_EMTETimeSlices.tag("");
            EMT.EMTETimeSlices(resultEMTETimeSlices);
            newLineEMTETimeSlices &lt;&lt; flow_time &lt;&lt; " ";
            for (auto &amp;elem : resultEMTETimeSlices) {
                newLineEMTETimeSlices &lt;&lt; std::scientific &lt;&lt; std::setprecision(15) &lt;&lt; elem &lt;&lt; " ";
            }
        }

        if (lp.shear_bulk_corr_block() &amp;&amp; gradFlow.checkIfnecessaryTime()) {

            EnergyDensity = BlockBulk.updateBlock(EMTEBlock, lp.binsize());
            BulkCorr = BlockBulk.getCorr(EMTEBlock, lp.binsize());

            EMTensorTraceless = BlockShear.updateBlock(EMTUBlock, lp.binsize());
            ShearCorr = BlockShear.getCorr(EMTUBlock, lp.binsize());

            LineFormatter newLine_BlockShear = file_BlockShear.tag("");
            newLine_BlockShear &lt;&lt; flow_time &lt;&lt; " ";

            LineFormatter newLine_BlockBulk = file_BlockBulk.tag("");
            newLine_BlockBulk &lt;&lt; flow_time &lt;&lt; " ";

            for (size_t i=0;i&lt;BulkCorr.size();i++) {
                if (fabs(BulkCorr[i])&gt;1e-50) {//skip empty(zero) entries
                    newLine_BlockBulk &lt;&lt; sqrt(i%Rsq_size)*lp.binsize() &lt;&lt; " " &lt;&lt; std::scientific &lt;&lt; std::setprecision(15) &lt;&lt; BulkCorr[i] &lt;&lt;" ";
                    newLine_BlockShear &lt;&lt; sqrt(i%Rsq_size)*lp.binsize() &lt;&lt; " " &lt;&lt; std::scientific &lt;&lt; std::setprecision(15) &lt;&lt; ShearCorr[i] &lt;&lt;" ";
                }
            }
            newLine_BlockShear &lt;&lt; "\n";
            newLine_BlockBulk &lt;&lt; "\n";

            LineFormatter newLine_normEMT = file_normEMT.tag("");
            newLine_normEMT &lt;&lt; flow_time &lt;&lt; " ";
            newLine_normEMT &lt;&lt; std::scientific &lt;&lt; std::setprecision(15) &lt;&lt; EnergyDensity &lt;&lt; " " &lt;&lt; EMTensorTraceless.elems[0] &lt;&lt; " "
                            &lt;&lt; EMTensorTraceless.elems[1] &lt;&lt; " " &lt;&lt; EMTensorTraceless.elems[2] &lt;&lt; " " &lt;&lt; EMTensorTraceless.elems[3] &lt;&lt; " "
                            &lt;&lt; EMTensorTraceless.elems[4] &lt;&lt; " " &lt;&lt; EMTensorTraceless.elems[5] &lt;&lt; " " &lt;&lt; EMTensorTraceless.elems[6] &lt;&lt; " "
                            &lt;&lt; EMTensorTraceless.elems[7] &lt;&lt; " " &lt;&lt; EMTensorTraceless.elems[8] &lt;&lt; " " &lt;&lt; EMTensorTraceless.elems[9] &lt;&lt;"\n";
        }

        if (lp.ColorElectricCorrTimeSlices_naive() &amp;&amp; gradFlow.checkIfnecessaryTime()) {
            //! print naive discretization for ce
            LineFormatter newLineColEl_naive = fileColElecCorrSl_naive.tag("");
            resultPoly = poly.getPolyakovLoop();
            resultColElecCorSl_naive = CEC.getColorElectricCorr_naive();
            newLineColEl_naive &lt;&lt; flow_time;
            newLineColEl_naive &lt;&lt; real(resultPoly);
            newLineColEl_naive &lt;&lt; imag(resultPoly);
            for (auto &amp;elem : resultColElecCorSl_naive) {
                newLineColEl_naive &lt;&lt; real(elem);
            }
            for (auto &amp;elem : resultColElecCorSl_naive) {
                newLineColEl_naive &lt;&lt; imag(elem);
            }
        }

        if (lp.ColorElectricCorrTimeSlices_clover() &amp;&amp; gradFlow.checkIfnecessaryTime()) {
            //! print clover discretization for ce
            LineFormatter newLineColEl_clover = fileColElecCorrSl_clover.tag("");
            resultPoly = poly.getPolyakovLoop();
            resultColElecCorSl_clover = CEC.getColorElectricCorr_clover();
            newLineColEl_clover &lt;&lt; flow_time;
            newLineColEl_clover &lt;&lt; real(resultPoly);
            newLineColEl_clover &lt;&lt; imag(resultPoly);
            for (auto &amp;elem : resultColElecCorSl_clover) {
                newLineColEl_clover &lt;&lt; real(elem);
            }
            for (auto &amp;elem : resultColElecCorSl_clover) {
                newLineColEl_clover &lt;&lt; imag(elem);
            }
        }

        if (lp.ColorMagneticCorrTimeSlices_naive() &amp;&amp; gradFlow.checkIfnecessaryTime()) {
            //! print naive discretization for cm
            LineFormatter newLineColMa_naive = fileColMagnCorrSl_naive.tag("");
            resultPoly = poly.getPolyakovLoop();
            resultColMagnCorSl_naive = CMC.getColorMagneticCorr_naive();
            newLineColMa_naive &lt;&lt; flow_time;
            newLineColMa_naive &lt;&lt; real(resultPoly);
            newLineColMa_naive &lt;&lt; imag(resultPoly);
            for (auto &amp;elem : resultColMagnCorSl_naive) {
                newLineColMa_naive &lt;&lt; real(elem);
            }
            for (auto &amp;elem : resultColMagnCorSl_naive) {
                newLineColMa_naive &lt;&lt; imag(elem);
            }
        }

        if (lp.ColorMagneticCorrTimeSlices_clover() &amp;&amp; gradFlow.checkIfnecessaryTime()) {
            //! print clover discretization for cm
            LineFormatter newLineColMa_clover = fileColMagnCorrSl_clover.tag("");
            resultPoly = poly.getPolyakovLoop();
            resultColMagnCorSl_clover = CMC.getColorMagneticCorr_clover();
            newLineColMa_clover &lt;&lt; flow_time;
            newLineColMa_clover &lt;&lt; real(resultPoly);
            newLineColMa_clover &lt;&lt; imag(resultPoly);
            for (auto &amp;elem : resultColMagnCorSl_clover) {
                newLineColMa_clover &lt;&lt; real(elem);
            }
            for (auto &amp;elem : resultColMagnCorSl_clover) {
                newLineColMa_clover &lt;&lt; imag(elem);
            }
        }

        if ((lp.PolyakovLoopCorrelator() &amp;&amp; gradFlow.checkIfnecessaryTime())) {
            Gaugefield&lt;floatT, false, HaloDepth&gt; gauge_host(gauge.getComm());
            gauge_host = gauge;
            int ngfstep=0;
            floatT gftheta=1e10;
            while ((ngfstep &lt; lp.GaugeFixNMax()) &amp;&amp; (gftheta &gt; lp.GaugeFixTol())) {
                // Compute starting GF functional and update the lattice.
                gFix.gaugefixOR();
                // Due to the nature of the update, we have to re-unitarize every so often.
                if ((ngfstep % lp.GaugeFixNUnitarize()) == 0) {
                    gauge.su3latunitarize();
                }
                // Re-calculate theta to determine whether we are sufficiently fixed.
                gftheta = gFix.getTheta();
                ngfstep += 1;
            }
            gauge.su3latunitarize(); // One final re-unitarization.
            PLC.PLCtoArrays(vec_plca, vec_plc1, vec_plc8, vec_factor, vec_weight, true);
            LineFormatter newLineplca = filePolyCorrAverage.tag("");
            LineFormatter newLineplc1 = filePolyCorrSinglet.tag("");
            LineFormatter newLineplc8 = filePolyCorrOctet.tag("");
            newLineplca &lt;&lt; flow_time;
            newLineplc1 &lt;&lt; flow_time;
            newLineplc8 &lt;&lt; flow_time;
            // Write final results to output file. Not every r^2 is possible on a lattice; this
            // construction ensures only those possible distances are output.
            for (int dx=0 ; dx&lt;corrTools.distmax ; dx++) {
                if (vec_factor[dx]&gt;0) {
                    newLineplca &lt;&lt; vec_plca[dx];
                    newLineplc1 &lt;&lt; vec_plc1[dx];
                    newLineplc8 &lt;&lt; vec_plc8[dx];
                }
            }
            gauge = gauge_host;
        }

        if (lp.RenormPolyakovSusc()) {

            // All susceptibility objects, instantiated here to save memory when RenormPolyakovSusc==False.
            CorrField&lt;false,SU3&lt;floatT&gt;&gt; thermalWilsonLine(gauge.getComm(), corrTools.vol3);
            Correlator&lt;false,COMPLEX(floatT)&gt; ABareSusc(gauge.getComm(), corrTools.USr2max);
            Correlator&lt;false,floatT&gt; LBareSusc(gauge.getComm(), corrTools.USr2max);
            Correlator&lt;false,floatT&gt; TBareSusc(gauge.getComm(), corrTools.USr2max);
            Correlator&lt;false,floatT&gt; CPUnorm(gauge.getComm(), corrTools.USr2max);
            LatticeContainerAccessor _thermalWilsonLine(thermalWilsonLine.getAccessor());
            LatticeContainerAccessor _ABareSusc(ABareSusc.getAccessor());
            LatticeContainerAccessor _LBareSusc(LBareSusc.getAccessor());
            LatticeContainerAccessor _TBareSusc(TBareSusc.getAccessor());
            LatticeContainerAccessor _CPUnorm(CPUnorm.getAccessor());

            // Get thermal Wilson line, the object out of which the susceptibilities is constructed.
            poly.PloopInArray(_thermalWilsonLine);
            resultPoly = poly.getPolyakovLoop();

            // Calculate susceptibilities.
            rootLogger.info("Remove contact term from chi_A, chi_L, chi_T...");
            corrTools.template correlateAt&lt;SU3&lt;floatT&gt;,COMPLEX(floatT),trAxtrBt&lt;floatT&gt;&gt;("spatial", thermalWilsonLine, thermalWilsonLine, CPUnorm, ABareSusc, false, lp.normFileDir());
            corrTools.template correlateAt&lt;SU3&lt;floatT&gt;,floatT,trReAxtrReB&lt;floatT&gt;&gt;("spatial", thermalWilsonLine, thermalWilsonLine, CPUnorm, LBareSusc, true, lp.normFileDir());
            corrTools.template correlateAt&lt;SU3&lt;floatT&gt;,floatT,trImAxtrImB&lt;floatT&gt;&gt;("spatial", thermalWilsonLine, thermalWilsonLine, CPUnorm, TBareSusc, true, lp.normFileDir());

            // Output.
            LineFormatter newLinePolySuscA = fileRenormPolySuscA.tag("");
            LineFormatter newLinePolySuscL = fileRenormPolySuscL.tag("");
            LineFormatter newLinePolySuscT = fileRenormPolySuscT.tag("");
            newLinePolySuscA &lt;&lt; flow_time;
            newLinePolySuscL &lt;&lt; flow_time;
            newLinePolySuscT &lt;&lt; flow_time;
            for(int ir2=0; ir2&lt;corrTools.USr2max+1; ir2++) {
                _CPUnorm.getValue&lt;floatT&gt;(ir2,norm);
                if(norm &gt; 0) {
                    _ABareSusc.getValue&lt;COMPLEX(floatT)&gt;(ir2,suscA);
                    _LBareSusc.getValue&lt;floatT&gt;(ir2,suscL);
                    _TBareSusc.getValue&lt;floatT&gt;(ir2,suscT);
                    newLinePolySuscA &lt;&lt; real(suscA);
                    newLinePolySuscL &lt;&lt; suscL;
                    newLinePolySuscT &lt;&lt; suscT;
                }
            }
            newLinePolySuscA &lt;&lt; resultPoly;
            newLinePolySuscL &lt;&lt; resultPoly;
            newLinePolySuscT &lt;&lt; resultPoly;
        }

        rootLogger.info(logStream.str());

        continueFlow = gradFlow.continueFlow(); //! check if the max flow time has been reached
        if (continueFlow){
            flow_time += gradFlow.updateFlow(); //! integrate flow equation up to next flow time
            gauge.updateAll();

            gAction.recomputeField();
            topology.recomputeField();
        }

    }
    timer.stop();
    rootLogger.info("complete time = " ,  timer.minutes() ,  " min");
}


int main(int argc, char *argv[]) {

    try {
        stdLogger.setVerbosity(DEBUG);
        CommunicationBase commBase(&amp;argc, &amp;argv);
        gradientFlowParam&lt;PREC&gt; lp;
        lp.readfile(commBase, "../parameter/applications/gradientFlow.param", argc, argv);
        commBase.init(lp.nodeDim());

        /// Convert input strings to enum for switching
        Force input_force = Force_map[lp.force()];
        RungeKuttaMethod input_RK_method = RK_map[lp.RK_method()];

        if (input_RK_method == fixed_stepsize &amp;&amp; lp.ignore_fixed_startstepsize() &amp;&amp; lp.necessary_flow_times.isSet()) {
            rootLogger.info("Ignoring fixed start_step_size. "
                                 "Stepsizes are dynamically deduced from necessary_flow_times.");
            lp.start_step_size.set(lp.measurement_intervall()[1]);
        }

        size_t input_HaloDepth = 1;
        if (input_force == wilson &amp;&amp; (lp.topCharge_imp() || lp.topChargeTimeSlices_imp() || lp.topCharge_imp_imp() || lp.topChargeTimeSlices_imp_imp())) {
            input_HaloDepth = 2;
        } else if (input_force == zeuthen ) {
            input_HaloDepth = 3;
        }

        //! loop over all templates and choose the one specified by the user
        static_for&lt;1, 4&gt;::apply([&amp;](auto i){
            const auto HaloDepth = static_cast&lt;size_t&gt;(i);
            static_for&lt;0, 3&gt;::apply([&amp;](auto j){
                const auto RKmethod = static_cast&lt;RungeKuttaMethod&gt;(static_cast&lt;int&gt;(j));
                static_for&lt;0, 2&gt;::apply([&amp;](auto k){
                    const auto myforce = static_cast&lt;Force&gt;(static_cast&lt;int&gt;(k));
                    if ( myforce == input_force &amp;&amp; RKmethod == input_RK_method &amp;&amp; HaloDepth == input_HaloDepth ) {
                        rootLogger.info("Initializing gradientFlow with RK_method=", RungeKuttaMethods[j], ", Force=", Forces[k]);
                        run&lt;PREC, USE_GPU, HaloDepth, RKmethod, myforce&gt;(commBase, lp);
                    }
                });
            });
        });
    }
    catch(const std::runtime_error &amp;error) {
        return 1;
    }
    return 0;
}



</pre>

    </div>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
    <script type="text/javascript">
        document.querySelectorAll('pre').forEach(block => hljs.highlightBlock(block));
    </script>
</body>
</html>

